<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for UNIX (Ubuntu Server LTS for x86-64 Containers) 2020.1.1 (Build 408U)" ts="2021-04-01 08:57:16">
<Routine name="Api.Config.inc" type="INC" timestamp="65834,73166.700652"><![CDATA[

#Define SRVPKG              Api.Config.Services
/// HTTP Status Code

#Define HTTP200                     ##class(%CSP.REST).%GetParameter("HTTP200OK")
#Define HTTP201                     ##class(%CSP.REST).%GetParameter("HTTP201CREATED")
#Define HTTP204                     ##class(%CSP.REST).%GetParameter("HTTP204NOCONTENT")
#Define HTTP400                     ##class(%CSP.REST).%GetParameter("HTTP400BADREQUEST")
#Define HTTP404                     ##class(%CSP.REST).%GetParameter("HTTP404NOTFOUND")
#Define HTTP409                     ##class(%CSP.REST).%GetParameter("HTTP409CONFLICT")


/// OTHERS

#Define switchNSSys                             New $NAMESPACE  Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
#Define restoreNS                               Set $NAMESPACE = ns
#Define CanSetProperty(%json,%property)         (%json.%IsDefined(%property)&&($Ascii(%json.%Get(%property))'=0))
#Define fillJSONFromArray(%array,%json)         Do ##class(dc.deploy.Utils).fillJSONFromArray(.%array,.%json)
#Define fillArrayFromJSON(%json,%array)         Do ##class(dc.deploy.Utils).fillArrayFromJSON(.%json,.%array)

#Define DBSysUpdateProperties       $LISTBUILD("ReadOnly","Size","ExpansionSize","MaxSize","GlobalJournalState","NewGlobalCollation","NewGlobalIsKeep","NewGlobalGrowthBlock","NewGlobalPointerBlock","ClusterMountMode","ResourceName","CompressionEngine")
#Define DBSysCreateProperties       $LISTBUILD("Directory","BlockSize","EncryptedDB","EncryptionKeyID","Size","ExpansionSize","MaxSize","MirrorDBName","MirrorSetName","GlobalJournalState","NewGlobalCollation","NewGlobalIsKeep","NewGlobalGrowthBlock","NewGlobalPointerBlock","ClusterMountMode","ResourceName","CompressionEngine")
]]></Routine>


<Routine name="IORedirect" type="INC" timestamp="65834,73166.130118"><![CDATA[

#Define OldIO                   %zIORedirect("OldIO")
#Define OldMnemonic             %zIORedirect("OldMnemonic")
#Define OldState                %zIORedirect("OldState")
#Define KillOldStateData        Kill $$$OldState, $$$OldMnemonic, $$$OldIO

#Define RedirectOutputHandler   %zIORedirect("OutputHandler")
#Define LastOutputHandler       %zIORedirect("LastOutputHandler")
#Define RedirectInputHandler    %zIORedirect("InputHandler")

#Define RedirectGbl             %zIORedirect("OutputGlobalName")
#Define RedirectGblName         $Get($$$RedirectGbl, $Name(^||IORedirect))

#Define RedirectStream          %zIORedirect("OutStream")
#Define RedirectInputStream     %zIORedirect("InputStream")

#Define RedirectString          %zIORedirect("OutString")
#Define RedirectInputString     %zIORedirect("InputString")

#Define ClearConfig             Kill %zIORedirect

#Define InputHandlerUTimeout    ($CLASSMETHOD($$$RedirectInputHandler,"%GetParameter","USETIMETOUT")=1)

#Define CallReadChar(%timeout)          $SELECT($$$InputHandlerUTimeout:$CLASSMETHOD($$$RedirectInputHandler,"InChar", %timeout),1:$CLASSMETHOD($$$RedirectInputHandler,"InChar"))
#Define CallReadString(%size,%timeout)  $SELECT($$$InputHandlerUTimeout:$CLASSMETHOD($$$RedirectInputHandler,"InString",%size,%timeout),1:$CLASSMETHOD($$$RedirectInputHandler,"InString",%size))
]]></Routine>
<Class name="Api.Config.Developers.ClassGenerator">
<Description>
Generator for 
- Swagger spec.
- REST Service implementation.
- Proxy class with Config package.
Classes in %SYS config package are pretty similar.
So, We can write easily an algorithm to generate needed classes.</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>65834,73166.747171</TimeChanged>
<TimeCreated>65834,73166.747171</TimeCreated>

<Property name="class">
<Description>
Configuration class</Description>
<Type>%Dictionary.CompiledClass</Type>
</Property>

<Property name="generatedClassName">
<Type>%String</Type>
</Property>

<Property name="outClass">
<Type>%Dictionary.ClassDefinition</Type>
<InitialExpression>##class(%Dictionary.ClassDefinition).%New()</InitialExpression>
</Property>

<Property name="parameters">
<Type>%Binary</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="temp">
<Type>%Binary</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="swaggerSpec">
<Type>%DynamicObject</Type>
</Property>

<Property name="restApp">
<Type>%String</Type>
<InitialExpression>"Api.Config.REST"</InitialExpression>
</Property>

<Method name="test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ;d ##class(Api.Config.Developers.ClassGenerator).test()
    tro
    TSTART
    
    Set swagger = {
        "swagger":"2.0",
        "host":"localhost:32773",
        "basePath":"/api/config",
        "schemes":[
            "http","https"
        ],
        "info":{
            "title":"IRIS Config API",
            "version":"0.0.1",
            "description":"Config API.",
            "contact":{
            "name":"Lorenzo Scalese",
            "email":"lorenzo.scalese@gmail.com",
            "url":"https://github.com/lscalese/Iris-Deploy-Utils-API/"
            },
            "license":{
            "name":"MIT",
            "url":"https://github.com/lscalese/Iris-Deploy-Utils-API/blob/master/LICENSE"
            }
        },
        "produces":[
            "application/json"
        ],
        "paths":{
            "/":{
                "get":{
                    "tags":[
                        "Developer"
                    ],
                    "operationId":"GetSpecification",
                    "description":"Swagger 2.0 specification",
                    "responses":{
                        "200":{
                            "description":"OK"
                        }
                    }
                }
            }
        },
        "definitions":{}
    }

    Set outPKG = "Api.Config.Services.", ptr = 0
    Set clsList = ..getConfigClassList() ;$LISTBUILD("Config.MapGlobals","Config.Journal")
    ;Set clsList = $LISTBUILD("Config.Databases")

    While $LISTNEXT(clsList, ptr, v) {
        Set gen = ..%New(v, outPKG _ $Piece(v,".",*), swagger)
        Set sc = gen.generate()

    }

    Set formatter=##class(%JSON.Formatter).%New()
    Set swaggerString = ""
    Do formatter.FormatToString(swagger, .swaggerString)
    ;w !,swaggerString
    
    Set file=##class(%File).%New($Get(parameters("outSwaggerFile"),"/irisrun/repo/GENERATOR.json"))
    Do file.Open("WSN")
    Do file.Write(swaggerString)
    Do file.SaveStream()


    Quit
]]></Implementation>
</Method>

<Method name="getConfigClassList">
<ClassMethod>1</ClassMethod>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Set classes("Cluster")=""
    Set classes("ConfigFile")=""
    Set classes("Databases")=""
    Set classes("Debug")=""
    Set classes("DeviceSubTypes")=""
    Set classes("Devices")=""
    Set classes("ECP")=""
    Set classes("ECPServers")=""
    Set classes("IO")=""
    Set classes("Journal")=""
    Set classes("LicenseServers")=""
    Set classes("MagTapes")=""
    Set classes("MapGlobals")=""
    Set classes("MapMirrors")=""
    Set classes("MapPackages")=""
    Set classes("MapRoutines")=""
    Set classes("MapShadows")=""
    Set classes("MirrorMember")=""
    Set classes("Mirrors")=""
    Set classes("Miscellaneous")=""
    Set classes("Monitor")=""
    Set classes("Namespaces")=""
    Set classes("SQL")=""
    Set classes("Shadows")=""
    Set classes("SqlSysDatatypes")=""
    Set classes("SqlUserDatatypes")=""
    Set classes("Startup")=""
    Set classes("Telnet")=""
    Set classes("config")=""
    
    
    Set class = ""
    For  {
        Set class = $Order(classes(class))
        Quit:class=""
        Set $List(lst,*+1) = "Config."_class
        
    }
    Quit lst
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec><![CDATA[configClassName:%String,generatedClassName:%String,swagger:%DynamicObject={{}},&parameters:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, ns = $NAMESPACE 
    
    New $NAMESPACE 
    Set $NAMESPACE= "%SYS"
    
    Set ..class = ##class(%Dictionary.CompiledClass).%OpenId(configClassName,,.sc)
    Quit:$$$ISERR(sc) sc
    
    Set $NAMESPACE= ns
    Set ..swaggerSpec = swagger
    If '$$$defClassDefined(generatedClassName) {
        Set ..outClass = ##class(%Dictionary.ClassDefinition).%New()
        Set ..outClass.Name = generatedClassName
        Set ..outClass.IncludeCode = "Api.Config.inc"
        Set ..outClass.ProcedureBlock = $$$YES
    } Else {
        Set ..outClass = ##class(%Dictionary.ClassDefinition).%OpenId(generatedClassName)
    }
    
    If $Data(parameters) {
        Merge ..parameters = parameters
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="generate">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, ns = $NAMESPACE, key = "", template = {}
    
    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }

    New $NAMESPACE 
    
    Do ..log("Start Generating Class "_..outClass.Name)

    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    $$$QuitOnError(..ToDynamic())
    $$$QuitOnError(..ToArray())
    $$$QuitOnError(..Get())
    $$$QuitOnError(..Exists())
    $$$QuitOnError(..Create())
    $$$QuitOnError(..Update())
    $$$QuitOnError(..Delete())
    $$$QuitOnError(..CheckModel())
    $$$QuitOnError(..ObjectToArray())
    $$$QuitOnError(..List())

    For  {
        Set $NAMESPACE= "%SYS", property = ..class.Properties.GetNext(.key), $NAMESPACE= ns

        Quit:key=""
        Continue:..skipProperty(property)

        Set dflt = ""
        If property.InitialExpression '= "" {
            Set $NAMESPACE= "%SYS"
            Try { ; attempt to evaluate InitialExpression
                XECUTE ("(out) SET out="_ property.InitialExpression, .dflt)
            } Catch(ex) { 
                Do ..log("Evaluate initial expression failed for "_property.Name_" : "_property.InitialExpression)
            }
            Set $NAMESPACE= ns
        }
        
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))

        Do ToDynamic, ToArray, CheckModel, SwaggerDefinition, ObjectToArray

    }

    
    
    Do ..wlMethod($CHAR(9)_"Quit model", "ToDynamic")
    Do ..wlMethod($CHAR(9)_"Quit", "ToArray")
        
    Do ..wlMethod($CHAR(9)_"Quit sc", "CheckModel")
    Do ..wlMethod($CHAR(9)_"Quit", "ObjectToArray")

    Set clsKey = $Piece(..class.Name, ".", *)
    ;Set clsKey = $s($e(clsKey,*)="s":$e(clsKey,1,*-1),1:clsKey)
    
    Set swaggerDef.example = template
    
    Set:'$ISOBJECT(..swaggerSpec.definitions) ..swaggerSpec.definitions = {}
    Do:swaggerDef.required.%Size()=0 swaggerDef.%Remove("required")

    Do ..swaggerSpec.definitions.%Set(clsKey, swaggerDef)

    If ..configQueryExists("List") {
        Set listOf = {
            "type":"object",
            "properties": {}
        }
        Do listOf.properties.%Set(clsKey, {
            "type":"array",
            "items":{
                "$ref":("#/definitions/"_clsKey)
            }
        })
        Set lisOfPropertyName = "ListOf"_$$$UPPER($Extract(clsKey))_$Extract(clsKey,2,*)
        Set ..temp("RESTGEN","listof") = lisOfPropertyName
        Do ..swaggerSpec.definitions.%Set(lisOfPropertyName, listOf)
    }

    Do ..Path(clsKey)
    Set sc = ##class(%REST.API).CreateApplication(..restApp,..swaggerSpec)
    Do ..log("Update CSP REST application : "_$SYSTEM.Status.GetOneErrorText(sc))
    Do ..addRestImpl()
    Set sc = ..outClass.%Save()
    
    Quit sc

ToDynamic
    Set line = $CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType)
    Do ..wlMethod(line, "ToDynamic")
    Quit 1 ; Quit 1 for the pleasure of SonarQube :p

ToArray
    If 'property.ReadOnly {
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do ..wlMethod(line, "ToArray")
    }
    Quit 1

CheckModel
    If dflt=""&&property.Required {
        Set line = $CHAR(9) _ $$$FormatText("Set:model.%1="""" sc = $$$ADDSC(sc,$$$ERROR(5001, ""%1 property is mandatory.""))",property.Name)
        Do ..wlMethod(line,"CheckModel")
    }
    Quit 1

SwaggerDefinition
    If dflt=""&&property.Required {
        Do swaggerDef.required.%Push(property.Name)
        Do template.%Set(property.Name, dflt, jsonType)
    }

    Set description = ..getPropertyDescription(property.Name)

    Do swaggerDef.properties.%Set(property.Name, {
        "type" : (swaggerType),
        "default" : (dflt),
        "description" : (description)
    })

    Quit 1

ObjectToArray
    Set line = $CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name)
    Do ..wlMethod(line, "ObjectToArray")
    Quit 1
]]></Implementation>
</Method>

<Method name="wlMethod">
<FormalSpec>line:%String,methodName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set method = $Get(..temp(methodName))
    Quit:'$ISOBJECT(method) $$$OK
    ;Do ..log(methodName _" "_line)
    Do method.Implementation.WriteLine(line)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Path">
<FormalSpec>clsKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    Set service = {}
    
    Set serviceKey = "/"_$$$LOWER(clsKey)_"/", serviceKeyLocation = "%request.Application_"""_serviceKey_""""

    If '..isCommonSingle() {
        Do ..GetFormalSpec("Get",.callString)
        Set lst = $LISTFROMSTRING(callString, ","), ptr = 0
        
        While $LISTNEXT(lst, ptr, param) {
            Set serviceKey = serviceKey _ $Select($Extract(serviceKey,*)'="/":"/",1:"") _ $Replace("{%1}","%1",$$$LOWER(param))
            Set serviceKeyLocation = serviceKeyLocation _ "_"_$$$LOWER(param) _"/"
            Set rmTrailing=1
        }
        Set:$Get(rmTrailing) serviceKeyLocation = $Extract(serviceKeyLocation,1,*-1)
    }

    Set ..temp("RESTGEN","location")=serviceKeyLocation

    Do service.%Set("get", ..SwaggerGet(clsKey,.operationId))
    Set ..temp("RESTMETHOD","RESTTemplateGET")=operationId
    Do service.%Set("put", ..SwaggerPut(clsKey,.operationId))
    Set ..temp("RESTMETHOD","RESTTemplatePUT")=operationId

    If '..isCommonSingle() {
        Do service.%Set("post", ..SwaggerPost(clsKey,.operationId))
        Set ..temp("RESTMETHOD","RESTTemplatePOST")=operationId
        Do service.%Set("delete", ..SwaggerDelete(clsKey,.operationId))
        Set ..temp("RESTMETHOD","RESTTemplateDELETE")=operationId
    }
    

    Do ..swaggerSpec.paths.%Set(serviceKey, service)

    ;If "/"_$$$LOWER(clsKey)_"/"'=serviceKey,..configQueryExists("List") {
    If '..isCommonSingle(),..configQueryExists("List") {
        If ..isCommonMapMethods() {
            Set serviceKey = "/"_$$$LOWER(clsKey)_"/{namespace}/" 
        } Else {
            Set serviceKey = "/"_$$$LOWER(clsKey)_"/"
        }
        Do ..swaggerSpec.paths.%Set(serviceKey, {"get":(..SwaggerGetList(clsKey,.operationId))})
        Set ..temp("RESTMETHOD","RESTTemplateGETList")=operationId
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="addRestImpl">
<FormalSpec>class:%String=..restApp_".impl"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Set cdef = ##class(%Dictionary.ClassDefinition).%OpenId(class)
    Set cdef.IncludeCode = "Api.Config.inc"
    Do cdef.%Save()

    #dim mdef As %Dictionary.MethodDefinition
    Set mTemplate = ""
    For  {
        Set mTemplate = $Order(..temp("RESTMETHOD",mTemplate),1,methodName)
        Quit:mTemplate=""
        
        Set mdef = ##class(%Dictionary.MethodDefinition).%OpenId(class _ "||" _ methodName)
        Set template=$METHOD(##this,mTemplate)
        Set buff = template.Read()
        Set replace = ""
        For  {
            Set replace = $Order(..temp("RESTGEN",replace),1,value)
            Quit:replace=""
            Set buff = $replace(buff, "{{"_replace_"}}", value)
        }
        w !,methodName
        Do mdef.Implementation.Clear()
        Do mdef.Implementation.Write(buff)
        Set sc2 = mdef.%Save()
        Do ..log("Add REST method implementation "_ methodName _ " "_$SYSTEM.Status.GetOneErrorText(sc2))
        Set:$$$ISERR(sc2) sc = $$$ADDSC(sc,sc2)
    }
    
    Quit sc
]]></Implementation>
</Method>

<Method name="SwaggerDelete">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[

    Set verb = "delete"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()

    Set responses = {
        "204": {
            "description" : (clsKey _" deleted.")
            
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "404" : {
            "description" : (clsKey _ " not found.")
        }
    }

    Set desc = "Delete "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }

    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerPut">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "put"
    Set parameters = ..SwggerGetCommonParam()
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Do parameters.%Push({
        "name": "model",
        "description" : (clsKey _ " to update."),
        "in": "body",
        "required":true,
        "schema": {
            "$ref": ("#/definitions/" _ clsKey)
        }
    })

    Set responses = {
        "204" : {
            "description": "Ressource updated."
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "404" : {
            "description" : (clsKey _ " to update not found.")
        }
    }

    Set desc = "Update "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }

    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerPost">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "post"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()
    
    Do parameters.%Push({
        "name": "model",
        "description" : (clsKey _ " to create."),
        "in": "body",
        "required":true,
        "schema": {
            "$ref": ("#/definitions/" _ clsKey)
        }
    })

    
    Set responses = {
        "201": {
            "description" : (clsKey _" created."),
            "headers": {
                "Location": {
                    "type":"string",
                    "description":"Created ressource location."
                }
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty"
        },
        "409" : {
            "description" : ( clsKey _ " already exists.")
        }
    }

    Set desc = "Create "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerGetList">
<FormalSpec>clsKey,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "get"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _"List"_ clsKey)
    Set parameters = []

    Do:..isCommonMapMethods() parameters.%Push({
        "name": "namespace",
        "description" : "namespace.",
        "in": "path",
        "required":true,
        "type":"string"
    })
    
    Set responses = {
        "200": {
            "description" : "OK",
            "schema": {
                "$ref": ("#/definitions/ListOf" _ clsKey)
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty."
        }
    }
    Set desc = "Get List Of "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwaggerGet">
<FormalSpec>clsKey:%String,*operationId</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set verb = "get"
    Set operationId =($$$UPPER($Extract(verb)) _ $Extract(verb, 2, *) _ clsKey)
    Set parameters = ..SwggerGetCommonParam()

    Set responses = {
        "200": {
            "description" : "OK",
            "schema": {
                "$ref": ("#/definitions/" _ clsKey)
            }
        },
        "400" : {
            "description" : "Bad request, can occurs if mandatory parameters are missing or empty."
        },
        "404" : {
            "description" : (clsKey _ " not found.")
        }
    }
    Set desc = "Get "_clsKey _ "."
    Set method = {
        "operationId" : (operationId),
        "description": (desc),
        "parameters" : (parameters),
        "responses" : (responses)
    }
    
    Quit method
]]></Implementation>
</Method>

<Method name="SwggerGetCommonParam">
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set parameters = []
    ;
    ;w !,"..isCommonSingle() : ",..isCommonSingle(),!
    Set ..temp("RESTGEN","params")="", ..temp("RESTGEN","getlistparams")=""

    If '..isCommonSingle() {
        Do ..GetFormalSpec("Get",.callString)
        ;w !,"call string " ,callString,!
        Set lst = $LISTFROMSTRING(callString, ","), ptr = 0, params=""
        
        While $LISTNEXT(lst, ptr, param) {
            Set description = ..getPropertyDescription(param)
            Do parameters.%Push({
                "name" : ($$$LOWER(param)),
                "description" : (description),
                "in" : "path",
                "type" : "string",
                "required" : true
            })
            Set params = params_","_$$$LOWER(param)
            ;w !,"desc ",description
        }
    
        Set ..temp("RESTGEN","params")=$Extract(params,2,*)
    
    } 
    
    If ..isCommonMapMethods() {
        Set ..temp("RESTGEN","getlistparams") = $Piece(..temp("RESTGEN","params"),",",1)
    }

    Quit parameters
]]></Implementation>
</Method>

<Method name="ToDynamic">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK

    Do ..log(" * Generate method ToDynamic : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||ToDynamic" ) {
        Set mToDynamic = ##class(%Dictionary.MethodDefinition).%New()
        Set mToDynamic.Name = "ToDynamic"
        Set mToDynamic.ClassMethod = $$$YES
        Set mToDynamic.FormalSpec = "&properties:%Binary" ; "pObj:"_className
        Set mToDynamic.ReturnType = "%Library.DynamicObject"
        Do mToDynamic.Implementation.WriteLine($CHAR(9) _ "Set model = {}")
        Do ..outClass.Methods.Insert(mToDynamic)
        Set ..temp("ToDynamic")=mToDynamic
        Do ..log( "Initialized.", 0)
    } Else {
        Do ..log( "Already exists (skipped).", 0)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="ToArray">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..log(" * Generate method ToArray : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||ToArray") {
        Set mToArray = ##class(%Dictionary.MethodDefinition).%New()
        Set mToArray.Name = "ToArray"
        Set mToArray.ClassMethod = $$$YES
        Set mToArray.FormalSpec = "model:%Library.DynamicObject,*properties:%Binary"
        Set mToArray.ReturnType = ""
        Do ..outClass.Methods.Insert(mToArray)
        Set ..temp("ToArray")=mToArray
        Do ..log( "Initialized.", 0)
    } Else {
        Do ..log( "Already exists (skipped).", 0)
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="Get">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..log(" * Generate method Get : ")
    Set methodName = "Get"
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name_"||"_methodName) {
        #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Library.DynamicObject"
        If ..isCommonSingle() {
            Set args = ""
        } Else {
            Set method.FormalSpec = ..GetFormalSpec(methodName, .callString)
            Do method.Implementation.WriteLine($CHAR(9) _ "Quit:'..Exists(" _ callString _ ") """"")
            Set args = $Select(callString'="":callString_",",1:"")
        }
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("$$$ThrowOnError(##class(%1).Get("_args_".properties))", ..class.Name))
        Do method.Implementation.WriteLine($CHAR(9) _ "Quit ..ToDynamic(.properties)")
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","get") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Exists">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Exists"
    Quit:'..configMethodExists(methodName) sc

    Quit:..isCommonSingle() sc

    Do ..log(" * Generate method Exists : ")
    
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||"_methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Boolean"
        Set method.FormalSpec = ..GetFormalSpec("Get", .callString) 
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Exists("_callString_")", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
     Set ..temp("RESTGEN","exists") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Create"
    Quit:'..configMethodExists(methodName) sc
    
    Set ns = $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit:$CLASSMETHOD(..class.Name,"%Extends","Config.CommonSingleMethods") sc
    Set $NAMESPACE = ns

    Do ..log(" * Generate method Create : ")

    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = "model:%Library.DynamicObject"
        Do ..GetFormalSpec("Get", .callString, "model.")
        Do method.Implementation.WriteLine($CHAR(9) _ "Do ..ToArray(model,.properties)")
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Set args = $Select(callString'="":callString_",",1:"")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Create("_args_".properties)", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)

    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","create") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Update">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Update"
    Quit:'..configMethodExists("Modify") sc
    Do ..log(" * Generate method Update : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = "model:%Library.DynamicObject"
        If '..isCommonSingle() {
            Do ..GetFormalSpec("Get", .callString, "model.") 
            Set args = $Select(callString'="":callString_",",1:"")
        } Else {
            Set args = ""
        }
        Do method.Implementation.WriteLine($CHAR(9) _ "Do ..ToArray(model,.properties)")
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
       
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Modify("_args_".properties)", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","update") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="Delete">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "Delete"
    Quit:'..configMethodExists(methodName) sc
    Do ..log(" * Generate method Delete : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%Status"
        Set method.FormalSpec = ..GetFormalSpec("Get", .callString) 
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Quit ##class(%1).Delete("_callString_")", ..class.Name))
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","delete") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="CheckModel">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName =  "CheckModel"
    Do ..log(" * Generate method CheckModel : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _methodName) {
        Set checkModelMethod = ##class(%Dictionary.MethodDefinition).%New()
        Set checkModelMethod.Name = methodName
        Set checkModelMethod.ClassMethod = $$$YES
        Set checkModelMethod.ReturnType = "%Status"
        Set checkModelMethod.FormalSpec = "model:%Library.DynamicObject"
        Do checkModelMethod.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")
        Do ..outClass.Methods.Insert(checkModelMethod)
        Set ..temp(methodName)=checkModelMethod
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Set ..temp("RESTGEN","checkmodel") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)
    Quit sc
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "ObjectToArray"
    Do ..log(" * Generate method ObjectToArray : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _methodName) {
        Set mObjectToArray = ##class(%Dictionary.MethodDefinition).%New()
        Set mObjectToArray.Name = methodName
        Set mObjectToArray.ClassMethod = $$$YES
        Set mObjectToArray.ReturnType = ""
        Set mObjectToArray.FormalSpec = "&pObj,*properties:%Binary"
        Do ..outClass.Methods.Insert(mObjectToArray)
        Do ..outClass.Methods.Insert(mObjectToArray)
        Set ..temp(methodName)=mObjectToArray
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="List">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK, methodName = "List"
    Quit:'..configQueryExists(methodName) sc
    Set ns = $NAMESPACE
    New $NAMESPACE

    Do ..log(" * Generate method List : ")
    If '##class(%Dictionary.MethodDefinition).%ExistsId(..outClass.Name _ "||" _ methodName) {
        Set method = ##class(%Dictionary.MethodDefinition).%New()
        Set method.Name = methodName
        Set method.ClassMethod = $$$YES
        Set method.ReturnType = "%DynamicArray"
        Set method.FormalSpec = ..GetFormalSpecList(.callString)
        Do method.Implementation.WriteLine($CHAR(9) _ "$$$switchNSSys")
        Do method.Implementation.WriteLine($CHAR(9) _ "Set list = []")
        Do method.Implementation.WriteLine($CHAR(9) _ "Try{")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Set rs=##class(%Library.ResultSet).%New("""_..class.Name_":List"")")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Do rs.Execute("_callString_")")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "While rs.Next() {")
        
        Set $NAMESPACE = "%SYS"
        Set paramsGet = ""
        If $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonSingleMethods") {
            Set paramsGet = ""
        } ElseIf $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonMapMethods") {
            Set paramsGet = "Namespace, rs.Data(""Name"")"
        } ElseIf $CLASSMETHOD(..class.Name, "%Extends", "Config.CommonMultipleMethods") {
            Set paramsGet = "rs.Data(""Name"")"
        }
        Set $NAMESPACE = ns

        Do method.Implementation.WriteLine($CHAR(9,9,9) _ "Do list.%Push(..Get("_paramsGet_"))")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "}")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "Do rs.Close()")
        Do method.Implementation.WriteLine($CHAR(9,9) _ "$$$restoreNS")
        Do method.Implementation.WriteLine($CHAR(9) _"}Catch(ex) {")
        Do method.Implementation.WriteLine($CHAR(9,9) _"$$$restoreNS")
        Do method.Implementation.WriteLine($CHAR(9,9)_"Throw ex")
        Do method.Implementation.WriteLine($CHAR(9) _"}")
        Do method.Implementation.WriteLine($CHAR(9) _"Return list")
       
        Do ..outClass.Methods.Insert(method)
        Set ..temp(methodName)=method
        Do ..log("Initialized.", 0)
    } Else {
        Do ..log("Already exists (skipped).", 0)
    }

    Set ..temp("RESTGEN","getlist") = $$$FormatText("##class(%1).%2", ..outClass.Name, methodName)

    Quit sc
]]></Implementation>
</Method>

<Method name="GetFormalSpecList">
<FormalSpec>*callString:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS", callString = ""

    Set query = ##class(%Dictionary.CompiledQuery).%OpenId(..class.Name _ "||List")
    
    Set tmpList = $LISTFROMSTRING(query.FormalSpec), ptr = 0
    
    While $LISTNEXT(tmpList, ptr, v) {
        Set $Piece(callString, ",", *+1)= $Piece(v, ":")
    }
    Set callString = $Extract(callString, 2, *)
    
    Quit query.FormalSpec
]]></Implementation>
</Method>

<Method name="GetFormalSpec">
<FormalSpec>methodName:%String,*callString:%String,prefix:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS", callString = ""

    #dim cm As %Dictionary.CompiledMethod = ##class(%Dictionary.CompiledMethod).%OpenId(..class.Name _ "||" _ methodName,,.sc)
    Quit:$$$ISERR(sc) sc
    Set formalSpec = $Piece(cm.FormalSpec, ",&Properties")
    Set tmpList = $LISTFROMSTRING(formalSpec), ptr = 0
    
    While $LISTNEXT(tmpList, ptr, v) {
        Set $Piece(callString, ",", *+1)= prefix _ $Piece(v, ":")
    }
    Set callString = $Extract(callString, 2, *)

    Quit formalSpec
]]></Implementation>
</Method>

<Method name="configMethodExists">
<FormalSpec>methodName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit ##class(%Dictionary.CompiledMethod).%ExistsId(..class.Name _ "||" _ methodName)
]]></Implementation>
</Method>

<Method name="configQueryExists">
<FormalSpec>queryName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit ##class(%Dictionary.CompiledQuery).%ExistsId(..class.Name _ "||" _ queryName)
]]></Implementation>
</Method>

<Method name="log">
<Description>
write message to the current device if verbose is enabled</Description>
<FormalSpec>message:%String,newLine:%Boolean=1,dateTime:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
    Quit:'..verbose()
    Write:newLine !, $zdt($h,3,1), " "
    Write message
    Quit
]]></Implementation>
</Method>

<Method name="isCommonSingle">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonSingleMethods")
]]></Implementation>
</Method>

<Method name="isCommonMapMethods">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonMapMethods")
]]></Implementation>
</Method>

<Method name="isCommonMultipleMethods">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"
    Quit $CLASSMETHOD(..class.Name,"%Extends","Config.CommonMultipleMethods")
]]></Implementation>
</Method>

<Method name="getPropertyDescription">
<FormalSpec>property:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    Set desc = ""

    #dim cProp As %Dictionary.CompiledProperty = ##class(%Dictionary.CompiledProperty).%OpenId(..class.Name _ "||" _property,,.sc)
    Quit:$$$ISERR(sc) ""
    Set desc = cProp.Description
    ;Set desc = $Replace(desc,"<br>","\n")
    ;Set desc = $Replace(desc,"<br/>","\n")
    
    Quit desc
]]></Implementation>
</Method>

<Method name="verbose">
<CodeMode>expression</CodeMode>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$Get(..parameters("verbose"),1)
]]></Implementation>
</Method>

<Method name="skipProperty">
<FormalSpec>property:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Quit:property.Internal $$$YES
    Quit:$Get(parameters("excludePercent"), $$$YES)&&($EXTRACT(property.Name)="%") $$$YES
    Quit:$Get(parameters("excludePrivate"), $$$YES)&&property.Private $$$YES
    Quit $$$NO
]]></Implementation>
</Method>

<Method name="RESTTemplateGET">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()

    If ..configMethodExists("Exists") {
        Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
        Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
        Do stream.WriteLine($c(9,9)_ "Quit """"")
        Do stream.WriteLine($c(9)_ "}")
        Do stream.WriteLine("")
    }

    Do stream.WriteLine($c(9)_"Set model = {{get}}({{params}})")
    Do stream.WriteLine($c(9)_"Do ..%SetStatusCode($$$HTTP200)")
    Do stream.WriteLine($c(9)_"Do ..%SetContentType(""application/json"")")
    Do stream.WriteLine($c(9)_"Quit model")
    
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplatePUT">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set dModel = {}.%FromJSON(.model)")
    Do stream.WriteLine($c(9)_ "Set sc ={{checkmodel}}(dModel)")
    Do stream.WriteLine($c(9)_ "If $$$ISERR(sc) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP400)")
    Do stream.WriteLine($c(9,9)_ "Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)")
    Do stream.WriteLine($c(9,9)_ "Quit jsonSC")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    If ..configMethodExists("Exists") {
        Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
        Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
        Do stream.WriteLine($c(9)_ "}")
    }
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{update}}(dModel))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP204)")
    Do stream.WriteLine($c(9)_ "Quit """"")   
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplatePOST">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set dModel = {}.%FromJSON(.model)")
    Do stream.WriteLine($c(9)_ "Set sc ={{checkmodel}}(dModel)")
    Do stream.WriteLine($c(9)_ "If $$$ISERR(sc) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP400)")
    Do stream.WriteLine($c(9,9)_ "Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)")
    Do stream.WriteLine($c(9,9)_ "Quit jsonSC")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "If {{exists}}({{params}}) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP409)")
    Do stream.WriteLine($c(9,9)_ "Quit """"")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{create}}(dModel))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP201)")
    Do stream.WriteLine($c(9)_ "Do ..%SetHeader(""Location"", {{location}})")
    Do stream.WriteLine($c(9)_ "Quit """"")
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplateDELETE">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "If '{{exists}}({{params}}) {")
    Do stream.WriteLine($c(9,9)_ "Do ..%SetStatusCode($$$HTTP404)")
    Do stream.WriteLine($c(9,9)_ "Quit """"")
    Do stream.WriteLine($c(9)_ "}")
    Do stream.WriteLine($c(9)_ "")
    Do stream.WriteLine($c(9)_ "$$$ThrowOnError({{delete}}({{params}}))")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP204)")
    Do stream.WriteLine($c(9)_ "Quit """"")
    Quit stream
]]></Implementation>
</Method>

<Method name="RESTTemplateGETList">
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<Implementation><![CDATA[
    Set stream = ##class(%Stream.GlobalCharacter).%New()
    Do stream.WriteLine($c(9)_ "Set lst = {{getlist}}({{getlistparams}})")
    Do stream.WriteLine($c(9)_ "Do ..%SetStatusCode($$$HTTP200)")
    Do stream.WriteLine($c(9)_ "Do ..%SetContentType(""application/json"")")
    Do stream.WriteLine($c(9)_ "Quit {""{{listof}}"":(lst)}")
    Quit stream
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Helper">
<Description>
dev helper
zw ##class(Api.Config.Developers.Helper).GenCommonMethod("","")
zw ##class(Api.Config.Developers.Helper).GenObjectToArray("","")
zw ##class(Api.Config.Developers.Helper).GenToDynamic("","")</Description>
<TimeChanged>65834,73166.746796</TimeChanged>
<TimeCreated>65834,73166.746796</TimeCreated>

<Method name="GenCommonMethod">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Do ..GenToDynamic(className, outClassName)
    Do ..GenToArray(className, outClassName)
    Do ..GenObjectToArray(className, outClassName)
    Do ..ShowSwaggerDef(className, outClassName)
    Return sc
]]></Implementation>
</Method>

<Method name="GenToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
        #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Write !," * Generate method ToArray to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    ;Set outClass = ##class(%Dictionary.ClassDefinition).%OpenId(outClassName)
    Set methodName = "ToArray"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName,,.sc)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = methodName
    Set method.ClassMethod = $$$YES
    Set method.FormalSpec = "model:%Library.DynamicObject,*properties:%Binary"
    Set method.ReturnType = ""
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        ; Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        ; Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
        Set line = $CHAR(9) _ $$$FormatText("Set:$$$CanSetProperty(model,""%1"") properties(""%1"") = model.%1", property.Name)
        Do method.Implementation.WriteLine(line)
    }
    Do method.Implementation.WriteLine($CHAR(9) _ "Quit")

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="GenToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Write !," * Generate method ToDynamic to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    ;Set outClass = ##class(%Dictionary.ClassDefinition).%OpenId(outClassName)
    Set methodName = "ToDynamic"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName,,.sc)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "ToDynamic"
    Set method.ClassMethod = $$$YES
    Set method.FormalSpec = "&properties:%Binary" ; "pObj:"_className
    Set method.ReturnType = "%Library.DynamicObject"
    Do method.Implementation.WriteLine($CHAR(9) _ "Set model = {}")
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        ; Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
        Do method.Implementation.WriteLine($CHAR(9) _ $$$FormatText("Do:$Data(properties(""%1"")) model.%Set(""%1"", properties(""%1""), ""%2"")", property.Name, jsonType))
    }
    Do method.Implementation.WriteLine($CHAR(9) _ "Quit model")

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="GenObjectToArray">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,outClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(PackageName.ClassName).GenObjectToArray("","")
    Write !," * Generate method ObjectToArray to "_outClassName _ " "
    Set sc = $$$OK, key=""
    
    Set methodName = "ObjectToArray"
    
    Set method = ##class(%Dictionary.MethodDefinition).%OpenId(outClassName_"||"_methodName)
    Set:'$ISOBJECT(method) method = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = methodName
    Set method.ClassMethod = $$$YES
    Set method.ReturnType = ""
    Set method.FormalSpec = "&pObj,*properties:%Binary"
    
    Do method.parentSetObjectId(outClassName)

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Do method.Implementation.WriteLine($CHAR(9)_$$$FormatText("Set properties(""%1"") = pObj.%1",property.Name))
    }

    Set $NAMESPACE = ns
    Set sc = method.%Save()
    Write $SYSTEM.Status.GetOneErrorText(sc)
    Return sc
]]></Implementation>
</Method>

<Method name="ShowSwaggerDef">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    #define GETTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"number",:"string")
    #define GETSWAGGERTYPE(%type) $case(%type,"%Boolean":"boolean","Security.Datatype.BooleanYN":"boolean","%Float":"number","%Integer":"integer",:"string")

    Set swaggerDef = {
        "type" : "object",
        "properties" : {},
        "required" : []
    }
    Set template = {}, key=""
    Set swaggerDef.example = template
    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    
    Set obj = $CLASSMETHOD(className, "%New")
    
    #dim class As %Dictionary.CompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(className)

    For  {
        Set property = class.Properties.GetNext(.key)
        Quit:key="" 
        Continue:..skipProperty(property)
        Set jsonType = $$$GETTYPE($Replace(property.Type, "Library.",""))
        Set swaggerType = $$$GETSWAGGERTYPE($Replace(property.Type, "Library.",""))
    
        Set dflt = $PROPERTY(obj,property.Name)
        Set:$ISOBJECT(dflt) dflt=""
        If dflt=""&&property.Required {
            Do swaggerDef.required.%Push(property.Name)
            Do template.%Set(property.Name, dflt, jsonType)
        }

        Set description = ..getPropertyDescription(property.Name, className)

        Do swaggerDef.properties.%Set(property.Name, {
            "type" : (swaggerType),
            "default" : (dflt),
            "description" : (description)
        })
    
    }
    
    Set $NAMESPACE = ns
    Set formatter=##class(%JSON.Formatter).%New()
    Set swaggerString = ""
    Do formatter.FormatToString(swaggerDef, .swaggerString)
    w !,swaggerString
    Quit swaggerDef
]]></Implementation>
</Method>

<Method name="getPropertyDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec>property:%String,class:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $NAMESPACE
    Set $NAMESPACE = "%SYS"

    #dim cProp As %Dictionary.CompiledProperty = ##class(%Dictionary.CompiledProperty).%OpenId(class _ "||" _property,,.sc)
    Quit:$$$ISERR(sc) ""
    Quit cProp.Description
]]></Implementation>
</Method>

<Method name="skipProperty">
<ClassMethod>1</ClassMethod>
<FormalSpec>property:%Dictionary.CompiledProperty</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Quit:property.Internal $$$YES
    Quit:$Get(parameters("excludePercent"), $$$YES)&&($EXTRACT(property.Name)="%") $$$YES
    Quit:$Get(parameters("excludePrivate"), $$$YES)&&property.Private $$$YES
    Quit $$$NO
]]></Implementation>
</Method>

<Method name="MDListServices">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ; d ##class(Api.Config.Developers.Helper).MDListServices()
    #define METHODEXISTS(%name)    $s(##class(%Dictionary.MethodDefinition).%ExistsId(key_"||"_%name):"yes",1:"no")
    Write !,"| Service classes 	| List 	| Get 	| Update    | Create    | Delete    | Exists    |"
    Write !,"|-	|-	|-	|-	|-	|-	|-	|"

    Set list = 1, get = 1, update = 1, create = 1, delete=1, exists=1 
    Set key = "Api.Config.Services"
    For  {
        Set key = $Order(^oddDEF(key))
        Quit:key=""||(key'["Api.Config.Services.")
        CONTINUE:key="Api.Config.Services.Loader"

        Set list = $$$METHODEXISTS("List"), 
                    get = $$$METHODEXISTS("Get"), 
                    update = $$$METHODEXISTS("Update"), 
                    create = $$$METHODEXISTS("Create"), 
                    delete = $$$METHODEXISTS("Delete"), 
                    exists = $$$METHODEXISTS("Exists")
        Write !, $$$FormatText("| %1 | %2 | %3 | %4 | %5 | %6 | %7 |",key,list,get,update,create,delete,exists)
    }
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Install">
<Description>
Description</Description>
<TimeChanged>65834,73166.744137</TimeChanged>
<TimeCreated>65834,73166.744137</TimeCreated>

<Method name="installRESTApp">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set cfg = {
        "Security.Applications" : {
            "/api/config": {
                "NameSpace" : ($NAMESPACE),
                "Enabled" : 1,
                "DispatchClass" : "Api.Config.REST.disp",
                "CSPZENEnabled" : 1,
                "AutheEnabled": 32
            }
        }
    }

    Set sc = ##class(Api.Config.Services.Loader).Load(cfg)

    Quit sc
]]></Implementation>
</Method>

<Method name="SetSwaggerUIDefaultPath">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>specUrl:%String="/api/config/",toReplace:%String="""http://localhost:52773/crud/_spec"""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Quit:'##class(Api.Config.Services.Security.Applications).Exists("/swagger-ui") $$$ERROR(5001, "/swagger-ui web app does not exists")
    
    Set app = ##class(Api.Config.Services.Security.Applications).Get("/swagger-ui")
    Set dir = ##class(%File).NormalizeDirectory(app.Path)
    
    Set newValue = "(window.location.protocol+'//'+window.location.host+'"_specUrl_"')"
    Set file = ##class(%Stream.FileCharacter).%New()
    Do file.LinkToFile(dir_"index.html")
    Set buff = file.Read()
    Set buff = $REPLACE(buff, toReplace, newValue)
    Do file.Clear()
    Do file.Rewind()
    Do file.Write(buff)
    Quit file.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Samples">
<Description>
code samples
Description</Description>
<TimeChanged>65834,73166.79256</TimeChanged>
<TimeCreated>65834,73166.79256</TimeCreated>

<Method name="firstStep">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    /// zw ##class(Api.Config.Developers.Samples).firstStep()
    Set config = {
        "Journal": {                                /* Service class Api.Config.Journal */
            "FreezeOnError":1
        },
        "SQL": {                                    /* Service class Api.Config.SQL */
            "LockThreshold" : 2500
        },
        "config": {                                 /* Service class Api.Config.config */
            "locksiz" : 33554432
        },
        "Startup":{                                 /* Service class Api.Config.Startup */
            "SystemMode" : "DEVELOPMENT"
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="firstAppEnvironment">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    /// zw ##class(Api.Config.Developers.Samples).firstAppEnvironment()
    Set config = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}zwebapp/",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="advanced">
<Description>
zw ##class(Api.Config.Developers.Samples).advanced()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set config = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}zwebapp/",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        },
        "MapPackages": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "PackageName",
                "Database" : "USER"
            }]
        },
        "MapRoutines": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "RoutineName",
                "Database" : "USER"
            }]
        },
        "Journal": {
            "FreezeOnError":1
        },
        "Security.Services":{   
            "%Service_Mirror": {
                "Enabled" : 0
            }
        },
        "SQL": {
            "LockThreshold" : 2500
        },
        "config": {
            "locksiz" : 33554432
        },
        "Startup":{
            "SystemMode" : "DEVELOPMENT"
        }
    }
    Set sc = ##class(Api.Config.Services.Loader).Load(config)
    Quit sc
]]></Implementation>
</Method>

<Method name="export">
<Description>
zw ##class(Api.Config.Developers.Samples).export()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set filter = {
        "Namespaces": {   
            "MYAPP":""    /* Namespace to export */
        },
        "MapGlobals":{
            "MYAPP":""    /* Export all globals mapping for namespace MYAPP */
        },
        "MapPackages":{ 
            "MYAPP":""    /* Export all packages mapping for namespace MYAPP */
        },
        "MapRoutines":{
            "MYAPP":""    /* Export all routines mapping for namespace MYAPP */
        },
        "Security.Applications":{
            "/csp/zrestapp":"",   /* Export Web applications parameters /csp/zrestapp */
            "/csp/zwebapp":""     /* Export Web applications parameters /csp/zwebapp */
        },
        "Journal":"",  /* Export all journal setting.  *There is a trick to export only non default parameters(see below) */
        "config":""   /* Export config parameters */
    }
    Set OnlyNotDefaultValue = 1
    Set config = ##class(Api.Config.Services.Loader).export(filter,OnlyNotDefaultValue)
    Quit config
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.UnitTestsClassGen">
<Description>
Dev helper to generate template UnitTests classes for services.</Description>
<TimeChanged>65834,73166.78849</TimeChanged>
<TimeCreated>65834,73166.78849</TimeCreated>

<Parameter name="PACKAGE">
<Default>UnitTests.Api.Config.Services.</Default>
</Parameter>

<Method name="Gen">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,*unitTestClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    ; zw ##class(Api.Config.Developers.UnitTestsClassGen).Gen("Api.Config.Services.Namespaces",.o)
    #define METHODEXISTS(%method)       ##class(%Dictionary.CompiledMethod).%ExistsId(className_"||"_%method)
    
    Set unitTestClass = ..#PACKAGE _ $PIECE(className,"Config.Services.",2)

    #dim class As %Dictionary.ClassDefinition = ##class(%Dictionary.ClassDefinition).%New()
    Set class.Name = unitTestClass
    Set class.ProcedureBlock = $$$YES
    Set class.Super = "%UnitTest.TestCase"

    If $$$METHODEXISTS("Get") {
        Do class.Methods.Insert(..GetMethod(className,unitTestClass))
    }

    If $$$METHODEXISTS("Update") {
        Do class.Methods.Insert(..UpdateMethod(className,unitTestClass))
    }

    If $$$METHODEXISTS("Create") {
        Do class.Methods.Insert(..CreateMethod(className,unitTestClass))
    }

    If $$$METHODEXISTS("List") {
        Do class.Methods.Insert(..ListMethod(className,unitTestClass))
    }



    Quit class.%Save()
]]></Implementation>
</Method>

<Method name="ListMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,unitTestClass:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestList"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Set listLine = "Set list = ##class(%1).List(%2)"

    If $PARAMETER(className,"ISMAP") {
        Set arg = $PIECE($PARAMETER(className,"PIDENTIFIER"),",",1)
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_ arg _" = """"" )
        Set listLine = $$$FormatText(listLine, className, arg)

    } Else {
        Set listLine = $$$FormatText(listLine, className, "")
    }

    Do method.Implementation.WriteLine($CHAR(9)_ listLine)
    
    
    
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="CreateMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,unitTestClass:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestCreateAndDelete"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Do method.Implementation.WriteLine($CHAR(9)_"Set model = {}")

    Do method.Implementation.WriteLine($CHAR(9)_ $Replace("Set sc = ##class(%1).Create(model)", "%1",className))

    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc,""Create status"")")

    Set delLine = $Replace("Set sc = ##class(%1).Delete(%2)","%1",className)

    If $PARAMETER(className,"ISMAP") {
        Set args = $PARAMETER(className,"PIDENTIFIER")
        For i=1:1:$LENGTH(args,",") {
            Do method.Implementation.WriteLine($CHAR(9) _ "Set "_$Piece(args,",",i) _" = """"" )
        }
        Set delLine = $$$FormatText(delLine, className, args)

    } Else {
        Set pName = $PARAMETER(className,"PNAME")
        Set:pName="" pName="Name"
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_pName _" = """"" )
        Set delLine = $$$FormatText(delLine, className, pName)
    }

    Do method.Implementation.WriteLine($CHAR(9)_ delLine)
    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc,""Delete created ressource"")")
    
    
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="UpdateMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,unitTestClass:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestUpdate"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Do method.Implementation.WriteLine($CHAR(9)_"Set model = {}")

    Do method.Implementation.WriteLine($CHAR(9)_ $Replace("Set sc = ##class(%1).Update(model)", "%1",className))

    Do method.Implementation.WriteLine($CHAR(9)_ "Do $$$AssertStatusOK(sc)")

    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>

<Method name="GetMethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,unitTestClass:%String</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    #dim method As %Dictionary.MethodDefinition = ##class(%Dictionary.MethodDefinition).%New()
    Set method.Name = "TestGet"
    Set method.ReturnType = "%Status"

    Do method.Implementation.WriteLine($CHAR(9)_"Set sc = $$$OK")

    Set getLine = $CHAR(9) _ "Set model = ##class(%1).Get(%2)"

    If $PARAMETER(className,"ISSINGLE") {
        Set getLine = $$$FormatText(getLine, className, "")

    } ElseIf $PARAMETER(className,"ISMAP") {

        Set args = $PARAMETER(className,"PIDENTIFIER")
        For i=1:1:$LENGTH(args,",") {
            Do method.Implementation.WriteLine($CHAR(9) _ "Set "_$Piece(args,",",i) _" = """"" )
        }
        Set getLine = $$$FormatText(getLine, className, args)

    } Else {

        Set pName = $PARAMETER(className,"PNAME")
        Set:pName="" pName="Name"
        Do method.Implementation.WriteLine($CHAR(9) _ "Set "_pName _" = """"" )

        Set getLine = $$$FormatText(getLine, className, pName)
        
    }

    
    
    Do method.Implementation.WriteLine(getLine)
    For i=1:1:3 {
        Do method.Implementation.WriteLine($CHAR(9) _ "Set expected = """"")
        Do method.Implementation.WriteLine($CHAR(9) _ "Do $$$AssertTrue(model.%IsDefined(expected),$replace(""Check if property %1 is defined"",""%1"",expected))")
    }
    Do method.Implementation.WriteLine($CHAR(9)_"Quit sc")

    Quit method
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Developers.Utils">
<Description>
Description</Description>
<TimeChanged>65834,73166.774538</TimeChanged>
<TimeCreated>65834,73166.774538</TimeCreated>

<Method name="Show">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    Set formatter=##class(%JSON.Formatter).%New()
    Set str = ""
    Do formatter.FormatToString(model, .str)
    Write !,str
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.REST.impl">
<Description><![CDATA[
Config API.<br/>
Business logic class defined by OpenAPI in Api.Config.REST.spec<br/>
Updated Mar 31, 2021 20:19:27]]></Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%REST.Impl</Super>
<TimeChanged>65834,73167.847211</TimeChanged>
<TimeCreated>65834,73166.845628</TimeCreated>

<Parameter name="ExposeServerExceptions">
<Description>
If ExposeServerExceptions is true, then details of internal errors will be exposed.</Description>
<Default>1</Default>
</Parameter>

<Method name="GetSpecification">
<Description>
Swagger 2.0 specification</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Do ..%SetStatusCode($$$HTTP200)
    Do ..%SetContentType("application/json")
    #dim XData As %Dictionary.CompiledXData = ##class(%Dictionary.CompiledXData).%OpenId("Api.Config.REST.spec||OpenAPI")
    Set swagger = {}.%FromJSON(XData.Data)
    Set swagger.host = %request.CgiEnvs("SERVER_NAME") _ ":" _ %request.CgiEnvs("SERVER_PORT")
    Set swagger.basePath = %request.Application
    Quit swagger
]]></Implementation>
</Method>

<Method name="GetCluster">
<Description>
Get Cluster.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.Cluster).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutCluster">
<Description><![CDATA[
Update Cluster.<br/>
The method arguments hold values for:<br/>
    model, Cluster to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Cluster).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Cluster).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetConfigFile">
<Description>
Get ConfigFile.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.ConfigFile).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutConfigFile">
<Description><![CDATA[
Update ConfigFile.<br/>
The method arguments hold values for:<br/>
    model, ConfigFile to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.ConfigFile).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.ConfigFile).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetDatabases">
<Description><![CDATA[
Get Databases.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Databases).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Databases).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutDatabases">
<Description><![CDATA[
Update Databases.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Databases to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Databases).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Databases).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Databases).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostDatabases">
<Description><![CDATA[
Create Databases.<br/>
The method arguments hold values for:<br/>
    model, Databases to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Databases).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.Databases).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Databases).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/databases/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDatabases">
<Description><![CDATA[
Delete Databases.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Databases).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Databases).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListDatabases">
<Description>
Get List Of Databases.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.Databases).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfDatabases":(lst)}
]]></Implementation>
</Method>

<Method name="GetDebug">
<Description><![CDATA[
Get Debug.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Debug).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Debug).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutDebug">
<Description><![CDATA[
Update Debug.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Debug to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Debug).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Debug).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Debug).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostDebug">
<Description><![CDATA[
Create Debug.<br/>
The method arguments hold values for:<br/>
    model, Debug to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Debug).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.Debug).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Debug).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/debug/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDebug">
<Description><![CDATA[
Delete Debug.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Debug).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Debug).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListDebug">
<Description>
Get List Of Debug.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.Debug).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfDebug":(lst)}
]]></Implementation>
</Method>

<Method name="GetDeviceSubTypes">
<Description><![CDATA[
Get DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.DeviceSubTypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.DeviceSubTypes).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutDeviceSubTypes">
<Description><![CDATA[
Update DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, DeviceSubTypes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.DeviceSubTypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.DeviceSubTypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.DeviceSubTypes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostDeviceSubTypes">
<Description><![CDATA[
Create DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    model, DeviceSubTypes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.DeviceSubTypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.DeviceSubTypes).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.DeviceSubTypes).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/devicesubtypes/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDeviceSubTypes">
<Description><![CDATA[
Delete DeviceSubTypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.DeviceSubTypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.DeviceSubTypes).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListDeviceSubTypes">
<Description>
Get List Of DeviceSubTypes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.DeviceSubTypes).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfDeviceSubTypes":(lst)}
]]></Implementation>
</Method>

<Method name="GetDevices">
<Description><![CDATA[
Get Devices.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Devices).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Devices).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutDevices">
<Description><![CDATA[
Update Devices.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Devices to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Devices).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Devices).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Devices).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetECP">
<Description>
Get ECP.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.ECP).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostDevices">
<Description><![CDATA[
Create Devices.<br/>
The method arguments hold values for:<br/>
    model, Devices to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Devices).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.Devices).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Devices).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/devices/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDevices">
<Description><![CDATA[
Delete Devices.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Devices).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Devices).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutECP">
<Description><![CDATA[
Update ECP.<br/>
The method arguments hold values for:<br/>
    model, ECP to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.ECP).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.ECP).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListDevices">
<Description>
Get List Of Devices.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.Devices).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfDevices":(lst)}
]]></Implementation>
</Method>

<Method name="GetECPServers">
<Description><![CDATA[
Get ECPServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.ECPServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.ECPServers).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutECPServers">
<Description><![CDATA[
Update ECPServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, ECPServers to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.ECPServers).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.ECPServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.ECPServers).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetIO">
<Description>
Get IO.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.IO).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostECPServers">
<Description><![CDATA[
Create ECPServers.<br/>
The method arguments hold values for:<br/>
    model, ECPServers to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.ECPServers).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.ECPServers).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.ECPServers).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/ecpservers/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteECPServers">
<Description><![CDATA[
Delete ECPServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.ECPServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.ECPServers).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutIO">
<Description><![CDATA[
Update IO.<br/>
The method arguments hold values for:<br/>
    model, IO to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.IO).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.IO).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetJournal">
<Description>
Get Journal.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.Journal).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="GetListECPServers">
<Description>
Get List Of ECPServers.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.ECPServers).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfECPServers":(lst)}
]]></Implementation>
</Method>

<Method name="PutJournal">
<Description><![CDATA[
Update Journal.<br/>
The method arguments hold values for:<br/>
    model, Journal to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Journal).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Journal).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetLicenseServers">
<Description><![CDATA[
Get LicenseServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.LicenseServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.LicenseServers).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutLicenseServers">
<Description><![CDATA[
Update LicenseServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, LicenseServers to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.LicenseServers).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.LicenseServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.LicenseServers).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostLicenseServers">
<Description><![CDATA[
Create LicenseServers.<br/>
The method arguments hold values for:<br/>
    model, LicenseServers to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.LicenseServers).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.LicenseServers).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.LicenseServers).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/licenseservers/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteLicenseServers">
<Description><![CDATA[
Delete LicenseServers.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.LicenseServers).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.LicenseServers).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListLicenseServers">
<Description>
Get List Of LicenseServers.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.LicenseServers).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfLicenseServers":(lst)}
]]></Implementation>
</Method>

<Method name="GetMagTapes">
<Description><![CDATA[
Get MagTapes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MagTapes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MagTapes).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMagTapes">
<Description><![CDATA[
Update MagTapes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, MagTapes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.MagTapes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MagTapes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MagTapes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMagTapes">
<Description><![CDATA[
Create MagTapes.<br/>
The method arguments hold values for:<br/>
    model, MagTapes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.MagTapes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.MagTapes).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MagTapes).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/magtapes/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMagTapes">
<Description><![CDATA[
Delete MagTapes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MagTapes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MagTapes).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMagTapes">
<Description>
Get List Of MagTapes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MagTapes).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMagTapes":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapGlobals">
<Description><![CDATA[
Get MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapGlobals).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MapGlobals).Get(namespace,name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMapGlobals">
<Description><![CDATA[
Update MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapGlobals to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name, dModel.Namespace = namespace
	Set sc =##class(Api.Config.Services.MapGlobals).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapGlobals).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapGlobals).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapGlobals">
<Description><![CDATA[
Create MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    model, MapGlobals to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace
	Set sc =##class(Api.Config.Services.MapGlobals).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.MapGlobals).Exists(namespace,dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapGlobals).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/mapglobals/"_namespace_"/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMapGlobals">
<Description><![CDATA[
Delete MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapGlobals).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapGlobals).Delete(namespace,name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMapGlobals">
<Description><![CDATA[
Get List Of MapGlobals.<br/>
The method arguments hold values for:<br/>
    namespace, namespace.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapGlobals).List(namespace)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapGlobals":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapMirrors">
<Description><![CDATA[
Get MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, This is the name of this instance in the mirror. Mirror system names
must be unique (enforced by Enterprise Manager) across all of the mirrors which 
the EM manages, as an instance has a single mirror system name which 
may appear in multiple mirror sets (eg. a reporting member may connect
to multiple mirrors). For the most part the <property>GUID </property>
is used to identify a mirror member, the Name is used for display 
purposes. 
<br><br>
The name must not contain a colon (':') and is converted to uppercase before
saving.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapMirrors).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MapMirrors).Get(id,name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMapMirrors">
<Description><![CDATA[
Update MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, This is the name of this instance in the mirror. Mirror system names
must be unique (enforced by Enterprise Manager) across all of the mirrors which 
the EM manages, as an instance has a single mirror system name which 
may appear in multiple mirror sets (eg. a reporting member may connect
to multiple mirrors). For the most part the <property>GUID </property>
is used to identify a mirror member, the Name is used for display 
purposes. 
<br><br>
The name must not contain a colon (':') and is converted to uppercase before
saving.<br/>
    model, MapMirrors to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapMirrors).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapMirrors).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapMirrors).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapMirrors">
<Description><![CDATA[
Create MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    model, MapMirrors to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id
	Set sc =##class(Api.Config.Services.MapMirrors).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.MapMirrors).Exists(id,dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapMirrors).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/mapmirrors/"_id_"/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMapMirrors">
<Description><![CDATA[
Delete MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, This is the name of this instance in the mirror. Mirror system names
must be unique (enforced by Enterprise Manager) across all of the mirrors which 
the EM manages, as an instance has a single mirror system name which 
may appear in multiple mirror sets (eg. a reporting member may connect
to multiple mirrors). For the most part the <property>GUID </property>
is used to identify a mirror member, the Name is used for display 
purposes. 
<br><br>
The name must not contain a colon (':') and is converted to uppercase before
saving.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapMirrors).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapMirrors).Delete(id,name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMapMirrors">
<Description><![CDATA[
Get List Of MapMirrors.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapMirrors).List(id)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapMirrors":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapPackages">
<Description><![CDATA[
Get MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapPackages).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MapPackages).Get(namespace,name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMapPackages">
<Description><![CDATA[
Update MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapPackages to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapPackages).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapPackages).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapPackages).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapPackages">
<Description><![CDATA[
Create MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    model, MapPackages to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace
	Set sc =##class(Api.Config.Services.MapPackages).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.MapPackages).Exists(namespace,dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapPackages).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/mappackages/"_namespace_"/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMapPackages">
<Description><![CDATA[
Delete MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapPackages).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapPackages).Delete(namespace,name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMapPackages">
<Description><![CDATA[
Get List Of MapPackages.<br/>
The method arguments hold values for:<br/>
    namespace, namespace.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapPackages).List(namespace)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapPackages":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapRoutines">
<Description><![CDATA[
Get MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapRoutines).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MapRoutines).Get(namespace,name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMapRoutines">
<Description><![CDATA[
Update MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapRoutines to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapRoutines).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapRoutines).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapRoutines).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostMapRoutines">
<Description><![CDATA[
Create MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    model, MapRoutines to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Namespace = namespace
	Set sc =##class(Api.Config.Services.MapRoutines).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.MapRoutines).Exists(namespace,dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapRoutines).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/maproutines/"_namespace_"/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMapRoutines">
<Description><![CDATA[
Delete MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, Namespace where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapRoutines).Exists(namespace,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapRoutines).Delete(namespace,name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMapRoutines">
<Description><![CDATA[
Get List Of MapRoutines.<br/>
The method arguments hold values for:<br/>
    namespace, namespace.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapRoutines).List(namespace)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapRoutines":(lst)}
]]></Implementation>
</Method>

<Method name="GetMapShadows">
<Description><![CDATA[
Get MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapShadows).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.MapShadows).Get(id,name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMapShadows">
<Description><![CDATA[
Update MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>
    model, MapShadows to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id, dModel.Name = name
	Set sc =##class(Api.Config.Services.MapShadows).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.MapShadows).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapShadows).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetMirrorMember">
<Description>
Get MirrorMember.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.MirrorMember).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostMapShadows">
<Description><![CDATA[
Create MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    model, MapShadows to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Id = id
	Set sc =##class(Api.Config.Services.MapShadows).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.MapShadows).Exists(id,dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapShadows).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/mapshadows/"_id_"/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMapShadows">
<Description><![CDATA[
Delete MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>
    name, Name of the mapping.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String,name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.MapShadows).Exists(id,name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.MapShadows).Delete(id,name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutMirrorMember">
<Description><![CDATA[
Update MirrorMember.<br/>
The method arguments hold values for:<br/>
    model, MirrorMember to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.MirrorMember).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.MirrorMember).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMapShadows">
<Description><![CDATA[
Get List Of MapShadows.<br/>
The method arguments hold values for:<br/>
    id, ID where the mapping is.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.MapShadows).List(id)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMapShadows":(lst)}
]]></Implementation>
</Method>

<Method name="GetMirrors">
<Description><![CDATA[
Get Mirrors.<br/>
The method arguments hold values for:<br/>
    name, Mirror names are uppercase (alphanumeric)
Name of the mirror, restricted to 15 uppercase alphanumeric characters. 
Must be unique across the mirrors managed by the EMS<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Mirrors).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Mirrors).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMirrors">
<Description><![CDATA[
Update Mirrors.<br/>
The method arguments hold values for:<br/>
    name, Mirror names are uppercase (alphanumeric)
Name of the mirror, restricted to 15 uppercase alphanumeric characters. 
Must be unique across the mirrors managed by the EMS<br/>
    model, Mirrors to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Mirrors).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Mirrors).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Mirrors).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetMiscellaneous">
<Description>
Get Miscellaneous.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.Miscellaneous).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostMirrors">
<Description><![CDATA[
Create Mirrors.<br/>
The method arguments hold values for:<br/>
    model, Mirrors to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Mirrors).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.Mirrors).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Mirrors).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/mirrors/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteMirrors">
<Description><![CDATA[
Delete Mirrors.<br/>
The method arguments hold values for:<br/>
    name, Mirror names are uppercase (alphanumeric)
Name of the mirror, restricted to 15 uppercase alphanumeric characters. 
Must be unique across the mirrors managed by the EMS<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Mirrors).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Mirrors).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutMiscellaneous">
<Description><![CDATA[
Update Miscellaneous.<br/>
The method arguments hold values for:<br/>
    model, Miscellaneous to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Miscellaneous).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Miscellaneous).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListMirrors">
<Description>
Get List Of Mirrors.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.Mirrors).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfMirrors":(lst)}
]]></Implementation>
</Method>

<Method name="GetMonitor">
<Description>
Get Monitor.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.Monitor).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutMonitor">
<Description><![CDATA[
Update Monitor.<br/>
The method arguments hold values for:<br/>
    model, Monitor to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Monitor).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Monitor).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetNamespaces">
<Description><![CDATA[
Get Namespaces.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Namespaces).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Namespaces).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutNamespaces">
<Description><![CDATA[
Update Namespaces.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Namespaces to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Namespaces).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Namespaces).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Namespaces).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetSQL">
<Description>
Get SQL.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.SQL).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostNamespaces">
<Description><![CDATA[
Create Namespaces.<br/>
The method arguments hold values for:<br/>
    model, Namespaces to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Namespaces).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.Namespaces).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Namespaces).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/namespaces/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteNamespaces">
<Description><![CDATA[
Delete Namespaces.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Namespaces).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Namespaces).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutSQL">
<Description><![CDATA[
Update SQL.<br/>
The method arguments hold values for:<br/>
    model, SQL to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.SQL).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.SQL).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListNamespaces">
<Description>
Get List Of Namespaces.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.Namespaces).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfNamespaces":(lst)}
]]></Implementation>
</Method>

<Method name="GetShadows">
<Description><![CDATA[
Get Shadows.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Shadows).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.Shadows).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutShadows">
<Description><![CDATA[
Update Shadows.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, Shadows to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.Shadows).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.Shadows).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Shadows).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostShadows">
<Description><![CDATA[
Create Shadows.<br/>
The method arguments hold values for:<br/>
    model, Shadows to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Shadows).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.Shadows).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Shadows).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/shadows/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteShadows">
<Description><![CDATA[
Delete Shadows.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.Shadows).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Shadows).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListShadows">
<Description>
Get List Of Shadows.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.Shadows).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfShadows":(lst)}
]]></Implementation>
</Method>

<Method name="GetSqlSysDatatypes">
<Description><![CDATA[
Get SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.SqlSysDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.SqlSysDatatypes).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutSqlSysDatatypes">
<Description><![CDATA[
Update SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, SqlSysDatatypes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.SqlSysDatatypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.SqlSysDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlSysDatatypes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostSqlSysDatatypes">
<Description><![CDATA[
Create SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    model, SqlSysDatatypes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.SqlSysDatatypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.SqlSysDatatypes).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlSysDatatypes).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/sqlsysdatatypes/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteSqlSysDatatypes">
<Description><![CDATA[
Delete SqlSysDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.SqlSysDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlSysDatatypes).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListSqlSysDatatypes">
<Description>
Get List Of SqlSysDatatypes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.SqlSysDatatypes).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfSqlSysDatatypes":(lst)}
]]></Implementation>
</Method>

<Method name="GetSqlUserDatatypes">
<Description><![CDATA[
Get SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.SqlUserDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.SqlUserDatatypes).Get(name)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutSqlUserDatatypes">
<Description><![CDATA[
Update SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>
    model, SqlUserDatatypes to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set dModel.Name = name
	Set sc =##class(Api.Config.Services.SqlUserDatatypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If '##class(Api.Config.Services.SqlUserDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlUserDatatypes).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetStartup">
<Description>
Get Startup.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.Startup).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostSqlUserDatatypes">
<Description><![CDATA[
Create SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    model, SqlUserDatatypes to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.SqlUserDatatypes).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	If ##class(Api.Config.Services.SqlUserDatatypes).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlUserDatatypes).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"/sqluserdatatypes/"_dModel.Name)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteSqlUserDatatypes">
<Description><![CDATA[
Delete SqlUserDatatypes.<br/>
The method arguments hold values for:<br/>
    name, Name of the object instance.<br><br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	If '##class(Api.Config.Services.SqlUserDatatypes).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SqlUserDatatypes).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutStartup">
<Description><![CDATA[
Update Startup.<br/>
The method arguments hold values for:<br/>
    model, Startup to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Startup).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Startup).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListSqlUserDatatypes">
<Description>
Get List Of SqlUserDatatypes.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set lst = ##class(Api.Config.Services.SqlUserDatatypes).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfSqlUserDatatypes":(lst)}
]]></Implementation>
</Method>

<Method name="GetTelnet">
<Description>
Get Telnet.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.Telnet).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PutTelnet">
<Description><![CDATA[
Update Telnet.<br/>
The method arguments hold values for:<br/>
    model, Telnet to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.Telnet).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.Telnet).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="Getconfig">
<Description>
Get config.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = ##class(Api.Config.Services.config).Get()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="Putconfig">
<Description><![CDATA[
Update config.<br/>
The method arguments hold values for:<br/>
    model, config to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.model)
	Set sc =##class(Api.Config.Services.config).CheckModel(dModel)
	If $$$ISERR(sc) {
		Do ..%SetStatusCode($$$HTTP400)
		Do ##class(%CSP.REST).StatusToJSON(sc,.jsonSC)
		Quit jsonSC
	}
	
	
	$$$ThrowOnError(##class(Api.Config.Services.config).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListOfDirectory">
<Description>
Get list of databases directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set lst = ##class(Api.Config.Services.SYS.Databases).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfDirectory":(lst)}
]]></Implementation>
</Method>

<Method name="GetDirectory">
<Description><![CDATA[
Get database directory details.<br/>
The method arguments hold values for:<br/>
    directory, Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set directory = ##class(%CSP.Page).UnescapeURL(directory)
	
    If '##class(Api.Config.Services.SYS.Databases).Exists(directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Set model = ##class(Api.Config.Services.SYS.Databases).Get(directory)
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit model
]]></Implementation>
</Method>

<Method name="PostDirectory">
<Description><![CDATA[
Create a new database directory.<br/>
The method arguments hold values for:<br/>
    directory, Database directory to create.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(.directory)
	
	If ##class(Api.Config.Services.Databases).Exists(dModel.Directory) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.Databases).Create(dModel))
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"directory?directory="_##class(%CSP.Page).EscapeURL(dModel.Directory))
	Quit ""
]]></Implementation>
</Method>

<Method name="PutDirectory">
<Description><![CDATA[
Update an existing database directory.<br/>
The method arguments hold values for:<br/>
    directory, Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.<br/>
    DirectoryModel, Database to update.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String,DirectoryModel:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(.DirectoryModel)
	Set dModel.Directory = directory
	If '##class(Api.Config.Services.SYS.Databases).Exists(dModel.Directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SYS.Databases).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDirectory">
<Description><![CDATA[
Delete database directory.<br/>
The method arguments hold values for:<br/>
    directory, Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set directory = ##class(%CSP.Page).UnescapeURL(directory)
    If '##class(Api.Config.Services.SYS.Databases).Exists(directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	
	$$$ThrowOnError(##class(Api.Config.Services.SYS.Databases).Delete(directory))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PutDirectoryMounted">
<Description><![CDATA[
Mount database.<br/>
The method arguments hold values for:<br/>
    directory<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set directory = ##class(%CSP.Page).UnescapeURL(directory)

	If '##class(Api.Config.Services.SYS.Databases).Exists(directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.SYS.Databases).Mount(directory))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="DeleteDirectoryMounted">
<Description><![CDATA[
Dismount database.<br/>
The method arguments hold values for:<br/>
    directory<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set directory = ##class(%CSP.Page).UnescapeURL(directory)

	If '##class(Api.Config.Services.SYS.Databases).Exists(directory) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.SYS.Databases).Dismount(directory))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetWebApp">
<Description><![CDATA[
Get Web application.<br/>
The method arguments hold values for:<br/>
    name, Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set name = ##class(%CSP.Page).UnescapeURL(name)
	If '##class(Api.Config.Services.Security.Applications).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Quit ##class(Api.Config.Services.Security.Applications).Get(name)
]]></Implementation>
</Method>

<Method name="PutWebApp">
<Description><![CDATA[
Update Web application.<br/>
The method arguments hold values for:<br/>
    name, Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	Set name = ##class(%CSP.Page).UnescapeURL(name)
	If '##class(Api.Config.Services.Security.Applications).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.Security.Applications).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostWebApp">
<Description><![CDATA[
Create a new web applications.<br/>
The method arguments hold values for:<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	If '##class(Api.Config.Services.Security.Applications).Exists(dModel.Name) {
		Do ..%SetStatusCode($$$HTTP409)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.Security.Applications).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="GetListOfWebApps">
<Description>
Get list of existings web applications.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set lst = ##class(Api.Config.Services.Security.Applications).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfWebApps":(lst)}
]]></Implementation>
</Method>

<Method name="DeleteWebApp">
<Description><![CDATA[
Delete Web application.<br/>
The method arguments hold values for:<br/>
    name, Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set name = ##class(%CSP.Page).UnescapeURL(name)
    If '##class(Api.Config.Services.Security.Applications).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.Security.Applications).Delete(name))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="LoadConfiguration">
<Description><![CDATA[
Load configuration.<br/>
The method arguments hold values for:<br/>
    model, configuration in json format.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	Do ##class(IORedirect.Redirect).ToStream()
	Try {
		Set tSC = ##class(Api.Config.Services.Loader).Load(dModel)
	}
	Catch ex {
		Set tSC=ex.AsStatus()
	}
	
	Do ##class(IORedirect.Redirect).RestoreIO()
	Set stream = ##class(IORedirect.Redirect).Get()
	
	If $$$ISERR(tSC) {
		Do ..%SetStatusCode(500)
		Do stream.WriteLine($SYSTEM.Status.GetOneErrorText(tSC))
	}
	Do stream.Rewind()
	Quit stream
]]></Implementation>
</Method>

<Method name="DeleteConfiguration">
<Description><![CDATA[
WARNING Delete all namespaces, databases, webapps,... defined in configuration object.<br/>
The method arguments hold values for:<br/>
    model, configuration in json format.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Stream.Object</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
	Set dModel = {}.%FromJSON(model)
	Do ##class(IORedirect.Redirect).ToStream()
	
	Try {
		Set tSC = ##class(Api.Config.Services.Loader).Delete(dModel)
	}
	Catch ex {
		Set tSC=ex.AsStatus()
	}
	
	Do ##class(IORedirect.Redirect).RestoreIO()
	Set stream = ##class(IORedirect.Redirect).Get()
	
	If $$$ISERR(tSC) {
		Do ..%SetStatusCode(500)
		Do stream.WriteLine($SYSTEM.Status.GetOneErrorText(tSC))
	}
	Do stream.Rewind()
	Quit stream
]]></Implementation>
</Method>

<Method name="GetListOfServices">
<Description>
Get list of services.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec/>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set lst = ##class(Api.Config.Services.Security.Services).List()
	Do ..%SetStatusCode($$$HTTP200)
	Do ..%SetContentType("application/json")
	Quit {"ListOfServices":(lst)}
]]></Implementation>
</Method>

<Method name="GetService">
<Description><![CDATA[
Get service detail by name<br/>
The method arguments hold values for:<br/>
    name<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set name = ##class(%CSP.Page).UnescapeURL(name)
	If '##class(Api.Config.Services.Security.Services).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	Quit ##class(Api.Config.Services.Security.Services).Get(name)
]]></Implementation>
</Method>

<Method name="PutService">
<Description><![CDATA[
Update service.  Set Enable property to 1/0 to activate/disable.<br/>
The method arguments hold values for:<br/>
    name<br/>
    model<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,model:%Stream.Object</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(model)
	Set name = ##class(%CSP.Page).UnescapeURL(name)
	If '##class(Api.Config.Services.Security.Services).Exists(name) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}

	$$$ThrowOnError(##class(Api.Config.Services.Security.Services).Update(dModel))
	Do ..%SetStatusCode($$$HTTP204)
	Quit ""
]]></Implementation>
</Method>

<Method name="PostExport">
<Description><![CDATA[
Create an export instance on the server following your filter criteria.  You can download the created export with GET /export/{id}.  See the location response header.<br/>
The method arguments hold values for:<br/>
    filter, params filter to export.<br/>
    OnlyNotDefaultValue, export only not default value parameters.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filter:%Stream.Object,OnlyNotDefaultValue:%Integer</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set dModel = {}.%FromJSON(filter)
	Do ..%SetStatusCode($$$HTTP201)
	Set export = ##class(Api.Config.Services.Loader).export(dModel,''OnlyNotDefaultValue)
	Set record = ##class(Api.Config.TempStream).%New()
	Set record.name = "export-config"
	Do export.%ToJSON(record.charStream)
	Do record.%Save()
	Do ..%SetStatusCode($$$HTTP201)
	Do ..%SetHeader("Location", %request.Application_"export/"_record.%Id())
	Quit ""
]]></Implementation>
</Method>

<Method name="GetExport">
<Description><![CDATA[
Get an existing configuration export.<br/>
The method arguments hold values for:<br/>
    id, export id to retrieve.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    If '##class(Api.Config.TempStream).%ExistsId(id) {
		Do ..%SetStatusCode($$$HTTP404)
		Quit ""
	}
	Do ..%SetStatusCode($$$HTTP200)
	Set record = ##class(Api.Config.TempStream).%OpenId(id)
	Set response = {}.%FromJSON(record.charStream)
	Quit response
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.REST.spec">
<ProcedureBlock>1</ProcedureBlock>
<Super>%REST.Spec</Super>
<TimeChanged>65834,73166.913469</TimeChanged>
<TimeCreated>65834,73166.913469</TimeCreated>

<XData name="OpenAPI">
<MimeType>application/json</MimeType>
<Data><![CDATA[
{
  "swagger":"2.0",
  "basePath":"/api/config",
  "schemes":[
    "http",
    "https"
  ],
  "info":{
    "title":"IRIS Config API",
    "version":"0.0.1",
    "description":"Config API.",
    "contact":{
      "name":"Lorenzo Scalese",
      "email":"lorenzo.scalese@gmail.com",
      "url":"https://github.com/lscalese/iris-config-api/"
    },
    "license":{
      "name":"MIT",
      "url":"https://github.com/lscalese/iris-config-api/blob/master/LICENSE"
    }
  },
  "produces":[
    "application/json"
  ],
  "paths":{
    "/":{
      "get":{
        "summary":"Swagger 2.0 specification",
        "tags":[
          "Developer"
        ],
        "operationId":"GetSpecification",
        "description":"Swagger 2.0 specification",
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/loader":{
      "put":{
        "description":"Load configuration.",
        "summary":"Load configuration.",
        "operationId":"LoadConfiguration",
        "tags":[
          "Import/Export configuration"
        ],
        "parameters":[
          {
            "name":"model",
            "description":"configuration in json format.",
            "required":true,
            "in":"body",
            "schema":{
              "$ref":"#/definitions/ConfigDocument"
            }
          }
        ],
        "produces":[
          "text/plain"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"WARNING Delete all namespaces, databases, webapps,... defined in configuration object.",
        "description":"WARNING Delete all namespaces, databases, webapps,... defined in configuration object.",
        "operationId":"DeleteConfiguration",
        "tags":[
          "Import/Export configuration"
        ],
        "parameters":[
          {
            "name":"model",
            "description":"configuration in json format.",
            "required":true,
            "in":"body",
            "schema":{
            }
          }
        ],
        "produces":[
          "text/plain"
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/export":{
      "post":{
        "tags":[
          "Import/Export configuration"
        ],
        "summary":"Export a part of IRIS configuration.",
        "description":"Create an export instance on the server following your filter criteria.  You can download the created export with GET /export/{id}.  See the location response header.  ",
        "operationId":"PostExport",
        "parameters":[
          {
            "name":"filter",
            "description":"params filter to export.",
            "required":true,
            "in":"body",
            "schema":{
              "$ref":"#/definitions/ExportFilter"
            }
          },
          {
            "name":"OnlyNotDefaultValue",
            "description":"export only not default value parameters.",
            "required":true,
            "in":"query",
            "type":"integer",
            "default":"1"
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      }
    },
    "/export/{id}":{
      "get":{
        "tags":[
          "Import/Export configuration"
        ],
        "summary":"Get an existing configuration export.",
        "description":"Get an existing configuration export.",
        "operationId":"GetExport",
        "parameters":[
          {
            "name":"id",
            "description":"export id to retrieve.",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
            }
          }
        }
      }
    },
    "/sys/databases":{
      "get":{
        "tags":[
          "Databases"
        ],
        "summary":"Get list of databases directory.",
        "operationId":"GetListOfDirectory",
        "description":"Get list of databases directory.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDirectory"
            }
          }
        }
      },
      "post":{
        "tags":[
          "Databases"
        ],
        "operationId":"PostDirectory",
        "summary":"Create a new database directory.",
        "description":"Create a new database directory.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory to create.",
            "in":"body",
            "schema":{
              "$ref":"#/definitions/Directory"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Database created",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          },
          "409":{
            "description":"Database already exists."
          }
        }
      }
    },
    "/sys/databases/{directory}/mounted":{
      "put":{
        "tags":[
          "Databases"
        ],
        "operationId":"PutDirectoryMounted",
        "summary":"Mount database.",
        "description":"Mount database.",
        "parameters":[
          {
            "name":"directory",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "tags":[
          "Databases"
        ],
        "operationId":"DeleteDirectoryMounted",
        "summary":"Dismount database.",
        "description":"Dismount database.",
        "parameters":[
          {
            "name":"directory",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/sys/databases/{directory}":{
      "get":{
        "tags":[
          "Databases"
        ],
        "operationId":"GetDirectory",
        "summary":"Get database directory details",
        "description":"Get database directory details.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Directory"
            }
          },
          "404":{
            "description":"Database directory not found."
          }
        }
      },
      "put":{
        "tags":[
          "Databases"
        ],
        "operationId":"PutDirectory",
        "summary":"Update details of an existing database directory.",
        "description":"Update an existing database directory.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"DirectoryModel",
            "description":"Database to update.",
            "in":"body",
            "schema":{
              "$ref":"#/definitions/Directory"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Database updated.",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          },
          "404":{
            "description":"Database to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Databases"
        ],
        "operationId":"DeleteDirectory",
        "description":"Delete database directory.",
        "parameters":[
          {
            "name":"directory",
            "description":"Database directory ex: /usr/irissys/mgr/user/ don't forget to escape -> %2Fusr%2Firissys%2Fmgr%2Fuser%2F.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Database deleted."
          },
          "404":{
            "description":"Database to delete not found."
          }
        }
      }
    },
    "/databases/{name}":{
      "get":{
        "tags":[
          "Databases"
        ],
        "operationId":"GetDatabases",
        "description":"Get Databases.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Databases"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Databases not found."
          }
        }
      },
      "put":{
        "tags":[
          "Databases"
        ],
        "operationId":"PutDatabases",
        "description":"Update Databases.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Databases to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Databases"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Databases to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Databases"
        ],
        "operationId":"DeleteDatabases",
        "description":"Delete Databases.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Databases deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Databases not found."
          }
        }
      }
    },
    "/databases":{
      "get":{
        "tags":[
          "Databases"
        ],
        "operationId":"GetListDatabases",
        "description":"Get List Of Databases.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDatabases"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Databases"
        ],
        "operationId":"PostDatabases",
        "description":"Create Databases.",
        "parameters":[
          {
            "name":"model",
            "description":"Databases to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Databases"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Databases created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Databases already exists."
          }
        }
      }
    },
    "/namespaces/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetNamespaces",
        "description":"Get Namespaces.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Namespaces"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Namespaces not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutNamespaces",
        "description":"Update Namespaces.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Namespaces to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Namespaces"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Namespaces to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteNamespaces",
        "description":"Delete Namespaces.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Namespaces deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Namespaces not found."
          }
        }
      }
    },
    "/namespaces":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListNamespaces",
        "description":"Get List Of Namespaces.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfNamespaces"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostNamespaces",
        "description":"Create Namespaces.",
        "parameters":[
          {
            "name":"model",
            "description":"Namespaces to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Namespaces"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Namespaces created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Namespaces already exists."
          }
        }
      }
    },
    "/security/applications":{
      "post":{
        "summary":"Create a new web applications.",
        "description":"Create a new web applications.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"PostWebApp",
        "parameters":[
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/WebApplication"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"OK",
            "headers":{
              "Location":{
                "type":"string"
              }
            }
          }
        }
      },
      "get":{
        "summary":"Get list of existings web applications.",
        "description":"Get list of existings web applications.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"GetListOfWebApps",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfWebApplication"
            }
          }
        }
      }
    },
    "/security/applications/${name}":{
      "get":{
        "summary":"Get Web application.",
        "description":"Get Web application.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"GetWebApp",
        "parameters":[
          {
            "name":"name",
            "description":"Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "put":{
        "summary":"Update Web application.",
        "description":"Update Web application.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"PutWebApp",
        "parameters":[
          {
            "name":"name",
            "description":"Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig",
            "required":true,
            "type":"string",
            "in":"path"
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/WebApplication"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      },
      "delete":{
        "summary":"Delete Web application.",
        "description":"Delete Web application.",
        "tags":[
          "WebApplication"
        ],
        "operationId":"DeleteWebApp",
        "parameters":[
          {
            "name":"name",
            "description":"Web application url ex : /api/config don't forget to escape -> %2Fapi%2Fconfig",
            "required":true,
            "type":"string",
            "in":"path"
          }
        ],
        "responses":{
          "204":{
            "description":"Web Application Deleted."
          }
        }
      }
    },
    "/configfile":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetConfigFile",
        "description":"Get ConfigFile.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ConfigFile"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"ConfigFile not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutConfigFile",
        "description":"Update ConfigFile.",
        "parameters":[
          {
            "name":"model",
            "description":"ConfigFile to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ConfigFile"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ConfigFile to update not found."
          }
        }
      }
    },
    "/journal":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetJournal",
        "description":"Get Journal.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Journal"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Journal not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutJournal",
        "description":"Update Journal.",
        "parameters":[
          {
            "name":"model",
            "description":"Journal to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Journal"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Journal to update not found."
          }
        }
      }
    },
    "/config":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"Getconfig",
        "description":"Get config.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/config"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"config not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"Putconfig",
        "description":"Update config.",
        "parameters":[
          {
            "name":"model",
            "description":"config to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/config"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"config to update not found."
          }
        }
      }
    },
    "/security/services":{
      "get":{
        "tags":[
          "Services"
        ],
        "summary":"Get list of services.",
        "description":"Get list of services.",
        "parameters":[
        ],
        "operationId":"GetListOfServices",
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfServices"
            }
          }
        }
      }
    },
    "/security/services/{name}":{
      "get":{
        "tags":[
          "Services"
        ],
        "summary":"Get service detail by name",
        "description":"Get service detail by name",
        "operationId":"GetService",
        "parameters":[
          {
            "name":"name",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Services"
            }
          }
        }
      },
      "put":{
        "tags":[
          "Services"
        ],
        "summary":"Update service.",
        "description":"Update service.  Set Enable property to 1/0 to activate/disable.",
        "operationId":"PutService",
        "parameters":[
          {
            "name":"name",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Services"
            }
          }
        ],
        "responses":{
          "200":{
            "description":"OK"
          }
        }
      }
    },
    "/cluster":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetCluster",
        "description":"Get Cluster.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Cluster"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Cluster not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutCluster",
        "description":"Update Cluster.",
        "parameters":[
          {
            "name":"model",
            "description":"Cluster to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Cluster"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Cluster to update not found."
          }
        }
      }
    },
    "/debug/{name}":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetDebug",
        "description":"Get Debug.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Debug"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Debug not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutDebug",
        "description":"Update Debug.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Debug to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Debug"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Debug to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Others"
        ],
        "operationId":"DeleteDebug",
        "description":"Delete Debug.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Debug deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Debug not found."
          }
        }
      }
    },
    "/debug":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetListDebug",
        "description":"Get List Of Debug.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDebug"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Others"
        ],
        "operationId":"PostDebug",
        "description":"Create Debug.",
        "parameters":[
          {
            "name":"model",
            "description":"Debug to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Debug"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Debug created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Debug already exists."
          }
        }
      }
    },
    "/devicesubtypes/{name}":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetDeviceSubTypes",
        "description":"Get DeviceSubTypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/DeviceSubTypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"DeviceSubTypes not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutDeviceSubTypes",
        "description":"Update DeviceSubTypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"DeviceSubTypes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/DeviceSubTypes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"DeviceSubTypes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Devices"
        ],
        "operationId":"DeleteDeviceSubTypes",
        "description":"Delete DeviceSubTypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"DeviceSubTypes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"DeviceSubTypes not found."
          }
        }
      }
    },
    "/devicesubtypes":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetListDeviceSubTypes",
        "description":"Get List Of DeviceSubTypes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDeviceSubTypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Devices"
        ],
        "operationId":"PostDeviceSubTypes",
        "description":"Create DeviceSubTypes.",
        "parameters":[
          {
            "name":"model",
            "description":"DeviceSubTypes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/DeviceSubTypes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"DeviceSubTypes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"DeviceSubTypes already exists."
          }
        }
      }
    },
    "/devices/{name}":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetDevices",
        "description":"Get Devices.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Devices"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Devices not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutDevices",
        "description":"Update Devices.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Devices to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Devices"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Devices to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Devices"
        ],
        "operationId":"DeleteDevices",
        "description":"Delete Devices.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Devices deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Devices not found."
          }
        }
      }
    },
    "/devices":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetListDevices",
        "description":"Get List Of Devices.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfDevices"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Devices"
        ],
        "operationId":"PostDevices",
        "description":"Create Devices.",
        "parameters":[
          {
            "name":"model",
            "description":"Devices to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Devices"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Devices created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Devices already exists."
          }
        }
      }
    },
    "/ecp":{
      "get":{
        "tags":[
          "ECP"
        ],
        "operationId":"GetECP",
        "description":"Get ECP.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ECP"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"ECP not found."
          }
        }
      },
      "put":{
        "tags":[
          "ECP"
        ],
        "operationId":"PutECP",
        "description":"Update ECP.",
        "parameters":[
          {
            "name":"model",
            "description":"ECP to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ECP"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ECP to update not found."
          }
        }
      }
    },
    "/ecpservers/{name}":{
      "get":{
        "tags":[
          "ECP"
        ],
        "operationId":"GetECPServers",
        "description":"Get ECPServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ECPServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"ECPServers not found."
          }
        }
      },
      "put":{
        "tags":[
          "ECP"
        ],
        "operationId":"PutECPServers",
        "description":"Update ECPServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"ECPServers to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ECPServers"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ECPServers to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "ECP"
        ],
        "operationId":"DeleteECPServers",
        "description":"Delete ECPServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"ECPServers deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"ECPServers not found."
          }
        }
      }
    },
    "/ecpservers":{
      "get":{
        "tags":[
          "ECP"
        ],
        "operationId":"GetListECPServers",
        "description":"Get List Of ECPServers.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfECPServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "ECP"
        ],
        "operationId":"PostECPServers",
        "description":"Create ECPServers.",
        "parameters":[
          {
            "name":"model",
            "description":"ECPServers to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/ECPServers"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"ECPServers created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"ECPServers already exists."
          }
        }
      }
    },
    "/io":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetIO",
        "description":"Get IO.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/IO"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"IO not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutIO",
        "description":"Update IO.",
        "parameters":[
          {
            "name":"model",
            "description":"IO to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/IO"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"IO to update not found."
          }
        }
      }
    },
    "/licenseservers/{name}":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetLicenseServers",
        "description":"Get LicenseServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/LicenseServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"LicenseServers not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutLicenseServers",
        "description":"Update LicenseServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"LicenseServers to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/LicenseServers"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"LicenseServers to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Others"
        ],
        "operationId":"DeleteLicenseServers",
        "description":"Delete LicenseServers.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"LicenseServers deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"LicenseServers not found."
          }
        }
      }
    },
    "/licenseservers":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetListLicenseServers",
        "description":"Get List Of LicenseServers.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfLicenseServers"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Others"
        ],
        "operationId":"PostLicenseServers",
        "description":"Create LicenseServers.",
        "parameters":[
          {
            "name":"model",
            "description":"LicenseServers to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/LicenseServers"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"LicenseServers created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"LicenseServers already exists."
          }
        }
      }
    },
    "/magtapes/{name}":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetMagTapes",
        "description":"Get MagTapes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MagTapes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MagTapes not found."
          }
        }
      },
      "put":{
        "tags":[
          "Devices"
        ],
        "operationId":"PutMagTapes",
        "description":"Update MagTapes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MagTapes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MagTapes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MagTapes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Devices"
        ],
        "operationId":"DeleteMagTapes",
        "description":"Delete MagTapes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MagTapes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MagTapes not found."
          }
        }
      }
    },
    "/magtapes":{
      "get":{
        "tags":[
          "Devices"
        ],
        "operationId":"GetListMagTapes",
        "description":"Get List Of MagTapes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMagTapes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Devices"
        ],
        "operationId":"PostMagTapes",
        "description":"Create MagTapes.",
        "parameters":[
          {
            "name":"model",
            "description":"MagTapes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MagTapes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MagTapes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MagTapes already exists."
          }
        }
      }
    },
    "/mapglobals/{namespace}/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetMapGlobals",
        "description":"Get MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapGlobals"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapGlobals not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutMapGlobals",
        "description":"Update MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapGlobals to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapGlobals"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapGlobals to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteMapGlobals",
        "description":"Delete MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapGlobals deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapGlobals not found."
          }
        }
      }
    },
    "/mapglobals/{namespace}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListMapGlobals",
        "description":"Get List Of MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace.",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapGlobals"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostMapGlobals",
        "description":"Create MapGlobals.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapGlobals to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapGlobals"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapGlobals created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapGlobals already exists."
          }
        }
      }
    },
    "/mapmirrors/{id}/{name}":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetMapMirrors",
        "description":"Get MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapMirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapMirrors not found."
          }
        }
      },
      "put":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PutMapMirrors",
        "description":"Update MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving.",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapMirrors to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapMirrors"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapMirrors to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"DeleteMapMirrors",
        "description":"Delete MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving.",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapMirrors deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapMirrors not found."
          }
        }
      }
    },
    "/mapmirrors/{id}":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetListMapMirrors",
        "description":"Get List Of MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapMirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PostMapMirrors",
        "description":"Create MapMirrors.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapMirrors to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapMirrors"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapMirrors created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapMirrors already exists."
          }
        }
      }
    },
    "/mappackages/{namespace}/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetMapPackages",
        "description":"Get MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapPackages"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapPackages not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutMapPackages",
        "description":"Update MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapPackages to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapPackages"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapPackages to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteMapPackages",
        "description":"Delete MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapPackages deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapPackages not found."
          }
        }
      }
    },
    "/mappackages/{namespace}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListMapPackages",
        "description":"Get List Of MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace.",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapPackages"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostMapPackages",
        "description":"Create MapPackages.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapPackages to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapPackages"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapPackages created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapPackages already exists."
          }
        }
      }
    },
    "/maproutines/{namespace}/{name}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetMapRoutines",
        "description":"Get MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapRoutines"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapRoutines not found."
          }
        }
      },
      "put":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PutMapRoutines",
        "description":"Update MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapRoutines to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapRoutines"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapRoutines to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"DeleteMapRoutines",
        "description":"Delete MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapRoutines deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapRoutines not found."
          }
        }
      }
    },
    "/maproutines/{namespace}":{
      "get":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"GetListMapRoutines",
        "description":"Get List Of MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"namespace.",
            "in":"path",
            "required":true,
            "type":"string"
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapRoutines"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Namespaces"
        ],
        "operationId":"PostMapRoutines",
        "description":"Create MapRoutines.",
        "parameters":[
          {
            "name":"namespace",
            "description":"Namespace where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapRoutines to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapRoutines"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapRoutines created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapRoutines already exists."
          }
        }
      }
    },
    "/mapshadows/{id}/{name}":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetMapShadows",
        "description":"Get MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MapShadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MapShadows not found."
          }
        }
      },
      "put":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PutMapShadows",
        "description":"Update MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapShadows to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapShadows"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapShadows to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Shadows"
        ],
        "operationId":"DeleteMapShadows",
        "description":"Delete MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"name",
            "description":"Name of the mapping.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"MapShadows deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MapShadows not found."
          }
        }
      }
    },
    "/mapshadows/{id}":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetListMapShadows",
        "description":"Get List Of MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMapShadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PostMapShadows",
        "description":"Create MapShadows.",
        "parameters":[
          {
            "name":"id",
            "description":"ID where the mapping is.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"MapShadows to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MapShadows"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"MapShadows created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"MapShadows already exists."
          }
        }
      }
    },
    "/mirrormember":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetMirrorMember",
        "description":"Get MirrorMember.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/MirrorMember"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"MirrorMember not found."
          }
        }
      },
      "put":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PutMirrorMember",
        "description":"Update MirrorMember.",
        "parameters":[
          {
            "name":"model",
            "description":"MirrorMember to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/MirrorMember"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"MirrorMember to update not found."
          }
        }
      }
    },
    "/mirrors/{name}":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetMirrors",
        "description":"Get Mirrors.",
        "parameters":[
          {
            "name":"name",
            "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Mirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Mirrors not found."
          }
        }
      },
      "put":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PutMirrors",
        "description":"Update Mirrors.",
        "parameters":[
          {
            "name":"name",
            "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Mirrors to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Mirrors"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Mirrors to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"DeleteMirrors",
        "description":"Delete Mirrors.",
        "parameters":[
          {
            "name":"name",
            "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Mirrors deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Mirrors not found."
          }
        }
      }
    },
    "/mirrors":{
      "get":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"GetListMirrors",
        "description":"Get List Of Mirrors.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfMirrors"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Mirrors"
        ],
        "operationId":"PostMirrors",
        "description":"Create Mirrors.",
        "parameters":[
          {
            "name":"model",
            "description":"Mirrors to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Mirrors"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Mirrors created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Mirrors already exists."
          }
        }
      }
    },
    "/miscellaneous":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetMiscellaneous",
        "description":"Get Miscellaneous.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Miscellaneous"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Miscellaneous not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutMiscellaneous",
        "description":"Update Miscellaneous.",
        "parameters":[
          {
            "name":"model",
            "description":"Miscellaneous to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Miscellaneous"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Miscellaneous to update not found."
          }
        }
      }
    },
    "/monitor":{
      "get":{
        "tags":[
          "Others"
        ],
        "operationId":"GetMonitor",
        "description":"Get Monitor.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Monitor"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Monitor not found."
          }
        }
      },
      "put":{
        "tags":[
          "Others"
        ],
        "operationId":"PutMonitor",
        "description":"Update Monitor.",
        "parameters":[
          {
            "name":"model",
            "description":"Monitor to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Monitor"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Monitor to update not found."
          }
        }
      }
    },
    "/sql":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetSQL",
        "description":"Get SQL.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SQL"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"SQL not found."
          }
        }
      },
      "put":{
        "tags":[
          "SQL"
        ],
        "operationId":"PutSQL",
        "description":"Update SQL.",
        "parameters":[
          {
            "name":"model",
            "description":"SQL to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SQL"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SQL to update not found."
          }
        }
      }
    },
    "/shadows/{name}":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetShadows",
        "description":"Get Shadows.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Shadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Shadows not found."
          }
        }
      },
      "put":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PutShadows",
        "description":"Update Shadows.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"Shadows to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Shadows"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Shadows to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "Shadows"
        ],
        "operationId":"DeleteShadows",
        "description":"Delete Shadows.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"Shadows deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Shadows not found."
          }
        }
      }
    },
    "/shadows":{
      "get":{
        "tags":[
          "Shadows"
        ],
        "operationId":"GetListShadows",
        "description":"Get List Of Shadows.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfShadows"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "Shadows"
        ],
        "operationId":"PostShadows",
        "description":"Create Shadows.",
        "parameters":[
          {
            "name":"model",
            "description":"Shadows to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Shadows"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"Shadows created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"Shadows already exists."
          }
        }
      }
    },
    "/sqlsysdatatypes/{name}":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetSqlSysDatatypes",
        "description":"Get SqlSysDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SqlSysDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"SqlSysDatatypes not found."
          }
        }
      },
      "put":{
        "tags":[
          "SQL"
        ],
        "operationId":"PutSqlSysDatatypes",
        "description":"Update SqlSysDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"SqlSysDatatypes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlSysDatatypes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlSysDatatypes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "SQL"
        ],
        "operationId":"DeleteSqlSysDatatypes",
        "description":"Delete SqlSysDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"SqlSysDatatypes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlSysDatatypes not found."
          }
        }
      }
    },
    "/sqlsysdatatypes":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetListSqlSysDatatypes",
        "description":"Get List Of SqlSysDatatypes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSqlSysDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "SQL"
        ],
        "operationId":"PostSqlSysDatatypes",
        "description":"Create SqlSysDatatypes.",
        "parameters":[
          {
            "name":"model",
            "description":"SqlSysDatatypes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlSysDatatypes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"SqlSysDatatypes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"SqlSysDatatypes already exists."
          }
        }
      }
    },
    "/sqluserdatatypes/{name}":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetSqlUserDatatypes",
        "description":"Get SqlUserDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/SqlUserDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"SqlUserDatatypes not found."
          }
        }
      },
      "put":{
        "tags":[
          "SQL"
        ],
        "operationId":"PutSqlUserDatatypes",
        "description":"Update SqlUserDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          },
          {
            "name":"model",
            "description":"SqlUserDatatypes to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlUserDatatypes"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlUserDatatypes to update not found."
          }
        }
      },
      "delete":{
        "tags":[
          "SQL"
        ],
        "operationId":"DeleteSqlUserDatatypes",
        "description":"Delete SqlUserDatatypes.",
        "parameters":[
          {
            "name":"name",
            "description":"Name of the object instance.<br>",
            "in":"path",
            "type":"string",
            "required":true
          }
        ],
        "responses":{
          "204":{
            "description":"SqlUserDatatypes deleted."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"SqlUserDatatypes not found."
          }
        }
      }
    },
    "/sqluserdatatypes":{
      "get":{
        "tags":[
          "SQL"
        ],
        "operationId":"GetListSqlUserDatatypes",
        "description":"Get List Of SqlUserDatatypes.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/ListOfSqlUserDatatypes"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          }
        }
      },
      "post":{
        "tags":[
          "SQL"
        ],
        "operationId":"PostSqlUserDatatypes",
        "description":"Create SqlUserDatatypes.",
        "parameters":[
          {
            "name":"model",
            "description":"SqlUserDatatypes to create.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/SqlUserDatatypes"
            }
          }
        ],
        "responses":{
          "201":{
            "description":"SqlUserDatatypes created.",
            "headers":{
              "Location":{
                "type":"string",
                "description":"Created ressource location."
              }
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "409":{
            "description":"SqlUserDatatypes already exists."
          }
        }
      }
    },
    "/startup":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetStartup",
        "description":"Get Startup.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Startup"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Startup not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutStartup",
        "description":"Update Startup.",
        "parameters":[
          {
            "name":"model",
            "description":"Startup to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Startup"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Startup to update not found."
          }
        }
      }
    },
    "/telnet":{
      "get":{
        "tags":[
          "System settings"
        ],
        "operationId":"GetTelnet",
        "description":"Get Telnet.",
        "parameters":[
        ],
        "responses":{
          "200":{
            "description":"OK",
            "schema":{
              "$ref":"#/definitions/Telnet"
            }
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty."
          },
          "404":{
            "description":"Telnet not found."
          }
        }
      },
      "put":{
        "tags":[
          "System settings"
        ],
        "operationId":"PutTelnet",
        "description":"Update Telnet.",
        "parameters":[
          {
            "name":"model",
            "description":"Telnet to update.",
            "in":"body",
            "required":true,
            "schema":{
              "$ref":"#/definitions/Telnet"
            }
          }
        ],
        "responses":{
          "204":{
            "description":"Ressource updated."
          },
          "400":{
            "description":"Bad request, can occurs if mandatory parameters are missing or empty"
          },
          "404":{
            "description":"Telnet to update not found."
          }
        }
      }
    }
  },
  "definitions":{
    "ExportFilter":{
      "type":"object",
      "properties":{
      },
      "example":{
        "Namespaces":{
          "MYAPP":""
        },
        "MapGlobals":{
          "MYAPP":""
        },
        "MapPackages":{
          "MYAPP":""
        },
        "MapRoutines":{
          "MYAPP":""
        },
        "Security.Applications":{
          "/csp/zrestapp":"",
          "/csp/zwebapp":""
        },
        "Journal":"",
        "config":""
      }
    },
    "ListOfServices":{
      "type":"object",
      "properties":{
        "ListOfWebApps":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Services"
          }
        }
      }
    },
    "Services":{
      "type":"object",
      "properties":{
        "AutheEnabled":{
          "type":"string",
          "default":0,
          "description":"Authentication methods enabled for the service<br>\r\nBit 0 = AutheK5CCache<br>\r\nBit 1 = AutheK5Prompt<br>\r\nBit 2 = AutheK5API<br>\r\nBit 3 = AutheK5KeyTab<br>\r\nBit 4 = AutheOS<br>\r\nBit 5 - AutheCache<br>\r\nBit 6 = AutheUnauthenticated<br>\r\nBit 7 = AutheKB<br>\r\nBit 8 = AutheKBEncryption<br>\r\nBit 9 = AutheKBIntegrity<br>\r\nBit 10 = AutheSystem<br>\r\nBit 11 = AutheLDAP<br>\r\nBit 13 = AutheDelegated<br>\r\nBit 14 = AutheLoginToken<br>\r\nBits 15-19 reserved<br>\r\nBit 20 = TwoFactorSMS<br>\r\nBit 21 = TwoFactorPW<br>"
        },
        "ClientSystems":{
          "type":"string",
          "default":"",
          "description":"List of valid IP addresses allowed to connect for this service."
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Full name of the service"
        },
        "Enabled":{
          "type":"boolean",
          "default":0,
          "description":"Service enabled"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the service"
        }
      },
      "required":[
        "Description",
        "Name"
      ],
      "example":{
        "Description":"",
        "Name":""
      }
    },
    "ListOfWebApplication":{
      "type":"object",
      "properties":{
        "ListOfWebApps":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/WebApplication"
          }
        }
      }
    },
    "WebApplication":{
      "type":"object",
      "properties":{
        "AutheEnabled":{
          "type":"string",
          "default":64,
          "description":"Authentication and Session mechanisms enabled (CSP Only).<br>\r\nBit 2 = AutheK5API<br>\r\nBit 5 - AutheCache<br>\r\nBit 6 = AutheUnauthenticated<br>\r\nBit 11 = AutheLDAP<br>\r\nBit 13 = AutheDelegated<br>\r\nBit 14 = LoginToken<br>\r\nBit 20 = TwoFactorSMS<br>\r\nBit 21 = TwoFactorPW<br>"
        },
        "AutoCompile":{
          "type":"boolean",
          "default":1,
          "description":"This specifies whether CSP files should automatically compile or not (CSP Only).<br>\r\nIf this is turned on, then when a CSP file is more recent than its compiled class,<br>\r\nit is recompiled. This is normally something you would turn on in development environments<br>\r\nand turn off in production environments."
        },
        "CSPZENEnabled":{
          "type":"boolean",
          "default":1,
          "description":"Indicates whether this application will process CSP/Zen Pages (CSP Only)."
        },
        "CSRFToken":{
          "type":"boolean",
          "default":0,
          "description":"Prevent login CSRF attack (CSP only).<br>\r\nWhen enabled generate a token and cookie in the login page that is validated before accepting \r\nany username/password. Enabling this will prevent programatic access to pages in this application \r\nthat just pass in the username/password on the initial request. "
        },
        "ChangePasswordPage":{
          "type":"string",
          "default":"",
          "description":"A predefined change password page that can be sent out to the browser if the user account requires<br>\r\nthat a password change is required(CSP Only).<br>"
        },
        "ClientApplications":{
          "type":"string",
          "default":"",
          "description":"List of time stamps and hash values for valid executables (Client Applications Only).\r\nEach element is in the form $zdatetime($h,3)^HashValue"
        },
        "CookiePath":{
          "type":"string",
          "default":"",
          "description":"Scope of the session cookie (CSP Only).<br>\r\nThis determines which urls the browser will send the session cookie back to InterSystems IRIS.<br>\r\nIf your application name is 'myapp', it defaults to '/myapp/' meaning it will only send<br>\r\nthe cookie for pages under '/myapp/'. You should restrict this to only what is required<br>\r\nby your application to prevent this session cookie being used by other CSP application<br>\r\non this machine, or from being seen by any other application on this web server.<br>"
        },
        "DeepSeeEnabled":{
          "type":"boolean",
          "default":0,
          "description":"Indicates whether DeepSee access is enabled for this application"
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Application description.<br>"
        },
        "DispatchClass":{
          "type":"string",
          "default":"",
          "description":"If defined this will dispatch all requests in this CSP application to this one class.\r\nThis will bypass the normal url to classname conversion so allowing the specified\r\nclass complete control over this dispatch of the page. A predefined dispatch class\r\nthat can be used is 'CSP.REST' which provides REST dispatch capabilities."
        },
        "Enabled":{
          "type":"boolean",
          "default":1,
          "description":"Application is enabled.<br>"
        },
        "ErrorPage":{
          "type":"string",
          "default":"",
          "description":"A CSP or CLS page that will be displayed if an error occurs when generating the page (CSP Only).<br>"
        },
        "EventClass":{
          "type":"string",
          "default":"",
          "description":"This specifies the class whose methods are invoked for CSP application events,<br>\r\nsuch as a timeout (CSP Only)."
        },
        "GroupById":{
          "type":"string",
          "default":"",
          "description":"Indicates whether this application's authentication will move in sync with other applications in the same id group (CSP Only)."
        },
        "InbndWebServicesEnabled":{
          "type":"boolean",
          "default":1,
          "description":"Indicates whether this application will process Web Services (CSP Only)."
        },
        "IsNameSpaceDefault":{
          "type":"boolean",
          "default":0,
          "description":"Indicates that this application is the default application for its namespace. \r\nAs such it will be returned by the call $System.CSP.GetDefaultApp()"
        },
        "LockCSPName":{
          "type":"boolean",
          "default":1,
          "description":"Lock CSP Name (CSP Only). <br>\r\nIf true then you can only access this CSP page if the url you enter matches\r\nthe url stored in the CSPURL parameter value in the class. CSP pages have\r\nthe CSPURL set to the original url requested automatically when they are\r\ncompiled. If the url does not match you get a page not found error. For\r\nexample if you have two CSP applications defined that both map to the same\r\nnamespace and the same directory '/A' and '/B'. Then you view '/A/page.csp'\r\nthis will load this page and create the class 'csp.page' with the CSPURL\r\nparameter set to '/A/page.csp'. With this flag set you may only access this\r\npage using the url '/A/page.csp'. If this flag is false you may access it\r\nvia the pages '/B/page.csp', '/A/csp.page.cls', '/B/csp.page.cls'.  Note that the flag is checked on\r\nthe application associated with the CSPURL parameter, so even if the '/B'\r\napplication has the flag turned off, if the '/A' application has it turned\r\non you will get a page not found error from '/B/page.csp'. If you modify the\r\nCSP class and change the CSPURL=\"\" then this disables checking for this\r\npage."
        },
        "LoginPage":{
          "type":"string",
          "default":"",
          "description":"A predefined login page that can be sent out to the browser if the application requires<br>\r\nan authenticated identity and one is not available yet (CSP Only).<br>"
        },
        "MatchRoles":{
          "type":"string",
          "default":"",
          "description":"Mapping of Match Roles to added Target Roles.<br>\r\nMatchRoles are in the format:<br>\r\nMatchRole:TargetRole1:TargetRole2<br>\r\nTo specify a role to always be granted to an application, set\r\nMatchRole=\"\", i.e. (:TargetRole1)<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Short Name for Application. \r\nWeb applications should start with a  \"/\".<br>\r\nClient Applications are in the format AppName.EXE.<br>\r\nPrivileged routines can be any format.<br>"
        },
        "NameSpace":{
          "type":"string",
          "default":"",
          "description":"The namespace where pages for this application are run (CSP Only).<br>"
        },
        "Package":{
          "type":"string",
          "default":"",
          "description":"Specifies the package to prefix to the class name for all CSP files in this application.<br>\r\nIf not specified it defaults to \"csp\" (CSP Only).<br>"
        },
        "Path":{
          "type":"string",
          "default":"",
          "description":"This specifies the physical path (directory) for the CSP files on the InterSystems IRIS server (CSP Only).<br>"
        },
        "PermittedClasses":{
          "type":"string",
          "default":"",
          "description":"A name pattern which is used by the CSP Server to limit the classes which may be run in this application. <br>\r\nThis is a COS pattern, (1\"B\",1\"A\".1N) match {B.cls, A0.cls ... A9.cls} <br>"
        },
        "Recurse":{
          "type":"boolean",
          "default":1,
          "description":"This specifies whether to use subdirectories (CSP Only).<br>\r\nIf WPath is the Web Path and PPath is the Physical Path, then with recurse turned on,<br>\r\nWPath/xxx/yyy will look in PPath/xxx/yyy. If recurse is turned off, only files directly<br>\r\ncontained in WPath are used."
        },
        "Resource":{
          "type":"string",
          "default":"",
          "description":"The Resource name that controls access to this application.<br>\r\nIf no resource is defined, then it is a public application which\r\nanyone can run.<br>"
        },
        "Routines":{
          "type":"string",
          "default":"",
          "description":"List of Routines that can invoke this application (Privileged routine applications only).<br>\r\nThese are in the format Routine/Class:dbname:Flag, where dbname is \r\nthe name of the database where the routine resides; Flag=0 is a routine, Flag=1 is a class name."
        },
        "ServeFiles":{
          "type":"integer",
          "default":1,
          "description":"Allows the web server built into InterSystems IRIS to serve up static files, e.g., html or jpg files,<br>\r\nfrom this application path (CSP Only).<br>\r\nThis also allows the stream server to serve files from this path.<br>\r\n0 - No - Never serve files from this application path<br>\r\n1 - Always - Always serve files from this application path, ignore CSP security setting for this path for static files. This is the default for new applications as it is backward compatible with serving files from the web server.<br>\r\n2 - Always and cached - Always serve files from this application path and allow the CSP gateway to cache these files to avoid having to request them from InterSystems IRIS. This is the mode we expect deployed application to use<br>\r\n3 - Use CSP security - If the user has permissions to view a csp/cls page in this application then allow them to view a static file, if they do not have permissions to view a csp/cls page then return a 404 page not found page.<br>"
        },
        "ServeFilesTimeout":{
          "type":"integer",
          "default":3600,
          "description":"Time, in seconds, of how long to cache static files.<br>"
        },
        "SessionScope":{
          "type":"integer",
          "default":2,
          "description":"SameSite value that is used for CSP Session cookies.<br>\r\nThis setting affects whether session cookies are sent for cross-site requests. <br>\r\nThe default setting for a new application is Strict.<br>\r\n0 - None - Send cookie with cross-site requests .<br>\r\n1 - Lax - Send cookie with top-level cross-site navigation. <br>\r\n2 - Strict - Do not send cookie with cross-site requests. <br>"
        },
        "SuperClass":{
          "type":"string",
          "default":"",
          "description":"This specifies the default superclass (CSP Only).<br>\r\nIf blank, it defaults to %CSP.Page.<br>"
        },
        "Timeout":{
          "type":"integer",
          "default":900,
          "description":"This specifies the default session timeout, in seconds (CSP Only).<br>"
        },
        "Type":{
          "type":"string",
          "default":2,
          "description":"Type - Bitmap describing the type of application<br>\r\nBit 0 = System Application - Reserved<br>\r\nBit 1 = CSP Application (Default)<br>\r\nBit 2 = Privileged routine application<br>\r\nBit 3 - Client Application<br>"
        },
        "UseCookies":{
          "type":"integer",
          "default":2,
          "description":"This specifies whether to use cookies for CSP session management or not (CSP Only).<br>\r\nYou can set this on a per-application basis. It does NOT affect the user's use of<br>\r\ncookies in their application, simply how the session is managed. The available<br>\r\noptions are:<br>\r\n'Never' use cookies - This will just use the CSPCHD parameter to persist the session<br>\r\nstate from page to page and will not send a cookie to the browser at all.<br>\r\n'AutoDetect' (the default) - This will start by sending the cookie to the browser and<br>\r\nalso including the CSPCHD parameter in all the links and forms. Then when the user clicks<br>\r\non the next link if the browser accepted the cookie it will switch to the 'Always'<br>\r\nmode and turn off the use of the CSPCHD parameters. If the browser did not accept<br>\r\nthe cookie it will turn into the 'Never' mode.<br>\r\n'Always' use cookies - Do not include the CSPCHD parameter.<br>\r\n0 = Never, 1 = AutoDetect, 2 = Always"
        },
        "UserCookieScope":{
          "type":"integer",
          "default":2,
          "description":"Default SameSite value for cookies created by users' calls to %CSP.Response.SetCookie().<br>\r\nThis setting affects whether session cookies are sent for cross-site requests. <br>\r\nUsers can override the default by specifying the SameSite value in their SetCookie call.<br>\r\n0 - None - Send cookie with cross-site requests .<br>\r\n1 - Lax - Send same-site cookies with top-level cross-site navigation. <br>\r\n2 - Strict - Do not send same-site cookies with cross-site requests. "
        },
        "iKnowEnabled":{
          "type":"boolean",
          "default":0,
          "description":"Indicates whether iKnow access is enabled for this application"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AutheEnabled":"32",
        "AutoCompile":true,
        "CSPZENEnabled":true,
        "CSRFToken":false,
        "ChangePasswordPage":"",
        "CookiePath":"/api/config/",
        "DeepSeeEnabled":true,
        "Description":"",
        "DispatchClass":"Api.Config.REST.disp",
        "Enabled":true,
        "ErrorPage":"",
        "EventClass":"",
        "GroupById":"",
        "InbndWebServicesEnabled":true,
        "IsNameSpaceDefault":false,
        "LockCSPName":true,
        "LoginPage":"",
        "MatchRoles":"",
        "Name":"/api/config",
        "NameSpace":"USER",
        "Package":"",
        "Path":"",
        "PermittedClasses":"",
        "Recurse":true,
        "Resource":"",
        "ServeFiles":1,
        "ServeFilesTimeout":3600,
        "SessionScope":2,
        "SuperClass":"",
        "Timeout":900,
        "Type":"2",
        "UseCookies":2,
        "UserCookieScope":2,
        "iKnowEnabled":true
      }
    },
    "ListOfDirectory":{
      "type":"object",
      "properties":{
        "ListOfDirectory":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Directory"
          }
        }
      }
    },
    "Directory":{
      "type":"object",
      "properties":{
        "BlockFormat":{
          "type":"integer",
          "default":2
        },
        "BlockSize":{
          "type":"integer",
          "default":""
        },
        "Blocks":{
          "type":"integer",
          "default":0
        },
        "BlocksPerMap":{
          "type":"integer",
          "default":0
        },
        "ClusterMountMode":{
          "type":"boolean",
          "default":0
        },
        "ClusterMounted":{
          "type":"boolean",
          "default":0
        },
        "CompressionEngine":{
          "type":"integer",
          "default":0
        },
        "CurrentMaps":{
          "type":"integer",
          "default":""
        },
        "Directory":{
          "type":"string",
          "default":""
        },
        "DirectoryBlock":{
          "type":"integer",
          "default":3
        },
        "EncryptedDB":{
          "type":"boolean",
          "default":0
        },
        "EncryptionKeyID":{
          "type":"string",
          "default":""
        },
        "Expanding":{
          "type":"boolean",
          "default":0
        },
        "ExpansionSize":{
          "type":"integer",
          "default":0
        },
        "Full":{
          "type":"boolean",
          "default":0
        },
        "GlobalJournalState":{
          "type":"string",
          "default":""
        },
        "InActiveMirror":{
          "type":"boolean",
          "default":0
        },
        "LastExpansionTime":{
          "type":"string",
          "default":0
        },
        "MaxSize":{
          "type":"integer",
          "default":0
        },
        "MirrorActivationRequired":{
          "type":"boolean",
          "default":0
        },
        "MirrorDBCatchup":{
          "type":"boolean",
          "default":0
        },
        "MirrorDBCreatedNew":{
          "type":"boolean",
          "default":0
        },
        "MirrorDBName":{
          "type":"string",
          "default":""
        },
        "MirrorDBPaused":{
          "type":"boolean",
          "default":0
        },
        "MirrorFailoverDB":{
          "type":"boolean",
          "default":0
        },
        "MirrorNoWrite":{
          "type":"boolean",
          "default":0
        },
        "MirrorObsolete":{
          "type":"boolean",
          "default":0
        },
        "MirrorSetName":{
          "type":"string",
          "default":""
        },
        "Mirrored":{
          "type":"boolean",
          "default":0
        },
        "Mounted":{
          "type":"boolean",
          "default":0
        },
        "NewGlobalCollation":{
          "type":"string",
          "default":5
        },
        "NewGlobalGrowthBlock":{
          "type":"integer",
          "default":50
        },
        "NewGlobalIsKeep":{
          "type":"boolean",
          "default":0
        },
        "NewGlobalPointerBlock":{
          "type":"integer",
          "default":16
        },
        "NumberOfConfigDB":{
          "type":"integer",
          "default":0
        },
        "ROReasonCode":{
          "type":"integer",
          "default":0
        },
        "ROReasonText":{
          "type":"string",
          "default":""
        },
        "ReCreate":{
          "type":"boolean",
          "default":0
        },
        "ReadOnly":{
          "type":"boolean",
          "default":0
        },
        "ReadOnlyMounted":{
          "type":"boolean",
          "default":0
        },
        "Reinitialize":{
          "type":"boolean",
          "default":0
        },
        "RequestSize":{
          "type":"integer",
          "default":0
        },
        "ResourceName":{
          "type":"string",
          "default":""
        },
        "RunCatchupDBOnCreate":{
          "type":"boolean",
          "default":1
        },
        "SFN":{
          "type":"integer",
          "default":""
        },
        "Size":{
          "type":"integer",
          "default":1
        },
        "Skeleton":{
          "type":"boolean",
          "default":0
        },
        "SparseDB":{
          "type":"boolean",
          "default":0
        }
      },
      "example":{
        "Directory":"/usr/irissys/mgr/user/ztestapidata/",
        "ExpansionSize":0,
        "NewGlobalCollation":"5",
        "ReadOnly":false
      }
    },
    "ConfigDocument":{
      "type":"object",
      "example":{
        "Defaults":{
          "DBDIR":"${MGRDIR}",
          "WEBAPPDIR":"${CSPDIR}",
          "DBDATA":"${DBDIR}myappdata/",
          "DBARCHIVE":"${DBDIR}myapparchive/",
          "DBCODE":"${DBDIR}myappcode/",
          "DBLOG":"${DBDIR}myapplog/"
        },
        "SYS.Databases":{
          "${DBDATA}":{
            "ExpansionSize":128
          },
          "${DBARCHIVE}":{
          },
          "${DBCODE}":{
          },
          "${DBLOG}":{
          }
        },
        "Databases":{
          "MYAPPDATA":{
            "Directory":"${DBDATA}"
          },
          "MYAPPCODE":{
            "Directory":"${DBCODE}"
          },
          "MYAPPARCHIVE":{
            "Directory":"${DBARCHIVE}"
          },
          "MYAPPLOG":{
            "Directory":"${DBLOG}"
          }
        },
        "Namespaces":{
          "MYAPP":{
            "Globals":"MYAPPDATA",
            "Routines":"MYAPPCODE"
          }
        },
        "Security.Applications":{
          "/csp/zrestapp":{
            "DispatchClas":"my.dispatch.class",
            "Namespace":"MYAPP",
            "Enabled":"1",
            "AuthEnabled":"64",
            "CookiePath":"/csp/zrestapp/"
          },
          "/csp/zwebapp":{
            "Path":"${WEBAPPDIR}zwebapp/",
            "Namespace":"MYAPP",
            "Enabled":"1",
            "AuthEnabled":"64",
            "CookiePath":"/csp/zwebapp/"
          }
        },
        "MapGlobals":{
          "MYAPP":[
            {
              "Name":"Archive.Data",
              "Database":"MYAPPARCHIVE"
            },
            {
              "Name":"App.Log",
              "Database":"MYAPPLOG"
            }
          ]
        },
        "MapPackages":{
          "MYAPP":[
            {
              "Namespace":"MYAPP",
              "Name":"PackageName",
              "Database":"USER"
            }
          ]
        },
        "MapRoutines":{
          "MYAPP":[
            {
              "Namespace":"MYAPP",
              "Name":"RoutineName",
              "Database":"USER"
            }
          ]
        },
        "Journal":{
          "FreezeOnError":1
        },
        "Security.Services":{
          "%Service_Mirror":{
            "Enabled":0
          }
        },
        "SQL":{
          "LockThreshold":2500
        },
        "config":{
          "locksiz":33554432
        },
        "Startup":{
          "SystemMode":"DEVELOPMENT"
        }
      }
    },
    "Cluster":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "CommIPAddress":{
          "type":"string",
          "default":"",
          "description":"Defines the IP Address to advertise in the PIJ to the other cluster members.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "JoinCluster":{
          "type":"boolean",
          "default":0,
          "description":"Set to True if this configuration is part of a cluster.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "CommIPAddress":"",
        "JoinCluster":false
      }
    },
    "ConfigFile":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Product":{
          "type":"string",
          "default":"IRIS",
          "description":""
        },
        "Version":{
          "type":"string",
          "default":"",
          "description":"Version of the CPF file.<br>"
        }
      },
      "required":[
        "Name",
        "Version"
      ],
      "example":{
        "Product":"IRIS",
        "Version":"2020.4"
      }
    },
    "Databases":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "ClusterMountMode":{
          "type":"boolean",
          "default":0,
          "description":" Specifies whether the database should be mounted privately or clustered.<br>\r\n 0 - Mount private<br>\r\n 1 - Mount clustered<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Directory":{
          "type":"string",
          "default":"",
          "description":" Directory where the database resides.<br><br>\r\n On ECP Clients of a mirror this contains logical references to the databases on the\r\n failover miror memebers as the path may be different on the various nodes. <br>\r\n This has two forms:<br>\r\n &nbsp&nbsp&nbsp&nbsp&nbsp:mirror:&ltmirror name&gt:&ltmirror database name&gt <br>\r\n &nbsp&nbsp&nbsp&nbsp&nbsp:ds:&ltconfig database name&gt <br>\r\n <br>\r\n The 1st form, :mirror:&ltmirror name&gt:&ltmirror database name&gt, refers to a mirrored database. The mirror\r\n database name is the internal mirror name assigned to the database when it was added to\r\n the mirror. This is generally the same as the database name in the configuration.\r\n <br><br>\r\n The 2nd form, :ds:&ltconfig database name&gt, refers to a non-mirrored database on the server.\r\n The config database name is the name of the database in the configuration and this database name\r\n is expected to exist on all of the failover members. This form is only used in special circumstances\r\n as normally non-mirrored databases are hosted on the ECP Client, not the ECP Server. This is used\r\n in cases where scratch data (eg. the data will be lost during a mirror failover) needs to be hosted\r\n on the server for some reason."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "MountAtStartup":{
          "type":"boolean",
          "default":0,
          "description":" On a clustered system, specifies whether the database should be mounted at startup.<br>\r\n This property is valid for cluster systems only, and is ignored \r\n for non-cluster systems.<br>\r\n 0 - Don't mount at startup<br>\r\n 1 - Mount at startup<br>"
        },
        "MountRequired":{
          "type":"boolean",
          "default":0,
          "description":" Specifies that the database MUST be successfully mounted at startup.<br>\r\n 0 - Successful mount not required for startup to succeed.<br>\r\n 1 - Successful mount required for startup to succeed.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Server":{
          "type":"string",
          "default":"",
          "description":" Name of the remote server where the DB resides.<br>\r\n If empty, the database is local.<br>\r\n Remote server must already be configured to be entered here.<br>"
        },
        "StreamLocation":{
          "type":"string",
          "default":"",
          "description":" Directory where the streams associated with this database go.<br>\r\n By default (value=\"\"), the location is in the subdirectory \"stream\", underneath the\r\n database directory, e.g. for a database located in c:\\abc, the default would be\r\n c:\\abc\\stream. InterSystems recommends leaving this parameter as \"\".<br>"
        }
      },
      "required":[
        "Directory",
        "Name"
      ],
      "example":{
        "ClusterMountMode":false,
        "Directory":"/usr/irissys/mgr/user/",
        "MountAtStartup":false,
        "MountRequired":false,
        "Name":"USER",
        "Server":"",
        "StreamLocation":""
      }
    },
    "ListOfDatabases":{
      "type":"object",
      "properties":{
        "Databases":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Databases"
          }
        }
      }
    },
    "Debug":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ListOfDebug":{
      "type":"object",
      "properties":{
        "Debug":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Debug"
          }
        }
      }
    },
    "DeviceSubTypes":{
      "type":"object",
      "properties":{
        "Backspace":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents the backspace character on the selected<br>\r\ndevice in this form: $C(code1). Default depends on the device type.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "CursorControl":{
          "type":"string",
          "default":"",
          "description":"Enter the cursor control keys for the selected device.<br>\r\nDefault depends on the device type.<br>"
        },
        "EraseEOF":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents erasing to the end of file on the<br>\r\nselected device in this form: $C(code1,code2...).<br>\r\nDefault depends on the device type.<br>"
        },
        "EraseEOL":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents erasing to the end of line on this device<br>\r\nin the form $C(code1,code2).<br>\r\nDefault depends on the device type.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "FormFeed":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents a form feed on the selected device in this form:<br>\r\n#,$C(code1,code2...).<br>\r\nDefault depends on the device type.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "RightMargin":{
          "type":"integer",
          "default":80,
          "description":"Enter the number that represents the location of the right margin.<br>\r\nDevice output will wrap at that number of characters.<br>\r\nDefault depends on the device type.<br>"
        },
        "ScreenLength":{
          "type":"integer",
          "default":0,
          "description":"Enter the number of lines that comprise one screen or page for the device.<br>"
        },
        "ZU22Backspace":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents a backspace on the selected device in the form $C(code).<br>\r\nDefault depends on the device type.<br>"
        },
        "ZU22FormFeed":{
          "type":"string",
          "default":"",
          "description":"Enter the ASCII code that represents a form feed on the selected device in the form $C(code1,code2).<br>\r\nDefault depends on the device type.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Backspace":"",
        "CursorControl":"",
        "EraseEOF":"",
        "EraseEOL":"",
        "FormFeed":"",
        "Name":"ZDEVSUB",
        "RightMargin":80,
        "ScreenLength":0,
        "ZU22Backspace":"",
        "ZU22FormFeed":""
      }
    },
    "ListOfDeviceSubTypes":{
      "type":"object",
      "properties":{
        "DeviceSubTypes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/DeviceSubTypes"
          }
        }
      }
    },
    "Devices":{
      "type":"object",
      "properties":{
        "Alias":{
          "type":"integer",
          "default":"",
          "description":"Alternate device ID (number) for this device. <br>\r\nAll aliases must be unique. You can use this value to specify a device in an OPEN command, e.g 0PEN 210<br>"
        },
        "AlternateDevice":{
          "type":"string",
          "default":"",
          "description":"Device ID of an alternate device.<br>\r\nThis allows a user using %IS to specify A as the device.\r\nThe alternate device must be a defined mnemonic.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Description":{
          "type":"string",
          "default":"",
          "description":"Enter a description of where the device is located. This field is for your<br>\r\nown reference to help you identify what machine you're configuring.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "OpenParameters":{
          "type":"string",
          "default":"",
          "description":"Values that will be sent as the second argument for an OPEN command.<br>\r\nThis value allows you to specify more specific terminal information.<br>"
        },
        "PhysicalDevice":{
          "type":"string",
          "default":"",
          "description":"Physical device name used to refer to the device.<br>"
        },
        "Prompt":{
          "type":"integer",
          "default":"",
          "description":"Number of the prompt option desired.<br>\r\nOptions:<br>\r\nNULL (blank) = user sees the device selection prompt with the default device defined<br>\r\n1 = automatically uses this device, if it is the current device<br>\r\n2 = automatically uses this device with predefined Right Margin and Parameter settings.<br>"
        },
        "SubType":{
          "type":"string",
          "default":"",
          "description":"Options to refine the definition of your device SubTypes.<br>\r\nSubTypes specify terminal charactistics. They are used to create the appropriate\r\nOPEN command for the device. There should be SubType information for every terminal type.<br>"
        },
        "Type":{
          "type":"string",
          "default":"",
          "description":"Enter the type of device.<br>\r\nOptions:<br>\r\nTRM = Terminal<br>\r\nSPL = Spooling device<br>\r\nMT = Magnetic Tape drive<br>\r\nBT = Cartridge tape drive<br>\r\nIPC = Interprocess communication<br>\r\nOTH = any other device including printers and sequential files.<br>\r\nDefault depends on the device type.<br>"
        }
      },
      "required":[
        "Name",
        "PhysicalDevice",
        "SubType",
        "Type"
      ],
      "example":{
        "Name":"",
        "PhysicalDevice":"",
        "SubType":"",
        "Type":""
      }
    },
    "ListOfDevices":{
      "type":"object",
      "properties":{
        "Devices":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Devices"
          }
        }
      }
    },
    "ECP":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "ClientReconnectDuration":{
          "type":"integer",
          "default":1200,
          "description":"How long a client should keep trying to re-establish a connection before giving up\r\nor declaring connection failed (in seconds).<br>"
        },
        "ClientReconnectInterval":{
          "type":"integer",
          "default":5,
          "description":"When a server is not available, how long to wait between each reconnection attempt (in seconds).<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "ServerTroubleDuration":{
          "type":"integer",
          "default":60,
          "description":"Duration a connection will stay in troubled state (in seconds).\r\nOnce this period of time has elapsed, the server will declare the connection dead and\r\npresume recovery is not possible.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Name":""
      }
    },
    "ECPServers":{
      "type":"object",
      "properties":{
        "Address":{
          "type":"string",
          "default":"",
          "description":"IP Address to connect to.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "MirrorConnection":{
          "type":"integer",
          "default":0,
          "description":"Specifies the behavior of this connection with regard to mirrored database servers.\r\n<p>\r\nValue:\r\n<li>0: Non-mirrored connection.  Access databases on non-mirror members.  Also\r\nused to connect to async members to access mirror databases, configured by\r\ntheir database paths.\r\n<li>1: Mirrored connection. ECP will automatically find the primary mirror\r\nmember and will only connect to the primary. Access to mirrored databases \r\nis configured by mirror database name.</li>\r\n<li>-1: Mirrored connection restricted to the configured mirror member only. The\r\nconfigured member is the one specified by <PROPERTY>Address</PROPERTY> and\r\n<PROPERTY>Port</PROPERTY>. Like value '1', a connection will be established \r\nif the configured member is primary and access to mirrored databases is\r\nconfigured by mirror database name. Unlike '1', if the configured member is\r\na Disaster Recovery member, the connection will be established, allowing\r\nread-only access to mirrored databases. If the DR member is promoted, the \r\nconnection will be dropped and will be re-established when it becomes primary. \r\n<b>Warning</b>: This setting is not appropriate in typical configurations where\r\n mirroring will automatically fail over, as the new primary won't be found.\r\nThis is for use in specialized DR configurations, or other long-distance\r\nconfigurations, to prevent the application server from being automatically \r\nredirected to a primary in a different data center while allowing local \r\nread-only access. There is no system utility to set the value of '-1', but it\r\ncan be specified via this class interface.</li>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Port":{
          "type":"integer",
          "default":1972,
          "description":"IP Port to connect to.<br>"
        },
        "SSLConfig":{
          "type":"integer",
          "default":0,
          "description":"Use SSL configuration (%ECPClient) for the ECP connection.<br>"
        }
      },
      "required":[
        "Address",
        "Name"
      ],
      "example":{
        "Address":"",
        "Name":""
      }
    },
    "ListOfECPServers":{
      "type":"object",
      "properties":{
        "ECPServers":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/ECPServers"
          }
        }
      }
    },
    "IO":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "File":{
          "type":"string",
          "default":"^%X364",
          "description":"Routine to use in WRITE commands for sequential files.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "MagTape":{
          "type":"string",
          "default":"^%XMAG",
          "description":"Routine to use in WRITE commands for magnetic tapes.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Other":{
          "type":"string",
          "default":"^%X364",
          "description":"Routine to use in WRITE commands for Other devices.<br>"
        },
        "Terminal":{
          "type":"string",
          "default":"^%X364",
          "description":"Routine to use in WRITE commands for terminals.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "File":"^%X364",
        "MagTape":"^%XMAG",
        "Other":"^%X364",
        "Terminal":"^%X364"
      }
    },
    "Journal":{
      "type":"object",
      "properties":{
        "AlternateDirectory":{
          "type":"string",
          "default":"",
          "description":"Alternate journal directory.<br>"
        },
        "BackupsBeforePurge":{
          "type":"integer",
          "default":2,
          "description":"Number of backups before the journal files are automatically purged.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "CurrentDirectory":{
          "type":"string",
          "default":"",
          "description":"Primary journal directory.<br>"
        },
        "DaysBeforePurge":{
          "type":"integer",
          "default":2,
          "description":"Number of days before the journal files are purged.<br>"
        },
        "FileSizeLimit":{
          "type":"integer",
          "default":1024,
          "description":"Maximum size of each journal file in MB.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "FreezeOnError":{
          "type":"boolean",
          "default":0,
          "description":"Freeze the system if there is an error writing to the journal.<br>\r\nIf this option is set to true (1), as soon as the error occurs all global activities \r\nthat are normally journaled are blocked, which causes other jobs to block. \r\nThe typical outcome is that the system goes into a hang state until the journaling problem is \r\nresolved, and then resumes running. While InterSystems IRIS is hanging, the administrator can take \r\ncorrective measures, such as freeing up space on a disk that is full, switching the journal \r\nto a new disk, etc. This option has the advantage that once the problem is fixed and \r\nInterSystems IRIS resumes running, no journal information has been lost. \r\nIt has the disadvantage that the system is less available while the problem is being solved.<br>\r\nIf this option is set to false (0), when a journaling error occurs journaling is \r\nentirely disabled, while the system continues running as normal. \r\nThe system sends a console message to alert the administrator, who can fix the problem and then\r\nrun ^JRNSWTCH at the console to restart journaling. "
        },
        "JournalFilePrefix":{
          "type":"string",
          "default":"",
          "description":"Prefixes journal file names with this string.<br>\r\nMay be used to distinguish journal files from different instances in the same directory.<br>"
        },
        "JournalcspSession":{
          "type":"boolean",
          "default":0,
          "description":"%cspSession global will be mapped to the TEMP database and not journaled.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AlternateDirectory":"/usr/irissys/mgr/journal/",
        "BackupsBeforePurge":2,
        "CurrentDirectory":"/usr/irissys/mgr/journal/",
        "DaysBeforePurge":2,
        "FileSizeLimit":1024,
        "FreezeOnError":false,
        "JournalFilePrefix":"",
        "JournalcspSession":false
      }
    },
    "LicenseServers":{
      "type":"object",
      "properties":{
        "Address":{
          "type":"string",
          "default":"127.0.0.1",
          "description":"IP Address of the license server.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "KeyDirectory":{
          "type":"string",
          "default":"",
          "description":"Directory used to load license keys for distribution. At startup of a local\r\nLicense Server, the system will attempt to load license keys from all *.key files\r\nin this directory. These keys can then be requested by other Instances using this\r\nLicense Server."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Port":{
          "type":"integer",
          "default":4002,
          "description":"IP Port of the license server.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "Address":"127.0.0.1",
        "KeyDirectory":"",
        "Port":4002
      }
    },
    "ListOfLicenseServers":{
      "type":"object",
      "properties":{
        "LicenseServers":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/LicenseServers"
          }
        }
      }
    },
    "MagTapes":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "SystemDevice":{
          "type":"string",
          "default":"",
          "description":"Physical tape device name.<br>"
        }
      },
      "required":[
        "Name",
        "SystemDevice"
      ],
      "example":{
        "Name":"54",
        "SystemDevice":"/dev/st1m"
      }
    },
    "ListOfMagTapes":{
      "type":"object",
      "properties":{
        "MagTapes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MagTapes"
          }
        }
      }
    },
    "MapGlobals":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Collation":{
          "type":"integer",
          "default":5,
          "description":"Default collation of the global"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Database":{
          "type":"string",
          "default":"",
          "description":"Database to map global to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "LockDatabase":{
          "type":"string",
          "default":"",
          "description":"Database to map global lock to.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace where the mapping is.<br>"
        }
      },
      "required":[
        "Database",
        "Name",
        "Namespace"
      ],
      "example":{
        "Collation":5,
        "Database":"ENSLIB",
        "LockDatabase":"ENSLIB",
        "Name":"EnsDICOM.Dictionary",
        "Namespace":"USER"
      }
    },
    "ListOfMapGlobals":{
      "type":"object",
      "properties":{
        "MapGlobals":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapGlobals"
          }
        }
      }
    },
    "MapMirrors":{
      "type":"object",
      "properties":{
        "AgentAddress":{
          "type":"string",
          "default":"",
          "description":"Network address (IP address preferred to avoid DNS issues)\r\nmirror members which connect to the primary should use to \r\ncontact the Agent on this failover member. This is omitted\r\nreporting members as the agent is not used for mirroring\r\non those systems. This is required on failover members. This\r\nfield does not need to be specified on DR members although it will\r\nneed to be filled in before promotion of the DR to a Failover member. \r\nIt is best to configure the agent and the address information earlier \r\nrather than later.\r\n<br><br>\r\nThe agent can transfer journal data so a private address may\r\nbe desirable here to avoid network congestion. "
        },
        "AgentPort":{
          "type":"integer",
          "default":"",
          "description":"Port # which the agent on this system is configured to listen\r\non. <classmethod>##class(SYS.Agent).GetApplicationPort()</classmethod>\r\nwill return the current value if the local agent is active."
        },
        "AsyncMemberType":{
          "type":"integer",
          "default":0,
          "description":"AsyncMemberType indicates the async member is a disaster recovery (DR), read-only reporting or read-write reporting async member.<br>\r\n0 - Disaster Recovery (DR). This is a disaster recovery async member, all its mirrored databases are read-only mirrored databases.<br>\r\n1 - Read-Only Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-only when the database is\r\ncreated.<br>\r\n2 - Read-Write Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-write when the database is\r\ncreated.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "ConnectsTo":{
          "type":"string",
          "default":"",
          "description":"Reserved for future use."
        },
        "DejournalFilter":{
          "type":"string",
          "default":"",
          "description":"The name of the filter class for mirror dejournaling, null string means the dejournal filter is disabled. <br> \r\nThis property is meaningful only for Reporting Async members. "
        },
        "ECPAddress":{
          "type":"string",
          "default":"",
          "description":"This is the superserver address referenced in the documentation for this \r\ninstance. External mirror-aware systems can connect to the primary using \r\nthis address. Currently the only such external systems are ECP application \r\nservers connecting to failover members. This is distributed to\r\nthe ECP clients, along with the address for the other failover member\r\n(if there is one) when an ECP client builds a connection to a mirror. \r\n<br><br>\r\nOther mirror members may also make connections to a member's superserver \r\naddress for certain control and monitoring purposes. When a member is primary, \r\nasync members attempt to establish their data channel to the member using this \r\naddress if the mirror private address is not accessible, which means that \r\njournal data may travel over the network via this address.\r\n<br><br>\r\nThis a required field on failover members, optional on others."
        },
        "EncryptCommunication":{
          "type":"integer",
          "default":0,
          "description":"When SSL is not required by <Property>Config.Mirrors.UseSSL</Property> mirror wide\r\nsetting, this property controls whether this member uses SSL for its outgoing\r\nconnections and/or whether it requires SSL for its incoming connections. Whenever SSL is\r\nused to encrypt a connection, the endpoints also perform authorization and verify that the\r\nDN name in the SSL configuration matches the listed <property>SSLComputerName</property>\r\nfor that system in the Mirror configuration.\r\n<br><br>\r\nValues are:\r\n<ul>\r\n <li><p>0 - Encryption is not required. Outgoing connections may still be\r\n            encrypted if the member we connect to requires SSL for incoming\r\n            connections.\r\n\t\t\t</p></li>\r\n <li><p>1 - SSL is used to encrypt outgoing connections.\r\n            the server must have an SSL Mirror configuration or the\r\n            connection will fail\r\n            </p></li>\r\n <li><p>2 - Encryption is required for incoming connections. The clients\r\n            which connect must have an SSL Mirror configuration or the\r\n            connection will fail\r\n            </p></li>\r\n <li><p>3 - Both 1+2: Outgoing connections are encrypted, encryption is\r\n            required for incoming connections\r\n            </p></li>\r\n</ol>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "GUID":{
          "type":"string",
          "default":"",
          "description":"Uniquely identifies this node in the mirror. Apart from identifying\r\nthe nodes, primary used to identify the instance that owns a particular \r\ncopy of a mirrored database."
        },
        "ID":{
          "type":"string",
          "default":"",
          "description":"ID where the mapping is.<br>"
        },
        "InstanceDirectory":{
          "type":"string",
          "default":"",
          "description":"The installation directory of the instance (the parent of the mgr directory).\r\nUsed primarily on failover members to identify the instance to the agent"
        },
        "MemberType":{
          "type":"integer",
          "default":0,
          "description":"Numeric value indicating the type of mirror member.\r\n<br><br>\r\n0 - Failover member<br>\r\n1 - &ltreserved for future use&gt<br>\r\n2 - Async member (doesn't accept client connections)<br>\r\n(defined in %syMirror.inc as FailoverMemberType, AsyncMemberType)"
        },
        "MirrorAddress":{
          "type":"string",
          "default":"",
          "description":"Address (IP preferred to avoid DNS troubles) the other mirror members\r\nshould use to contact the superserver on this instance. \r\nWhen a InterSystems IRIS instance is running as the primary failover member, \r\neach of the other mirror members uses the mirror private address to \r\nestablish its mirror data channel, the channel over which it receives \r\njournal data from the primary and the most heavily used mirror \r\ncommunication channel. \r\n<br><br>\r\nFailover members are restricted in that they can only use this address\r\nfor establishing the connection to receive live updates. Async members\r\nattempt to use this address to connect to the primary but fall back to\r\nthe superserver address (<property>ECPAddress</property> property) if necessary.\r\n<br><br>\r\nThis documentation refers to ths property as the Mirror Private Address."
        },
        "MirrorSSPort":{
          "type":"integer",
          "default":"",
          "description":"SuperServer port for this instance. Used in conjunction with both the\r\n<property>MirrorAddress</property> and the <property>ECPAddress</property>\r\nby clients establishing connections to this instance."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"This is the name of this instance in the mirror. Mirror system names\r\nmust be unique (enforced by Enterprise Manager) across all of the mirrors which \r\nthe EM manages, as an instance has a single mirror system name which \r\nmay appear in multiple mirror sets (eg. a reporting member may connect\r\nto multiple mirrors). For the most part the <property>GUID </property>\r\nis used to identify a mirror member, the Name is used for display \r\npurposes. \r\n<br><br>\r\nThe name must not contain a colon (':') and is converted to uppercase before\r\nsaving."
        },
        "SSLComputerName":{
          "type":"string",
          "default":"",
          "description":"Value of the DN field in the SSL certificate which is part of\r\nthe %Mirror SSL configuration on this instance. When SSL is enabled\r\nan instance sends this value as part of establishing a TCP connection. Both\r\nsides of the connection verify that the other side's DN value matches a value\r\nstored in the configuration. It is best for every mirror member to have a unique\r\nDN value as otherwise it may be possible for a system that was removed from the\r\nmirror to still connect if it's DN value matches the DN stored with another system\r\nof the same type (eg. async v. failover). "
        }
      },
      "required":[
        "GUID",
        "ID",
        "InstanceDirectory",
        "MirrorAddress",
        "MirrorSSPort",
        "Name"
      ],
      "example":{
        "GUID":"",
        "ID":"",
        "InstanceDirectory":"",
        "MirrorAddress":"",
        "MirrorSSPort":0,
        "Name":""
      }
    },
    "ListOfMapMirrors":{
      "type":"object",
      "properties":{
        "MapMirrors":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapMirrors"
          }
        }
      }
    },
    "MapPackages":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Database":{
          "type":"string",
          "default":"",
          "description":"Database to map Package to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace where the mapping is.<br>"
        }
      },
      "required":[
        "Database",
        "Name",
        "Namespace"
      ],
      "example":{
        "Database":"ENSLIB",
        "Name":"EnsLib",
        "Namespace":"USER"
      }
    },
    "ListOfMapPackages":{
      "type":"object",
      "properties":{
        "MapPackages":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapPackages"
          }
        }
      }
    },
    "MapRoutines":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Database":{
          "type":"string",
          "default":"",
          "description":"Database to map routine to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        },
        "Namespace":{
          "type":"string",
          "default":"",
          "description":"Namespace where the mapping is.<br>"
        }
      },
      "required":[
        "Database",
        "Name",
        "Namespace"
      ],
      "example":{
        "Database":"ENSLIB",
        "Name":"Ens*",
        "Namespace":"USER"
      }
    },
    "ListOfMapRoutines":{
      "type":"object",
      "properties":{
        "MapRoutines":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapRoutines"
          }
        }
      }
    },
    "MapShadows":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Directory":{
          "type":"string",
          "default":"",
          "description":"Database to map global to.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<var>Bit $$$CPFSave</var> - Save object to disk.<br>\r\n<var>Bit $$$CPFWrite</var> - Write CPF file from object.<br>\r\n<var>Bit $$$CPFActivate</var> - Activate object into memory if CPFFile is the same as what is currently active.<br>"
        },
        "ID":{
          "type":"string",
          "default":"",
          "description":"ID where the mapping is.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the mapping.<br>"
        }
      },
      "required":[
        "Directory",
        "ID",
        "Name"
      ],
      "example":{
        "Directory":"",
        "ID":"",
        "Name":""
      }
    },
    "ListOfMapShadows":{
      "type":"object",
      "properties":{
        "MapShadows":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/MapShadows"
          }
        }
      }
    },
    "MirrorMember":{
      "type":"object",
      "properties":{
        "AgentAddress":{
          "type":"string",
          "default":"",
          "description":""
        },
        "AsyncMemberGUID":{
          "type":"string",
          "default":"",
          "description":""
        },
        "AsyncMemberType":{
          "type":"integer",
          "default":0,
          "description":"AsyncMemberType indicates the async member is a disaster recovery (DR), read-only reporting or read-write reporting async member.<br>\r\n0 - Disaster Recovery (DR). This is a disaster recovery async member, all its mirrored databases are read-only mirrored databases.<br>\r\n1 - Read-Only Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-only when the database is\r\ncreated.<br>\r\n2 - Read-Write Reporting. This is a reporting async member, all its mirrored databases could be read-only or read-write databases, the default is read-write when the database is\r\ncreated.<br>"
        },
        "AsyncUseSystemPurgeInterval":{
          "type":"boolean",
          "default":0,
          "description":"AsyncUseSystemPurgeInterval when set indicates that the async member should\r\npurge mirror journal files according to the same criteria it uses for purging\r\nlocal journal files (eg. after a certain number of days or a certain number\r\nof backups). When this parameter is missing, or clear, the default state, mirror\r\njournal files are purged as soon as they are no longer needed because they\r\nhave been replayed to the local databases and/or sent on to the various clients\r\nthat connect (if this is a relay member)."
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "JoinMirror":{
          "type":"boolean",
          "default":0,
          "description":"Flag indicating whether this system processes its mirror configuration\r\nat startup. When set to NO, the mirror configuration is ignored and the\r\nsystem is not considered a mirror member. This can be used if there is a \r\nproblem in the configuration which prevents the system from starting or\r\nas part of removing a system from the mirror as if a system is the primary\r\nit needs to be restarted but we also need to block the system from joining\r\nthe mirror when it restarts and becoming the primary again."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "SystemName":{
          "type":"string",
          "default":"",
          "description":"This is the name by which the system is known in the mirror (the mirror \r\nmember name). The name is converted to uppercase before storing. \r\nThe following characters are not permitted in mirror system names:\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: # , ; = ^ ~ \" &ltspace&gt &lttab&gt \r\n<br>\r\nThe following character sequences are not allowed in mirror system names:\r\n<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;/*  \r\n<br>\r\n\r\nMirror system names must be unique across all\r\nmirror members as some mirror members (eg. relay and async members) may\r\nparticipate in multiple mirrors and they will have the same system name\r\nin all of the mirrors."
        },
        "VirtualAddressInterface":{
          "type":"string",
          "default":"",
          "description":"When the mirror is configured to keep a virtual ip address assigned\r\nto the primary, this is the local interface which hosts the IP address.<br><br>\r\nConsult the documentation for the format specific to the operating system.<br><br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AgentAddress":"",
        "AsyncMemberGUID":"",
        "AsyncMemberType":0,
        "AsyncUseSystemPurgeInterval":false,
        "JoinMirror":false,
        "SystemName":"",
        "VirtualAddressInterface":""
      }
    },
    "Mirrors":{
      "type":"object",
      "properties":{
        "AllowParallelDejournaling":{
          "type":"integer",
          "default":0,
          "description":"Determines the type of mirror members can run parallel dejournaling updaters.\r\n<br>\r\n0 - Failover and Disaster Recover members.<br>\r\n1 - Failover members only.<br>\r\n2 - All members including Failover, Disaster Recovery and Reporting Async members.<br>\r\n<br>"
        },
        "ArbiterNode":{
          "type":"string",
          "default":"",
          "description":"An address for the arbiter node used by this mirror.<br>\r\nThe arbiter node is used by the failover members as an observer to provide\r\ninformation to an active backup that allows it to take over when the agent\r\non the primary cannot be contacted (eg. the primary loses power).<br><br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "CompressionForAsyncMembers":{
          "type":"integer",
          "default":0,
          "description":"Determines whether journal data is compressed before being transmitted to async members (disaster recovery and reporting).\r\n<br>\r\n0 - System Selected: The system will use a compression strategy expected to balance network utilization with performance.<br>\r\n1 - Uncompressed: No compression will be used.<br>\r\n2 - Compressed: Compression will be used.<br>\r\n<br>"
        },
        "CompressionForFailoverMembers":{
          "type":"integer",
          "default":0,
          "description":"Determines whether journal data is compressed before being transmitted between failover members.\r\n<br>\r\n0 - System Selected: The system will use compression only in configurations where it is expected to improve the response time for synchronization between the primary and backup.<br>\r\n1 - Uncompressed: No compression will be used.<br>\r\n2 - Compressed: Compression will be used.<br>\r\n<br>"
        },
        "CompressionTypeForAsyncMembers":{
          "type":"integer",
          "default":0,
          "description":"Compress type when CompressionForAsyncMembers is set to 'Compressed' mode. It is meanlinless if CompressionForAsyncMembers is not 'Compressed' mode.\r\n<br>\r\n0 - ZLIB.<br>\r\n1 - ZSTD.<br>\r\n2 - LZ4.<br>\r\n<br>"
        },
        "CompressionTypeForFailoverMembers":{
          "type":"integer",
          "default":0,
          "description":"Compress type when CompressionForFailoverMembers is set to 'Compressed' mode. It is meanlinless if CompressionForFailoverMembers is not 'Compressed' mode.\r\n<br>\r\n0 - ZLIB.<br>\r\n1 - ZSTD.<br>\r\n2 - LZ4.<br>\r\n<br>"
        },
        "DefinedPrimary":{
          "type":"string",
          "default":"",
          "description":"Field used internally when mirror failover is disabled, \r\ngenerally for maintenance purposes. Manipulated via the nofailover options\r\nwhen shutting down InterSystems IRIS. This contains the mirror system name of the node\r\nwhich is allowed to become the primary. It is cleared automatically when that\r\nnode starts up and becomes the primary (eg. starting it NOSTU will not clear\r\nthis field). This can also be set and cleared manually via ^MIRROR."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "GUID":{
          "type":"string",
          "default":"",
          "description":"Internal GUID which is unique to this mirror"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Mirror names are uppercase (alphanumeric)\r\nName of the mirror, restricted to 15 uppercase alphanumeric characters. \r\nMust be unique across the mirrors managed by the EMS"
        },
        "QOSTimeout":{
          "type":"integer",
          "default":8000,
          "description":"Contains the time in milliseconds which the primary will wait for the backup\r\nto acknowledge receipt of a chunk of journal data before the primary\r\nmarks the backup as inactive."
        },
        "UseSSL":{
          "type":"boolean",
          "default":0,
          "description":"Yes/No field for whether the mirror uses to encrypt the communication \r\nbetween members for every mirror connection. \r\nWhen set to Yes the Mirror SSL configuration is used for client/server connections by this\r\nnode. When set to No, encryption setting are controlled on a per-connection basis via\r\n<property>Config.MapMirrors.EncryptCommunication</property> and by\r\n<property>Config.MapMirrors.RequireEncryption MapMirrors</property>.\r\n<br><br>\r\nSetting this field to Yes forces <property>RequireAuthentication</property> to be set to \r\nYes and <property>RequireAuthentication</property> cannot be set to No while this field is\r\nenabled.\r\n<br><br>\r\nThis must be enabled when journal files are encrypted on the \r\nfailover mirror members or when there are any encrypted mirrored databases."
        },
        "VirtualAddress":{
          "type":"string",
          "default":"",
          "description":"Optional Virtual IP address which the mirror maintains pointing to the\r\ncurrent primary. When this is specified the failover members must be\r\nconfigured to host the Virtual IP on one of their interfaces. This is used\r\nby TCP/IP Client applications to connect to the primary mirror member."
        }
      },
      "required":[
        "GUID",
        "Name"
      ],
      "example":{
        "GUID":"",
        "Name":""
      }
    },
    "ListOfMirrors":{
      "type":"object",
      "properties":{
        "Mirrors":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Mirrors"
          }
        }
      }
    },
    "Miscellaneous":{
      "type":"object",
      "properties":{
        "AsyncDisconnectErr":{
          "type":"boolean",
          "default":0,
          "description":"This setting modifies the behavior of InterSystems IRIS when DisconnectErr is enabled.<br>\r\n0 - The process receives a <DSCON> error at the next read or write command.<br>\r\n1 - The process receives an asynchronous <DSCON> error at the time a disconnect occurs on the device. This error will occur at the next command executed. Hang commands will be interrupted. <br>\r\nAsyncDisconnectError is only applicable to Telnet connections on Windows. It has no effect on any other device type or operating system. If DisconnectErr is set to 0 (false), then AsyncDisconnectError has no effect. "
        },
        "AsynchError":{
          "type":"boolean",
          "default":1,
          "description":"Enable processes to receive asynchronous errors.<br>\r\n0 - Processes cannot receive asynchronous errors.<br>\r\n1 - Processes can receive asynchronous errors.<br>\r\nThis setting applies to ECP networking. "
        },
        "BreakMode":{
          "type":"boolean",
          "default":1,
          "description":"Process action when debug BREAK command executed.<br>\r\n0 - Breaks are ignored.<br>\r\n1 - Breaks are taken.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "CollectResourceStats":{
          "type":"boolean",
          "default":0,
          "description":"Controls whether the system resource statistics are updated or not (seize, nseize, \r\naseize, bseize).<br>\r\n0 - Statistics are not collected<br>\r\n1 - Statistics are collected.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DX":{
          "type":"boolean",
          "default":0,
          "description":"Sets $X update mode for escape sequences system-wide.<br>\r\nYou can control the way the system updates $X when writing a string containing an escape sequence. \r\nDefault behaviors for various system implementations are as follows: <br>\r\nUNIX - parses the ANSI standard escape sequence and counts the rest of the non-escape \r\ncharacters in the string against $X. <br>\r\nVMS - Do not count any more characters in the string against $X as soon as they encounter an \r\nescape character ($CHAR(27)). <br>\r\nOpen M [DSM] - Counts all characters in a string, including the escape character, against $X.<br>\r\nOpen M [DTM] and Open M [MSM] - Count all characters except for the escape character against $X.<br>\r\nA numeric code that controls a nondefault, consistent, system-wide way of updating $X.<br>\r\n0 - Use UNIX default behavior on system. <br>\r\n1 = Use Open M [DSM] default behavior on system.<br> \r\n2 = Use Open M [DTM]/Open M [MSM] default behavior on system.<br> \r\n3 = Use OpenVMS Alpha default behavior on system. <br>\r\nThe default behavior on UNIX zero (0).<br> \r\nThe default behavior on VMS is three (3).<br>"
        },
        "DisconnectErr":{
          "type":"boolean",
          "default":0,
          "description":"Enable a process to receive disconnect errors.<br>\r\nThis setting conditions how a process responds to a disconnect of the principal \r\nI/O device. <br>\r\nBe aware that when error on disconnect is enabled, a process continues to execute after \r\nits principal device has been disconnected. It is the responsibility of the application to \r\ndetect the disconnect condition and exit gracefully. Use care when enabling error on disconnect. \r\nThe application must be prepared to recognize the <DSCON> error and handle it appropriately \r\nin error traps. Error on disconnect is only applicable to TCP devices and to terminal devices \r\nwhere a disconnect can be recognized. Examples are modem controlled terminals and Windows \r\nTelnet, Windows LAT, and Windows local cterm (TRM:) connections. Error on disconnect is only \r\napplicable to the principal device.\r\n0 - Process exits without reporting an error to the application when a disconnect is detected.<br>\r\n1 - Process receives a <DSCON> error when a disconnect is detected during a Write or Read command.<br>"
        },
        "FileMode":{
          "type":"boolean",
          "default":0,
          "description":"Create a file if it does not exist when called with Write or Read/Write.<br>\r\nWhen 0 (false) and a file is opened for writing that does not exist, a new file is not created \r\nunless the N parameter was provided with the OPEN command.<br>\r\nWhen 1 (true) and a file is opened for writing that does not exist, a new file is created.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "GlobalKillEnabled":{
          "type":"boolean",
          "default":1,
          "description":"Enable KILL of an unsubscripted global.<br>\r\n0 - KILL of an unsubscripted global results in a <PROTECT> error.\r\n1 - KILL of an unsubscripted global is allowed, so you can kill all subscripts of a global with a single kill instead if killing them individually. "
        },
        "IEEEError":{
          "type":"boolean",
          "default":1,
          "description":"Enables or disables $DOUBLE returning INF and NAN values system-wide.<br>\r\nThis property sets the $DOUBLE function return value behavior system-wide. \r\nIf 0, $DOUBLE returns INF (infinity), -INF, and NAN (Not A Number) for unresolvable IEEE \r\nfloating point conversions. If 1, $DOUBLE generates ObjectScript errors for unresolvable IEEE \r\nfloating point conversions. The property controls the issuing of INF, -INF, and NAN when \r\na $DOUBLE numeric operation cannot be resolved to a numeric value. It does not control\r\nthe issuing of INF, -INF, and NAN in all cases. $DOUBLE always returns INF, -INF, or \r\nNAN when you supply one of these strings as the input value, regardless of this property.\r\nMathematical operations on $DOUBLE numbers that result in an INF, -INF, or NAN are controlled \r\nby this property. These include arithmetic operations, exponentiation, and logarithmic and \r\ntrigonometric functions. <br>\r\n0 - $DOUBLE returns INF, -INF, or NAN when given an unresolvable numeric expression. <br>\r\n1 - $DOUBLE generates <MAXNUMBER>, <ILLEGAL VALUE>, and <DIVIDE> errors when given an unresolvable numeric expression."
        },
        "LineRecall":{
          "type":"boolean",
          "default":1,
          "description":"Enable command line recall for READ commands. <br>\r\nRead line recall is only used by terminal devices.<br>\r\nThe OPEN command sets the read line recall mode for a terminal. You can specify the \r\nR protocol (enable) or the N protocol (disable). If neither protocol is specified, \r\nOPEN takes its setting from the current default established by %SYS.ProcessQuery.LineRecall,\r\nthis property. The USE command can specify the R protocol (enable) or the N protocol (disable) \r\nto change the OPEN mode. If neither protocol is specified, USE takes its setting from the \r\ninitial OPEN mode value.\r\nAn implicit open of an active device, such as issuing a BREAK command, reopens the device \r\nin the same mode as the initial OPEN command. \r\nModifying this property does not override an OPEN or USE setting for an active terminal. \r\nTo change read line recall for an already open terminal device, you must explicitly reopen \r\nthe device. You can use this property  or %SYS.ProcessQuery.LineRecall to change the default, \r\nthen issue an OPEN 0 command, which reopens the active terminal device, applying the current \r\ndefault. See Terminal I/O in InterSystems IRIS I/O Device Guide for details on using protocols. <br><br>\r\nRead Line Recall<br>\r\nRead line recall mode provides line recall of editable lines as input for READ operations \r\nfrom a terminal. These recallable lines include both previous READ input lines and previous \r\ncommand lines. Echoing of input lines is a necessary precondition for read line recall. \r\nThe system supports read line recall for both variable-length terminal reads (READ var) \r\nand fixed-length terminal reads (READ var#n). The system does not support read line recall \r\nfor single-character terminal reads (READ *var). For a fixed-length terminal read, the \r\nrecalled line is truncated to one character less than the number of characters specified in \r\nthe READ. This final READ character position is reserved for typing a line termination \r\ncharacter, specifying an edit character, or adding one more data character. \r\nWhen read line recall is active, you can provide input to a READ by using the Up Arrow and \r\nDown Arrow keys to recall a previous terminal input line. You can then use the Left Arrow,\r\nRight Arrow, Home, and End keys to position the cursor for editing the recalled line. \r\nYou can use the Backspace key to delete a character, Ctrl-X to delete the entire line, \r\nor Ctrl-U to delete all of the line to the left of the cursor. \r\nWhen read line recall is not active, the four Arrow keys, the Home key, and the End key \r\nall issue a line termination character. You can use the Backspace key to delete a single \r\ninput character, and Ctrl-X (or Ctrl-U) to delete the entire input line. Read line recall \r\ncan be deactivated by using the -R protocol, or by specifying the N, I, S, or T protocols, \r\nas described in the Terminal I/O chapter of the InterSystems IRIS I/O Device Guide. <br><br>\r\n0 - Command line recall is not enabled.<br>\r\n1 - Command line recall is enabled.<br>"
        },
        "ListFormat":{
          "type":"integer",
          "default":0,
          "description":"Enable compression of some $LIST types.<br>\r\nThe value is bit flags controlling these types:<br>\r\n1 - Compress IEEE floating point values ($DOUBLE)<br>\r\n2 - Compress Unicode strings"
        },
        "LogRollback":{
          "type":"boolean",
          "default":0,
          "description":"Enable logging for transaction rollbacks.<br>\r\n0 - Do not log transaction rollbacks.<br>\r\n1 - Log transaction rollbacks to the console log file.<br>"
        },
        "MVDefined":{
          "type":"boolean",
          "default":0,
          "description":"Sets MVBasic handling of undefined variables system-wide.<br>\r\nThis property function defines MVBasic behavior when it encounters a reference to an \r\nundefined variable. By default, if an MVBasic routine references an undefined variable, \r\nThe system generates an <UNDEFINED> error. You can change this default behavior to have \r\nthe system substitute an empty string for an undefined variable, without signaling an error.<br> \r\n0 - issue an <UNDEFINED> error for an undefined variable.<br>\r\n1 - substitute the empty string for an undefined variable.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "NodeNameInPid":{
          "type":"boolean",
          "default":0,
          "description":"Behavior when there is a reference to the special variable $JOB. <br>\r\n0 - $JOB returns only the process ID number. \r\n1 - $JOB returns the process ID number of the current process, concatenated to the nodename."
        },
        "NullSubscripts":{
          "type":"boolean",
          "default":0,
          "description":"Enable null subscript references.<br>\r\n0 - Throw <SUBSCRIPT> error when referencing a null subscript.<br>\r\n1 - Null subscript references do not throw an error.<br>"
        },
        "OldZU5":{
          "type":"boolean",
          "default":0,
          "description":"When switching namespace to the same namespace via $namespace or ZN, clear global vectors.<br>\r\n0 - Switching to the same namespace is a NOOP.<br>\r\n1 - Switching to the same namespace clears the globals vector cache.<br>"
        },
        "OpenMode":{
          "type":"integer",
          "default":0,
          "description":"The read/write mode you want used when opening sequential files and no mode is specified in the OPEN command.<br>\r\n0 - Read<br>\r\n1 - Read-Write<br>"
        },
        "PopError":{
          "type":"boolean",
          "default":0,
          "description":"When to pop $ZTRAP error handlers off the stack.<br><br>\r\nWhen a $ZTRAP error handler is invoked by the system, that error handler remains on the stack of\r\nestablished error handlers. Therefore, if an error occurs when the error handler is executing,\r\nthat error handler attempts to invoke itself, receives the same error again and enters an\r\ninfinite loop, unless that error handler explicitly sets $ZTRAP to a new value.<br>\r\nWhen a $ZTRAP error handler is invoked in DSM, the error handler is removed from the stack. \r\nTherefore, if an error occurs while the error handler is executing, that error is handled \r\nby the previous error handler on the stack.<br><br>\r\n0 - Normal behavior: A $ZTRAP error handler stays active when the error handler is invoked.<br>\r\n1 - Pop the $ZTRAP error handler off the stack when an error is triggered (DSM compatibility mode). <br>"
        },
        "RefInKind":{
          "type":"boolean",
          "default":0,
          "description":"Result of $NAME and $QUERY when an extended global reference is the argument.<br>\r\n0 - Return the global with an extended reference. <br>\r\n1 - Return the global without reference to where it is on the network. <br>"
        },
        "ScientificNotation":{
          "type":"boolean",
          "default":1,
          "description":"Enables or disables lowercase \"e\" as scientific notation symbol system-wide.<br>\r\n0 - Disable lowercase \"e\".<br>\r\n1 - Enable lowercase \"e\".<br>"
        },
        "SetZEOF":{
          "type":"boolean",
          "default":0,
          "description":"Behavior when the system encounters an unexpected end-of-file when reading a sequential file.<br>\r\n0 - Throw an <ENDOFFILE> error.<br>\r\n1 - Set the special variable $ZEOF to indicate that you have reached the end of the file. <br>"
        },
        "ShutDownLogErrors":{
          "type":"boolean",
          "default":0,
          "description":"Write ^SYSLOG errors to the console log file at shutdown.<br>\r\n0 - Do not write ^SYSLOG errors.<br>\r\n1 - Write ^SYSLOG errors.<br>"
        },
        "StopID":{
          "type":"boolean",
          "default":0,
          "description":"Sets $ZF process deletion behavior for OpenVMS STOP/ID system-wide.<br>\r\nUsing the OpenVMS STOP/ID command to delete a process can cause your \r\nsystem to fail. For this reason, the system on OpenVMS systems prevent you \r\nfrom deleting processes with STOP/ID.\r\nFor processes that are executing $ZF functions, you may need to be able to delete \r\na process from OpenVMS. Set this value to 0 if you need to terminate processes in a $ZF function.<br>\r\n0 - Enable deletion of processes with STOP/ID.<br>\r\n1 - Disable deletion of processes with STOP/ID.<br>"
        },
        "SwitchOSdir":{
          "type":"boolean",
          "default":0,
          "description":"Behavior of the current working O/S directory when changing namespaces.<br>\r\n0 - When you change namespaces, the current working directory is changed to the directory of the default database of the new namespace. However, if this dataset is remote (networked to a different system), the current working directory is left unchanged.<br>\r\n1 - When you change namespaces, the current working directory remains unaltered no matter what namespace you switch to.<br>"
        },
        "SynchCommit":{
          "type":"boolean",
          "default":0,
          "description":"Synchronize TCOMMIT with the corresponding journal write operation.<br>\r\n0 - TCOMMIT does not wait for the write operation to complete. <br>\r\n1 - TCOMMIT does not complete until the journal data write operation completes. Note that setting this\r\nproperty to 1 will have performance implications.<br>"
        },
        "TelnetNUL":{
          "type":"boolean",
          "default":0,
          "description":"Suppress Telnet NUL at end-of-line system-wide.<br>\r\nThis property disables or enables the issuance of a NUL character (ASCII 0) following a CR \r\ncharacter (ASCII 13) at end-of-line during Telnet transmission on Windows systems only. It has\r\nno affect of Unix or VMS systems. On output, a Telnet network virtual terminal (NVT) \r\nperforms the following default end-of-line behavior: either issues a CR \r\n(carriage return character) followed by a LF (linefeed character), or issues a CR \r\n(carriage return character) followed by a NUL character (if no LF is issued). <br>\r\n0 - do not suppress NUL. <br>\r\n1 - suppress NUL. <br>"
        },
        "TruncateOverflow":{
          "type":"boolean",
          "default":0,
          "description":"Enable the <MAXNUMBER> error on numeric overflow.<br>\r\nWhen the system encounters a number larger than 9223372036854775807 E127 (or smaller than -9223372036854775808 E127) it throws the <MAXNUMBER> error. <br>\r\n0 - <MAXNUMBER> error is thrown.<br> \r\n1 - <MAXNUMBER> error is suppressed.<br> "
        },
        "Undefined":{
          "type":"integer",
          "default":0,
          "description":"ObjectScript response to undefined variables.<br>\r\n0 - Always throw an <UNDEFINED> error.<br>\r\n1 - If the undefined variable has subscripts, return a null string, but if the undefined variable is single-valued, throw an <UNDEFINED> error.<br>\r\n2 - Always return a null string.<br>"
        },
        "UseNagleAlgorithm":{
          "type":"boolean",
          "default":0,
          "description":"Enable the Nagle algorithm for Telnet (Windows only).<br>\r\n0 - Nagle algorithm is disabled.<br>\r\n1 - Nagle algorithm is enabled.<br>"
        },
        "ViewPastData":{
          "type":"boolean",
          "default":0,
          "description":"Enable $VIEW command to examine data outside of the InterSystems IRIS memory area.<br>\r\n0 - $VIEW command throws an error.<br>\r\n1 - $view command does not throw an error.<br>"
        },
        "ZDateNull":{
          "type":"boolean",
          "default":0,
          "description":"$ZDATE response to an invalid value. <br>\r\n0 - The valid range is from 0 through 2980013, inclusive, which corresponds to dates from \r\n12/31/1840 through 12/31/9999. This range can be restricted by setting the $ZDATE mindate \r\nand maxdate parameters. If the date is invalid, the error message <ILLEGAL VALUE> or \r\n<VALUE OUT OF RANGE> will be generated. The behavior can be overridden by supplying an \r\nerropt to the $ZDATE call. <br>\r\n1 - (ISM compatibility) The valid range is from 1 through 94232, inclusive, which corresponds to dates from 01/01/1841 \r\nthrough 12/30/2098. This date range is set for any $ZDATE function call which has three or \r\nfewer parameters. If a $ZDATE function call has more than three parameters, the valid date \r\nrange is taken either from the $ZDATE mindate and maxdate parameters (if specified) or \r\nfrom the date range established for the current locale. If the date is invalid, \r\n$ZDATE will return the null string if you submit an invalid date. This behavior is set for \r\nany $ZDATE function call, regardless of the number of parameters. "
        },
        "ZaMode":{
          "type":"boolean",
          "default":0,
          "description":"Determines how the ZALLOCATE (ZA) and ZDEALLOCATE (ZD) commands behave, according to InterSystems IRIS rules or DSM-11 rules.<br>\r\n0 - InterSystems IRIS rules, which means that ZA and ZD behave exactly like LOCK + and LOCK -.<br>\r\n1 - DSM-11 rules, which means that ZA locks can only be unlocked by ZD and LOCK + locks can only be unlocked by LOCK.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "AsyncDisconnectErr":false,
        "AsynchError":true,
        "BreakMode":true,
        "CollectResourceStats":false,
        "DisconnectErr":false,
        "FileMode":false,
        "GlobalKillEnabled":true,
        "IEEEError":true,
        "LineRecall":true,
        "ListFormat":0,
        "LogRollback":false,
        "MVDefined":false,
        "NodeNameInPid":false,
        "NullSubscripts":false,
        "OldZU5":false,
        "OpenMode":0,
        "PopError":false,
        "RefInKind":false,
        "ScientificNotation":true,
        "SetZEOF":false,
        "ShutDownLogErrors":false,
        "StopID":false,
        "SwitchOSdir":false,
        "SynchCommit":false,
        "TelnetNUL":false,
        "TruncateOverflow":false,
        "Undefined":0,
        "UseNagleAlgorithm":false,
        "ViewPastData":false,
        "ZDateNull":false,
        "ZaMode":false
      }
    },
    "Monitor":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "PatrolCollectionInterval":{
          "type":"integer",
          "default":30,
          "description":"** DEPRECATED - No longer Supported. **\r\nEnter the number of seconds between each time the system collects data and sends it to Patrol.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "PatrolDisplayMode":{
          "type":"integer",
          "default":0,
          "description":"** DEPRECATED - No longer Supported. **\r\nControl how the metric data is displayed in the Patrol console.<br>\r\n0 - 'Total' displays the total counts since the collection was started.<br>\r\n1 - 'Delta' displays the count for the last collection period.<br>\r\n2 - 'Rate' displays a calculated count per second.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "PatrolEnabled":{
          "type":"boolean",
          "default":0,
          "description":"** DEPRECATED - No longer Supported. **\r\nAautomatically starts the connection to Patrol when the system is started.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "PatrolTopProcesses":{
          "type":"integer",
          "default":20,
          "description":"** DEPRECATED - No longer Supported. **\r\nNumber of processes to be displayed in the Process Status window on the Patrol console.<br>\r\nThis will show the top processes as sorted by global or routine.<br>\r\nA value of 0 tells the PATROL utility to stop calculating the top processes.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "SNMPEnabled":{
          "type":"boolean",
          "default":0,
          "description":"Automatically starts the SNMP agent when the system is started.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "WMIEnabled":{
          "type":"boolean",
          "default":0,
          "description":"** DEPRECATED - No longer Supported. **\r\nIdentifies this configuration as one that should be monitored by the WMI DLL.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "PatrolCollectionInterval":30,
        "PatrolDisplayMode":0,
        "PatrolEnabled":false,
        "PatrolTopProcesses":20,
        "SNMPEnabled":false,
        "WMIEnabled":false
      }
    },
    "Namespaces":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Globals":{
          "type":"string",
          "default":"",
          "description":"Default database for globals.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Routines":{
          "type":"string",
          "default":"",
          "description":"Default database for routines.<br>"
        },
        "TempGlobals":{
          "type":"string",
          "default":"IRISTEMP",
          "description":"Default database for temporary globals.<br>"
        }
      },
      "required":[
        "Globals",
        "Name",
        "Routines"
      ],
      "example":{
        "Globals":"USER",
        "Name":"USER",
        "Routines":"USER",
        "TempGlobals":"IRISTEMP"
      }
    },
    "ListOfNamespaces":{
      "type":"object",
      "properties":{
        "Namespaces":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Namespaces"
          }
        }
      }
    },
    "SQL":{
      "type":"object",
      "properties":{
        "ANSIPrecedence":{
          "type":"boolean",
          "default":1,
          "description":"Apply SQL92 operator precedence if this flag is set<br>"
        },
        "AllowRowIDUpdate":{
          "type":"boolean",
          "default":0,
          "description":"1 - The table compiler omits the checks to see if the RowID field(s) are being updated.<br>\r\n0 - The checks are performed."
        },
        "AutoParallel":{
          "type":"boolean",
          "default":1,
          "description":"Enable auto hinting for %PARALLEL<br>"
        },
        "AutoParallelThreshold":{
          "type":"integer",
          "default":3200,
          "description":"The threshold for auto hinting for %PARALLEL, the lower the value is, the higher the chance this query would be paralleded executed<br>"
        },
        "BiasQueriesAsOutlier":{
          "type":"boolean",
          "default":0,
          "description":"Set to 1 if queries on fields with non-null outliers often refer to the outlier.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comment":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if embedded SQL statements are retained as comments in the .INT code version of the routine.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DBMSSecurity":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if SQL security is enabled. If SQL security is ON, all SQL security is active. This means: Each user must specify a valid username and password when logging in through ODBC (or by setting the %msql variable directly); Privilege-based table/view security is active, and the user may only perform actions on a table or view they have been granted access to. If SQL Security is off: Any user may access SQL through ODBC, and may be prompted for a username/password but will not be validated; Privilege-based table/view security is suppressed, and user's may perform actions on tables and views to which they have not been given access.<br>"
        },
        "DDLDefineBitmapExtent":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement defines a bitmap extent index for the class.\r\nThis setting only applies to classes created through DDL that do not also define an explicit IdKey index.\r\nDDLDefineBitmapExtent=0 means a bitmap extent index will not be defined.\r\nDDLDefineBitmapExtent=1 means a bitmap extent index will be defined, if possible."
        },
        "DDLFinal":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement is Final.<br>\r\nDDLFinal=0 means the class created by the statement will not be defined as Final<br>\r\nDDLFinal=1 means the class created by the statement will be defined as Final.<br>"
        },
        "DDLNo201":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -201 error is returned when an attempt is made to CREATE a previously existing table through DDL.<br>"
        },
        "DDLNo30":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -30 error is returned when an attempt is made to DROP a non-existing table through DDL.<br>"
        },
        "DDLNo307":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -307 error is returned when an attempt is made to a primary key constraint to a table through DDL, when a primary key constraint already exists for that table.<br>"
        },
        "DDLNo311":{
          "type":"boolean",
          "default":0,
          "description":"Setting this parameter to 'Yes' allows you to ADD a foreign key through DDL even if one with the same name already exists. Setting this parameter to 'No' disallows this action and returns an error code.<br>"
        },
        "DDLNo315":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -315 error is returned when an attempt is made to DROP a non-existant constraint through DDL.<br>"
        },
        "DDLNo324":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -324 error is returned when an attempt is made to CREATE a previously existing index through DDL.<br>"
        },
        "DDLNo333":{
          "type":"boolean",
          "default":0,
          "description":"Set the flag that determines if an SQLCODE -333 error is returned when an attempt is made to drop a non-existant index through DDL.<br>"
        },
        "DDLSQLOnlyCompile":{
          "type":"boolean",
          "default":0,
          "description":"1 - any class compilation performed as a result of executing a DDL statement will compile the class with the \"q\" (sqlonly) flag.<br>\r\n0 - the \"q\" flag is not used. This is the default."
        },
        "DDLUseExtentSet":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement defines the USEEXTENTSET class parameter to a value of 1.\r\nUSEEXTENTSET=1 will generally bind the table to better improving global names, especially the index globals.  It does mean the global names the class is mapped to is not a name that attempts to match the classname.\r\nSee documentation for USEEXTENTSET parameter for more information."
        },
        "DDLUseSequence":{
          "type":"boolean",
          "default":1,
          "description":"Sets the flag which determines if a class created by a DDL CREATE TABLE statement uses $Sequence for ID assignment.\r\nThe storage keyword IDFUNCTION can be defined as INCREMENT or SEQUENCE. This keyword value is used by the class compiler to determine \r\nwhich system function - $increment or $sequence - is to be used for assigning new ID values for a persistent class using default storage.\r\nThe default value for IDFUNCTION is INCREMENT, however the default behavior for classes defined through DDL is to define IDFUNCTION as SEQUENCE.\r\nTo configure the system to have classes created through DDL to define IDFUNCTION as INCREMENT, define DDLUseSequence=0.\r\nTo configure the system to have classes created through DDL to define IDFUNCTION as SEQUENCE, define DDLUseSequence=1."
        },
        "DefaultSchema":{
          "type":"string",
          "default":"SQLUser",
          "description":"This setting provides the ability to define a default schema name other than SQLUser, the default. When an unqualified table name is encountered in an SQL statement (and there is no #import statement specified), the default schema will be used.  You may specify _CURRENT_USER for the default schema name if you wish to use the SQL username the process logged in as the name of the default schema. If the process has not logged in to SQL, SQLUser will be used as the default schema name.  You may also specify _CURRENT_USER/<default name>.  In this case, if the process has not logged in to SQL, <default name> will be used as the default schema name.  For example:  _CURRENT_USER/HMO will use HMO as the default schema if the process has not logged in to SQL.  This setting has nothing to do with the mappings between SQL schema names and the class package name, it only specifies the default schema.<br>"
        },
        "DelimitedIds":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if double quotes (\") in an SQL statement are used for delimited (quoted) identifiers or string constants.  If \"Yes\", a double quoted string (\"My String\") will be considered an identifier within an SQL statement.  If \"No\", a double quoted string (\"My String\") will be considered a string literal within an SQL statement.<br>"
        },
        "DropDelete":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines whether a DDL DROP TABLE statement deletes the table's data.<br>"
        },
        "ECPSync":{
          "type":"boolean",
          "default":0,
          "description":"When an SQL Select statement is executed, forces all pending ECP requests to the DB-server.\r\nOn completion it guarantees that the client cache is in sync."
        },
        "ExtrinsicFunctions":{
          "type":"boolean",
          "default":0,
          "description":"Allows/disallows extrinsic functions to be used in SQL statements through ODBC, JDBC, and Dynamic Query.<br>"
        },
        "FastDistinct":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines if SQL DISTINCT optimization is turned on.  If true (the default) many SQL queries involving DISTINCT (and GROUP BY) \r\n\twill run much more efficiently by making better use of indices (if available). \r\n\tThe downside of this is that the values returned by such queries will be collated \r\n\tin the same way they are stored within the index (i.e., results may be in upper case). \r\n\tSome applications care about the case of values returned by such queries. \r\n\tIf \"Fast DISTINCT\" is set to false (0), the SQL will revert to its pre-Cache 5.1 \r\n\tbehavior with regards to DISTINCT behavior.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "IdKey":{
          "type":"boolean",
          "default":1,
          "description":"Set the flag that determines whether a Primary Key constraint specified through DDL also<br>\r\nbecomes the IDKey index in the class definition or not. By default, the primary key does<br>\r\nalso become the idkey index. This generally gives better performance, but means that<br>\r\nthe Primary Key fields cannot be updated.<br>"
        },
        "IdTrxFrom":{
          "type":"string",
          "default":"",
          "description":"Modifies the DDL Identifier Translation mappings. This is for filtering/modifying valid SQL identifier characters when translating SQL identifiers into Objects identifiers. When converting an SQL identifier to an Objects identifier at DDL run-time, the characters in the 'From' list are converted to the characters in the 'To' list.<br>"
        },
        "IdTrxTo":{
          "type":"string",
          "default":"",
          "description":"Modifies the DDL Identifier Translation mappings. This is for filtering/modifying valid SQL identifier characters when translating SQL identifiers into Objects identifiers. When converting an SQL identifier to an Objects identifier at DDL run-time, the characters in the 'From' list are converted to the characters in the 'To' list.<br>"
        },
        "JDBCGatewayJVMArgs":{
          "type":"string",
          "default":"",
          "description":"Optional JVM arguments to include in the command line when starting the JDBC Gateway.<br>"
        },
        "JDBCGatewayLog":{
          "type":"string",
          "default":"",
          "description":"Name of the JDBC Gateway log file.<br>"
        },
        "JDBCGatewayPort":{
          "type":"integer",
          "default":62972,
          "description":"Port number for the JDBC Gateway.<br>"
        },
        "JDBCGatewayUsePassphrase":{
          "type":"boolean",
          "default":0,
          "description":"Require Passhphrase for JDBC connection"
        },
        "JavaClassPath":{
          "type":"string",
          "default":"",
          "description":""
        },
        "JavaHome":{
          "type":"string",
          "default":"",
          "description":""
        },
        "LockThreshold":{
          "type":"integer",
          "default":1000,
          "description":"The value n is the lock threshold. This is the number of inserts, updates, or deletes for a single table\r\nwithin a single transaction that will trigger a table-level lock when reached. For example, if the lock\r\nthreshold is 1000 and a process starts a transaction and then inserts 2000 rows, after the 1001st row is\r\ninserted the process will attempt to acquire a table-level lock instead of continue to lock individual\r\nrows. This is to help keep the lock table from becoming too full."
        },
        "LockTimeout":{
          "type":"integer",
          "default":10,
          "description":"Set the Lock Timeout for locks made during execution of SQL statements. This value is in seconds.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "ODBCVarcharMaxlen":{
          "type":"integer",
          "default":4096,
          "description":"Defines the MaxLen for ODBC fields of type VarChar.<br>"
        },
        "QueryProcedures":{
          "type":"boolean",
          "default":0,
          "description":"Defines whether or not all class queries project as SQL Stored Procedures \r\nregardless of the query's SqlProc setting.<br>\r\nDefault is 0, only class queries defined with SqlProc=1 will project as \r\nStored Procedures. When set to 1, all class queries will project as stored\r\nprocedures. When changing this setting, you must recompile the classes with \r\nthe class queries in order for this change to have an affect."
        },
        "RTPC":{
          "type":"boolean",
          "default":0,
          "description":"Enable Run Time Plan Choice<br>"
        },
        "ReferentialChecks":{
          "type":"boolean",
          "default":1,
          "description":"For INSERT, UPDATE, and DELETE, setting this parameter to 'Yes' instructs InterSystems IRIS to validate the foreign key constraint. Setting this parameter to 'No' will bypass foreign key constraint checking.<br>"
        },
        "SaveMAC":{
          "type":"boolean",
          "default":0,
          "description":"Defines whether or not the source code (.MAC and .INT) is saved or not. The default is that no source code is saved. This setting is made on a per-system basis.<br>"
        },
        "TCPKeepAlive":{
          "type":"integer",
          "default":300,
          "description":"Set the TCP Keep Alive timeout for xDBC TCP connections.<br>\r\nThis is the number of seconds between keep alive-messages.  The default for this is 300 seconds (5 minutes).]]]]><![CDATA[></Description>"
        },
        "TODATEDefaultFormat":{
          "type":"string",
          "default":"DD MON YYYY",
          "description":"Default date format for the SQL TO_DATE() function.<br>"
        },
        "TimePrecision":{
          "type":"integer",
          "default":0,
          "description":"Set the default precision for the Time component of the value returned by the GETDATE(), CURRENT_TIME, and CURRENT_TIMESTAMP SQL Scalar functions.  The precision, the number of decimal places for the millisecond portion of the time value, has a default is 0, which means milliseconds are not returned in the values returned by the GETDATE(), CURRENT_TIME, and CURRENT_TIMESTAMP functions.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "ANSIPrecedence":true,
        "AllowRowIDUpdate":false,
        "AutoParallel":true,
        "AutoParallelThreshold":3200,
        "BiasQueriesAsOutlier":false,
        "Comment":true,
        "DBMSSecurity":true,
        "DDLDefineBitmapExtent":true,
        "DDLFinal":true,
        "DDLNo201":false,
        "DDLNo30":false,
        "DDLNo307":false,
        "DDLNo311":false,
        "DDLNo315":false,
        "DDLNo324":false,
        "DDLNo333":false,
        "DDLSQLOnlyCompile":false,
        "DDLUseExtentSet":true,
        "DDLUseSequence":true,
        "DefaultSchema":"SQLUser",
        "DelimitedIds":true,
        "DropDelete":true,
        "ECPSync":false,
        "ExtrinsicFunctions":false,
        "FastDistinct":true,
        "IdKey":true,
        "IdTrxFrom":"~ `!@#$%^&*()_+-=[]\\{}|;':\",./<>?",
        "IdTrxTo":"",
        "JDBCGatewayJVMArgs":"",
        "JDBCGatewayLog":"",
        "JDBCGatewayPort":53773,
        "JDBCGatewayUsePassphrase":false,
        "JavaClassPath":"",
        "JavaHome":"",
        "LockThreshold":1000,
        "LockTimeout":10,
        "ODBCVarcharMaxlen":4096,
        "QueryProcedures":false,
        "RTPC":false,
        "ReferentialChecks":true,
        "SaveMAC":false,
        "TCPKeepAlive":300,
        "TODATEDefaultFormat":"DD MON YYYY",
        "TimePrecision":0
      }
    },
    "Shadows":{
      "type":"object",
      "properties":{
        "Address":{
          "type":"string",
          "default":"",
          "description":"IP Address to connect to.<br>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DaysBeforePurge":{
          "type":"integer",
          "default":0,
          "description":""
        },
        "DisableJournalUpdates":{
          "type":"boolean",
          "default":0,
          "description":"If true, updates that the shadow applies to the shadow databases are NOT\r\njournaled, regardless of the journal settings on the databases. By default,\r\nthis is false, that is, shadow updates are journaled."
        },
        "Enabled":{
          "type":"boolean",
          "default":0,
          "description":"Specifies whether the shadow should be running or stopped.<br>\r\n0 - Stopped<br>\r\n1 - Running<br>"
        },
        "FilterRoutine":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "JournalDirectory":{
          "type":"string",
          "default":"shadow",
          "description":"Directory where the shadow journal files reside.<br>"
        },
        "MaxErrors":{
          "type":"integer",
          "default":10,
          "description":"Maximum number of errors to retain.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "SSLConfig":{
          "type":"string",
          "default":"",
          "description":"SSL configuration to use on the shadow connection.<br>"
        }
      },
      "required":[
        "Address",
        "Name"
      ],
      "example":{
        "Address":"",
        "Name":""
      }
    },
    "ListOfShadows":{
      "type":"object",
      "properties":{
        "Shadows":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/Shadows"
          }
        }
      }
    },
    "SqlSysDatatypes":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Datatype":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Datatype",
        "Name"
      ],
      "example":{
        "Datatype":"",
        "Name":""
      }
    },
    "ListOfSqlSysDatatypes":{
      "type":"object",
      "properties":{
        "SqlSysDatatypes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SqlSysDatatypes"
          }
        }
      }
    },
    "SqlUserDatatypes":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "Datatype":{
          "type":"string",
          "default":"",
          "description":""
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        }
      },
      "required":[
        "Datatype",
        "Name"
      ],
      "example":{
        "Datatype":"",
        "Name":""
      }
    },
    "ListOfSqlUserDatatypes":{
      "type":"object",
      "properties":{
        "SqlUserDatatypes":{
          "type":"array",
          "items":{
            "$ref":"#/definitions/SqlUserDatatypes"
          }
        }
      }
    },
    "Startup":{
      "type":"object",
      "properties":{
        "ArbiterURL":{
          "type":"string",
          "default":"",
          "description":"When configuring a mirror using ShardMirrorRole, this field can be\r\nused to specify an Arbiter.<br>\r\nThe format of this field is  <i>host</i>:<i>port</i>"
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "CallinHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the CALLIN^%ZSTOP routine entry during calling Halt.<br>"
        },
        "CallinStart":{
          "type":"boolean",
          "default":1,
          "description":"Executes the CALLIN^%ZSTART routine entry during Callin startup.<br>"
        },
        "CliSysName":{
          "type":"string",
          "default":"",
          "description":"Name used to append to $J when Config.Miscellaneous.NodeNameInPid is set.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DBSizesAllowed":{
          "type":"string",
          "default":"8192",
          "description":"Stores a list of allowed database block sizes.<br>"
        },
        "DefaultPort":{
          "type":"integer",
          "default":1972,
          "description":"Port for the SuperServer.<br>"
        },
        "DefaultPortBindAddress":{
          "type":"string",
          "default":"",
          "description":"IP Address SuperServer will bind to.<br>\r\nBy default, the SuperServer accepts requests on all addresses, but if a DefaultPortBindAddress is specified it will accept requests only on that address.\r\nYou should insure that all clients, including the CSP Gateway, are also configured to connect to the address you specify.\r\nIf no address is specified, the SuperServer will accept requests directed to any address on the server."
        },
        "EnableVSSBackup":{
          "type":"boolean",
          "default":0,
          "description":"Start the VSS Backup Daemon.<br>"
        },
        "EnsembleAutoStart":{
          "type":"boolean",
          "default":0,
          "description":"Auto start the Interoperability productions.<br>"
        },
        "ErrorPurge":{
          "type":"integer",
          "default":30,
          "description":"Number of days to store application error logs before purging them.<br>"
        },
        "FIPSMode":{
          "type":"boolean",
          "default":0,
          "description":"Use FIPS 140-2 compliant library for database encryption.<br>"
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "IPv6":{
          "type":"boolean",
          "default":0,
          "description":"System is operating in an IPv6 network, with IPv6 addresses.<br>\r\n0 - IPv6 is not enabled.<br>\r\n1 - IPv6 is enabled.<br>"
        },
        "JobHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the JOB^%ZSTOP routine entry during JOB process Halt.<br>"
        },
        "JobServers":{
          "type":"integer",
          "default":0,
          "description":"Number of job servers you want the system to start up with.<br>"
        },
        "JobStart":{
          "type":"boolean",
          "default":1,
          "description":"Execute the JOB^%ZSTART routine entry during JOB process startup.<br>"
        },
        "LicenseID":{
          "type":"string",
          "default":"",
          "description":"LicenseID is used to request the license key from the License Server at startup, if there is no local key file.<br>"
        },
        "MaxConsoleLogSize":{
          "type":"integer",
          "default":5,
          "description":"Maximum size in megabytes of the messages.log after which it will be automatically switched.<br>"
        },
        "MaxIRISTempSizeAtStart":{
          "type":"integer",
          "default":0,
          "description":"Maximum size in megabytes the IRISTEMP database will be when the system is\r\nrestarted.<br> When the system restarts, the IRISTEMP database will be truncated to\r\nthis size. If 0, the IRISTEMP database will not be truncated.<br>"
        },
        "MirrorMember":{
          "type":"string",
          "default":"",
          "description":"Make this node part of a mirror:<br>\r\n<ul>\r\n<li> primary: This node will be the primary failover member\r\n<li> backup: This node will be the backup failover member\r\n<li> drasync This node will be a DR async member\r\n</ul>\r\nNote that these are only initial designations, and that failover may occur at any time. "
        },
        "MirrorPrimary":{
          "type":"string",
          "default":"",
          "description":"Specifies the host or IP of the initial mirror primary. This parameter is required for any\r\nnon-empty value of parameter <i>MirrorMember</i> other than \"primary\"."
        },
        "MirrorSetName":{
          "type":"string",
          "default":"",
          "description":"MirrorSetName is the name of the mirror set to be created. This name is converted to uppercase before storing.\r\nOnly alphanumeric characters are allowed to be in the mirror set name. This name can not be a null string."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "PasswordHash":{
          "type":"string",
          "default":"",
          "description":"Set the IRIS password using a cryptographic hash and salt.<br>\r\nThe format of this field is:  <i>hash</i>,<i>salt</i>,<i>workFactor</i>,<i>algorithm</i><br>\r\n<ul>\r\n<li>Hash: Hex-encoded output of PBKDF2 function.  Must be correct number of bits for Algorithm.\r\n<li>Salt: Hex-encoded salt input to PBKDF2.  Must be correct number of bits for Algorithm.\r\n<li>WorkFactor: WorkFactor input for PBKDF2.\r\n<li>Algorithm: A valid <a href=\"%25CSP.Documatic.cls?PAGE=CLASS&LIBRARY=%25SYS&CLASSNAME=Security.PBKDF2Alg\">Security.Datatype.PBKDF2Alg</a> value.\r\n</ul>\r\n"
        },
        "ProcessHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the LOGIN^%ZSTOP routine entry during terminal user Halt.<br>"
        },
        "ProcessStart":{
          "type":"boolean",
          "default":1,
          "description":"Execute the LOGIN^%ZSTART routine entry during terminal user startup.<br>"
        },
        "ShardClusterURL":{
          "type":"string",
          "default":"",
          "description":"In node-level architecture, specifies the location of the initial data node.\r\nThis field should be populated for all values of <i>ShardRole</i> other than <b>NODE1</b>.<br>\r\nThe format of this field is:  IRIS://<i>host</i>:<i>port</i>/<i>namespace</i><br>"
        },
        "ShardMasterRegexp":{
          "type":"string",
          "default":"-0$",
          "description":"Regular expression used to determine node type when <i>ShardRole</i> is <b>AUTO</b>.\r\nIf the hostname matches this expression, role will be <b>NODE1</b>, otherwise <b>DATA</b>.\r\nThe default regular expression assumes that the hostname for the <b>NODE1</b> node ends in \"-0\":<br>\r\n<ul>\r\niris-data-0 &nbsp&nbsp&nbsp&nbsp // NODE1<br>\r\niris-data-1 &nbsp&nbsp&nbsp&nbsp // DATA<br>\r\n. . .<br>\r\niris-data-N &nbsp&nbsp&nbsp&nbsp // DATA<br>\r\n</ul>\r\nHowever, suppose your hostname convention was the following:\r\n<ul>\r\niris-data-0-0 &nbsp&nbsp&nbsp&nbsp // Shard 0 primary<br>\r\niris-data-0-1 &nbsp&nbsp&nbsp&nbsp // Shard 0 backup<br>\r\niris-data-1-0 &nbsp&nbsp&nbsp&nbsp // Shard 1 primary<br>\r\niris-data-1-1 &nbsp&nbsp&nbsp&nbsp // Shard 1 backup<br>\r\n. . .<br>\r\niris-data-N-0 &nbsp&nbsp&nbsp&nbsp // Shard N primary<br>\r\niris-data-N-1 &nbsp&nbsp&nbsp&nbsp // Shard N backup<br>\r\n</ul>\r\nIn this case, we choose a value for <i>ShardMasterRegexp</i> that matches the first node only: \"-0-0$\"<br>"
        },
        "ShardMirrorMember":{
          "type":"string",
          "default":"",
          "description":"Make this node part of a mirror:<br>\r\n<ul>\r\n<li> primary: This node will be the primary failover member\r\n<li> backup: This node will be the backup failover member\r\n<li> drasync This node will be a DR async member\r\n<li> auto: Automatic failover member selection based on whether the hostname (which must conform with <i>ShardRegexp</i>)\r\ncontains an even or odd number after the final dash:\r\n  <ul>\r\n  iris-data-0: primary<br>\r\n  iris-data-1: backup<br>\r\n  iris-data-2: primary<br>\r\n  iris-data-3: backup<br>\r\n  </ul>\r\n</ul>\r\nNote that these are only initial designations, and that failover may occur at any time. "
        },
        "ShardRegexp":{
          "type":"string",
          "default":"-[0-9]+$",
          "description":"Regular expression used to make sure that hostnames conform to a regular numbering scheme,\r\nwhich is a prerequisite for using <i>ShardRole</i> and <i>ShardMirrorMember</i> in automatic mode.  The default assumes\r\na scheme such as the following:\r\n<ul>\r\niris-data-0<br>\r\niris-data-1<br>\r\n. . .<br>\r\niris-data-N<br>\r\n</ul>"
        },
        "ShardRole":{
          "type":"string",
          "default":"",
          "description":"Specify the role of this IRIS instance in nod-level architecture:<br>\r\n<ul>\r\n<li> NODE1: This is the initial data node; if mirrored, set on primary failover member only\r\n<li> DATA: For all data nodes other than NODE1\r\n<li> AUTO: Automatically determine role by comparing hostname with <i>ShardMasterRegexp</i>:\r\n  <ul>\r\n  <li>Match: NODE1\r\n  <li>Non-match: DATA\r\n  </ul>\r\n<li> COMPUTE: This will be a compute node\r\n</ul>\r\nFor all roles other than <b>NODE1</b>, requires that <i>ShardClusterURL</i> be provided."
        },
        "ShutdownTimeout":{
          "type":"integer",
          "default":300,
          "description":"Enter the time, in seconds, InterSystems IRIS should wait for shutdown to complete normally before\r\ntiming out and forcing a shutdown.<br>"
        },
        "SystemHalt":{
          "type":"boolean",
          "default":1,
          "description":"Execute the SYSTEM^%ZSTOP routine entry during system shutdown.<br>"
        },
        "SystemMode":{
          "type":"string",
          "default":"",
          "description":"The SystemMode is displayed in the title of the Management Portal web page. Currently, SystemMode string values recognized by the Management Portal include:<br>\r\n<ul>\r\n<li>LIVE\r\n<li>TEST\r\n<li>DEVELOPMENT\r\n<li>FAILOVER\r\n</ul>"
        },
        "SystemStart":{
          "type":"boolean",
          "default":1,
          "description":"Executes the SYSTEM^%ZSTART routine entry during system startup.<br>"
        },
        "TempDirectory":{
          "type":"string",
          "default":"Temp",
          "description":"Directory for temporary files.<br>"
        },
        "TerminalPrompt":{
          "type":"string",
          "default":"8,2",
          "description":"Set the format of the terminal prompt.<br>\r\nThis is a comma separated string of values which set the default terminal prompt for the system.<br>\r\nValues:<br>\r\n0 - Use only \">\" for the prompt.<br>\r\n1 - Host name, also known as the current system name. The name assigned to your\r\ncomputer. For example, LABLAPTOP&gt;. This is the same for all of your terminal\r\nprocesses.<br>\r\n2 - Namespace name. For example, %SYS&gt;. The current namespace name is contained\r\nin the $NAMESPACE special variable. It can be an explicit namespace name or an\r\nimplied namespace name.<br>\r\n3 - Config name. The name of your system installation. For example, DEVELOPMENT&gt;.\r\nThis is the same for all of your terminal processes.<br>\r\n4 - Current time, expressed as local time in 24-hour format with whole seconds.\r\nFor example, 15:59:36&gt;. This is the static time value for when the prompt was\r\nreturned. This value changes for each prompt.<br>\r\n5 - pid. The Process ID for your terminal. For example, 2336&gt;. This is different\r\nfor each terminal process. This value can also be returned from the $JOB special\r\nvariable.<br>\r\n6 - Username. For example, fred&gt;. This is the same for all of your terminal\r\nprocesses.<br>\r\n7 - Elapsed time executing the last command, in seconds.milliseconds. For example,\r\n.000495&gt;. Leading and trailing zeros are suppressed. This changes for each prompt.<br>\r\n8 - Transaction Level. For example, TL1&gt;.<br><br>\r\nThe order of the values in the string determines the order the values appear in the prompt.\r\nFor example TerminalPrompt=\"2,1\" will give you a terminal prompt of \"%SYS:HostName>\""
        },
        "WebServer":{
          "type":"boolean",
          "default":1,
          "description":"Start the private WebServer.<br>"
        },
        "WebServerName":{
          "type":"string",
          "default":"",
          "description":"Webserver name or IP address the private web server is running on.<br>\r\nIf not specified, it defaults to localhost. For Unix and Windows, the\r\nprivate web server will be started on this node, on the specified IP address\r\nand port. For VMS, This is the IP address of the node where the webserver\r\nis running."
        },
        "WebServerPort":{
          "type":"integer",
          "default":57772,
          "description":"Private WebServer port.<br>"
        },
        "WebServerURLPrefix":{
          "type":"string",
          "default":"",
          "description":"URL prefix.<br>"
        },
        "ZSTU":{
          "type":"boolean",
          "default":1,
          "description":"Run the user defined startup from the ZSTU routine at system startup.<br>"
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "ArbiterURL":"",
        "CallinHalt":true,
        "CallinStart":true,
        "CliSysName":"",
        "DBSizesAllowed":"8192",
        "DefaultPort":1972,
        "DefaultPortBindAddress":"",
        "EnableVSSBackup":false,
        "EnsembleAutoStart":true,
        "ErrorPurge":30,
        "FIPSMode":false,
        "IPv6":false,
        "JobHalt":true,
        "JobServers":0,
        "JobStart":true,
        "LicenseID":"",
        "MaxConsoleLogSize":5,
        "MaxIRISTempSizeAtStart":0,
        "MirrorMember":"",
        "MirrorPrimary":"",
        "MirrorSetName":"",
        "PasswordHash":"",
        "ProcessHalt":true,
        "ProcessStart":true,
        "ShardClusterURL":"",
        "ShardMasterRegexp":"-0$",
        "ShardMirrorMember":"",
        "ShardRegexp":"-[0-9]+$",
        "ShardRole":"",
        "ShutdownTimeout":300,
        "SystemHalt":true,
        "SystemMode":"",
        "SystemStart":true,
        "TempDirectory":"Temp",
        "TerminalPrompt":"8,2",
        "WebServer":true,
        "WebServerName":"",
        "WebServerPort":52773,
        "WebServerURLPrefix":"",
        "ZSTU":true
      }
    },
    "Telnet":{
      "type":"object",
      "properties":{
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "DNSLookup":{
          "type":"string",
          "default":"ON",
          "description":"Determines whether DNS lookup should be enabled.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "Port":{
          "type":"integer",
          "default":23,
          "description":"Telnet port.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "DNSLookup":"ON",
        "Port":23
      }
    },
    "config":{
      "type":"object",
      "properties":{
        "BackoffDisabled":{
          "type":"boolean",
          "default":0,
          "description":"Upon failure to allocate memory, do not retry with a reduced amount.  If shared\r\nmemory cannot be allocated at its configured size, startup is aborted.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "CPFFile":{
          "type":"string",
          "default":"/usr/irissys/iris.cpf",
          "description":"CPF file which the object maps to.<br>"
        },
        "Comments":{
          "type":"string",
          "default":"",
          "description":"Embedded comments in the CPF file.<br>"
        },
        "ConsoleFile":{
          "type":"string",
          "default":"",
          "description":"Location of the messages.log file.<br>\r\nNull means the MGR directory.<br>\r\nThis is the second piece of the CPF parameter console=VMSConsoleTerminal,ConsoleFile\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "Flags":{
          "type":"integer",
          "default":7,
          "description":"Flags governing how the object is processed when %Save() is called.<br>\r\nFor normal operations, all bits should be set.<br>\r\n<b>Bit $$$CPFSave</b> - Save object to disk.<br>\r\n<b>Bit $$$CPFWrite</b> - Write CPF file from object.<br>\r\n<b>Bit $$$CPFActivate</b> - Activate object into memory if CPFFile is the same as what is currently active.<br>\r\n<b>Bit $$$CPFAvoidBackupDB</b> - Don't Add/Remove the Database to Backup DB list.<br>"
        },
        "LargePagesDisabled":{
          "type":"boolean",
          "default":0,
          "description":"If true, on platforms supporting large/huge pages, instructs the system not\r\nto use them for global and routine buffers.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "LargePagesRequired":{
          "type":"boolean",
          "default":0,
          "description":"If true, on platforms supporting large or huge pages, requires shared memory to\r\nbe allocated from them.  Ignored on other platforms or if large pages are \r\ndisabled by <PROPERTY>LargePagesDisabled</PROPERTY>.  If true and not ignored, \r\nand memory cannot be allocated in large/huge pages, startup is aborted.  Note: \r\nstartup may retry with a small reduction in memory size, but the extent to which\r\nmemory may be reduced is smaller than would be allowed in absence of this flag.\r\nYou can disable this retry altogether with <PROPERTY>BackoffDisabled</PROPERTY>.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "LibPath":{
          "type":"string",
          "default":"",
          "description":"On Unix systems this sets the LD_LIBRARY_PATH environment variable to set \r\nsearch paths for third-party shared libraries. Ignored on Windows and VMS.\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "LineRecallBuffer":{
          "type":"integer",
          "default":1024,
          "description":"The size in bytes of the command line/read line buffer.<br>\r\nThis is the second piece of the CPF parameter history=LineRecallEntries,LineRecallBuffer\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "LineRecallEntries":{
          "type":"integer",
          "default":500,
          "description":"The number of entries held in the command line/read line recall buffer.<br>\r\nThis is the first piece of the CPF parameter history=LineRecallEntries,LineRecallBuffer\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "LockSharedMemory":{
          "type":"boolean",
          "default":0,
          "description":"On platforms that support it, requests control structures, global and routine\r\nbuffers to be locked in physical memory.  When using large or huge pages for\r\nshared memory, there is no need to set this property since they are \r\nautomatically locked in physical memory.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=.\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "LockTextSegment":{
          "type":"boolean",
          "default":0,
          "description":"On some UNIX platforms, requests the text segment (executable image) to be\r\nlocked in physical memory.\r\n<br><br>\r\nMakes up part of the CPF parameter memlock=\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "MaxServerConn":{
          "type":"integer",
          "default":1,
          "description":"Maximum number of clients that can access this server simultaneously.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "MaxServers":{
          "type":"integer",
          "default":2,
          "description":"Maximum number of ECP servers that can be accessed from this system.<br>\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active if memory is available in the shared memory heap."
        },
        "Name":{
          "type":"string",
          "default":"",
          "description":"Name of the object instance.<br>"
        },
        "VMSConsoleTerminal":{
          "type":"string",
          "default":"",
          "description":"Location of the VMS console terminal.<br>\r\nThis is the first piece of the CPF parameter console=VMSConsoleTerminal,ConsoleFile\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "ZFSize":{
          "type":"integer",
          "default":0,
          "description":"The total number of bytes allocated in virtual memory for $ZF input and output parameters, including strings.<br>\r\nThis is the second piece of the CPF parameter zfheap=ZFString,ZFSize\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "ZFString":{
          "type":"integer",
          "default":0,
          "description":"Number of bytes allocated for the each output byte array or string parameter on the $ZF heap.<br>\r\nThis is the First piece of the CPF parameter zfheap=ZFString,ZFSize\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "bbsiz":{
          "type":"integer",
          "default":262144,
          "description":"Maximum amount of memory a process can use (in KB).<br>\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "console":{
          "type":"string",
          "default":",",
          "description":"CPF file representation of console=VMSConsoleTerminal,ConsoleFile.<br>"
        },
        "errlog":{
          "type":"integer",
          "default":500,
          "description":"Maximum number of entries you want to store in the SYSLOG log file.<br>\r\nThe log file will expire old entries when this limit is reached.\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals":{
          "type":"string",
          "default":"0,0,0,0,0,0",
          "description":"List of configured sizes (in MBytes) for the global caches.<br>\r\nElement #1 corresponds to 2KB blocks (deprecated, always 0 now).<br>\r\nElement #2 corresponds to 4KB blocks.<br>\r\nElement #3 corresponds to 8KB blocks.<br>\r\nElement #4 corresponds to 16KB blocks.<br>\r\nElement #5 corresponds to 32KB blocks.<br>\r\nElement #6 corresponds to 64KB blocks.<br>"
        },
        "globals16kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 16KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals32kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 32KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals4kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 4KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals64kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 64KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "globals8kb":{
          "type":"integer",
          "default":0,
          "description":"Number of 8KB buffers in MB.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "gmheap":{
          "type":"integer",
          "default":37568,
          "description":"Generic Memory Heap Size (in KB).<br>\r\nThis is the place from where the Lock\r\ntable, the NLS tables and the PID table are allocated. The absolute minimum value is\r\n2048KB. If you specify a big Lock Table, the minimum value will increase so that there's\r\nalways room for it. If you are using an Asian locale you may want to add an extra MB (1024KB).\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "history":{
          "type":"string",
          "default":"500,1024",
          "description":"CPF file representation of history=LineRecallEntries,LineRecallBuffer.<br>"
        },
        "ijcbuff":{
          "type":"integer",
          "default":512,
          "description":"Number of bytes allocated for each InterJob Communication Device.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "ijcnum":{
          "type":"integer",
          "default":16,
          "description":"The number of InterJob Communication devices.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "jrnbufs":{
          "type":"integer",
          "default":64,
          "description":"Size of journal buffer pool in MBs. Modifying this property will require a restart of the system to make it active. The maximum value is 1024 and the minimum, 16 on Unicode platforms or 8 otherwise."
        },
        "locksiz":{
          "type":"integer",
          "default":16777216,
          "description":"The amount of memory allocated on your system for locks, in bytes.<br>\r\nThe maximum value depends on the gmheap size and not exceeding gmheap size. Memory is allocated in multiples\r\nof 64k (65536 bytes) chunks. If you enter a value which is not on a 64k boundary, the\r\nvalue will be rounded to the next higher 64k boundary.\r\nIncrease the gmheap size if you need more room for the Lock Table.\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "memlock":{
          "type":"integer",
          "default":0,
          "description":"When checked, this allows you to lock control structures in memory to improve access time.<br>\r\nCPF file representation of memlock="
        },
        "netjob":{
          "type":"boolean",
          "default":1,
          "description":"Allows jobs from remote connections to run on your server.<br>\r\n<br><br>\r\nModifying this property does not require a restart of the system to make it active."
        },
        "nlstab":{
          "type":"integer",
          "default":50,
          "description":"Enter the maximum number of collation tables. This instructs InterSystems IRIS to reserve space for that many tables at startup.<sp>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "overview":{
          "type":"string",
          "default":"Windows (Intel)~Windows",
          "description":""
        },
        "pijdir":{
          "type":"string",
          "default":"",
          "description":"Directory to store the cluster image journal.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "routines":{
          "type":"string",
          "default":0,
          "description":"Number of MB allocated for caching routine buffers.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "targwijsz":{
          "type":"integer",
          "default":0,
          "description":"When targwijsz is non-zero it is the desired size of the WIJ file in MB.\r\nThe maximum effective value is the size of the buffer pool. While it would not hurt\r\nto have a larger WIJ, it does not help anything. The minimum value is 100MB. When\r\nthe size of the global buffer pool is less than 100MB at startup the WIJ is sized\r\nto hold the entire buffer pool; the minimum size of the WIJ at startup is either\r\n100MB or the size required to hold the entire buffer pool (which is slightly larger\r\nthan the actual size of the buffer pool). If an existing WIJ is larger than\r\nthe specified target, the size of the WIJ is not reduced. <br><br>\r\nWhen the target size is larger than the size of the existing WIJ, the system will\r\nexpand the WIJ while the write daemon is idle up to the specified target (but\r\nnot to exceed the actual size of the WIJ needed to hold the entire buffer pool). The\r\nsystem can expand the WIJ past the target size if that becomes necessary to\r\ncomplete a write cycle.<br><br>\r\nLeaving this value set to 0 is fine. The system will grow the WIJ as needed based\r\non activity. Generally the WIJ quickly reaches whatever size is needed to \r\nsupport the activity level/the size of the buffer pool.  The purpose of setting\r\na target size is that if space has been reserved for the WIJ, setting a target\r\nallows the WIJ to grow to occupy that space early on in the life of the system.\r\nSince user activity can be blocked if the WIJ is too small (the WIJ will try to expand\r\nif this happens), setting the target may lead to a better user experience after\r\nstartup. If the target is set to 0, the WIJ may quickly expand as needed however\r\nusers may be blocked at times when this happens until the WIJ reaches the size\r\nrequired by the system."
        },
        "udevtabsiz":{
          "type":"integer",
          "default":24576,
          "description":"Maximum size in bytes of the device table.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "useresidentmem":{
          "type":"string",
          "default":"",
          "description":"VMS system resident memory name.<br>\r\n<br><br>\r\nModifying this property will require a restart of the system to make it active."
        },
        "wijdir":{
          "type":"string",
          "default":"",
          "description":"Enter the directory for the Write Image Journal file into this text box.<br>\r\n<br><br>\r\nModifying this property does not require an instance restart to activate the change except on cluster members."
        }
      },
      "required":[
        "Name"
      ],
      "example":{
        "BackoffDisabled":false,
        "ConsoleFile":"",
        "LargePagesDisabled":false,
        "LargePagesRequired":false,
        "LibPath":"",
        "LineRecallBuffer":1024,
        "LineRecallEntries":500,
        "LockSharedMemory":false,
        "LockTextSegment":false,
        "MaxServerConn":1,
        "MaxServers":2,
        "VMSConsoleTerminal":"",
        "ZFSize":0,
        "ZFString":0,
        "bbsiz":262144,
        "errlog":500,
        "globals16kb":0,
        "globals32kb":0,
        "globals4kb":0,
        "globals64kb":0,
        "globals8kb":0,
        "gmheap":37568,
        "ijcbuff":512,
        "ijcnum":16,
        "jrnbufs":64,
        "locksiz":16777216,
        "netjob":true,
        "nlstab":50,
        "pijdir":"",
        "routines":"0",
        "targwijsz":0,
        "udevtabsiz":24576,
        "wijdir":""
      }
    }
  }
}
]]></Data>
</XData>
</Class>


<Class name="Api.Config.Services.Cluster">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.835227</TimeChanged>
<TimeCreated>65834,73166.835227</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Cluster).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("CommIPAddress") = pObj.CommIPAddress
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("JoinCluster") = pObj.JoinCluster
	Set properties("Name") = pObj.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"CommIPAddress") properties("CommIPAddress") = model.CommIPAddress
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"JoinCluster") properties("JoinCluster") = model.JoinCluster
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("CommIPAddress")) model.%Set("CommIPAddress", properties("CommIPAddress"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("JoinCluster")) model.%Set("JoinCluster", properties("JoinCluster"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Cluster).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ConfigFile">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.879077</TimeChanged>
<TimeCreated>65834,73166.879077</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Version="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Version property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.ConfigFile).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("Product") = pObj.Product
	Set properties("Version") = pObj.Version
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Product") properties("Product") = model.Product
	Set:$$$CanSetProperty(model,"Version") properties("Version") = model.Version
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Product")) model.%Set("Product", properties("Product"), "string")
	Do:$Data(properties("Version")) model.%Set("Version", properties("Version"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.ConfigFile).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Databases">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.906377</TimeChanged>
<TimeCreated>65834,73166.906377</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Directory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Directory property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Databases).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Databases).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Databases).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Databases).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.Databases:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("ClusterMountMode") = pObj.ClusterMountMode
	Set properties("Comments") = pObj.Comments
	Set properties("Directory") = pObj.Directory
	Set properties("Flags") = pObj.Flags
	Set properties("MountAtStartup") = pObj.MountAtStartup
	Set properties("MountRequired") = pObj.MountRequired
	Set properties("Name") = pObj.Name
	Set properties("Server") = pObj.Server
	Set properties("StreamLocation") = pObj.StreamLocation
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"ClusterMountMode") properties("ClusterMountMode") = model.ClusterMountMode
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Directory") properties("Directory") = model.Directory
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"MountAtStartup") properties("MountAtStartup") = model.MountAtStartup
	Set:$$$CanSetProperty(model,"MountRequired") properties("MountRequired") = model.MountRequired
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Server") properties("Server") = model.Server
	Set:$$$CanSetProperty(model,"StreamLocation") properties("StreamLocation") = model.StreamLocation
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("ClusterMountMode")) model.%Set("ClusterMountMode", properties("ClusterMountMode"), "boolean")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Directory")) model.%Set("Directory", properties("Directory"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("MountAtStartup")) model.%Set("MountAtStartup", properties("MountAtStartup"), "boolean")
	Do:$Data(properties("MountRequired")) model.%Set("MountRequired", properties("MountRequired"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Server")) model.%Set("Server", properties("Server"), "string")
	Do:$Data(properties("StreamLocation")) model.%Set("StreamLocation", properties("StreamLocation"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Databases).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Debug">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.951612</TimeChanged>
<TimeCreated>65834,73166.951612</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Debug).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Debug).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Debug).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Debug).Get(Name,.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.Debug:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Debug).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.DeviceSubTypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.960253</TimeChanged>
<TimeCreated>65834,73166.960253</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.DeviceSubTypes).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.DeviceSubTypes).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.DeviceSubTypes).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.DeviceSubTypes).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.DeviceSubTypes:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("Backspace") = pObj.Backspace
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("CursorControl") = pObj.CursorControl
	Set properties("EraseEOF") = pObj.EraseEOF
	Set properties("EraseEOL") = pObj.EraseEOL
	Set properties("Flags") = pObj.Flags
	Set properties("FormFeed") = pObj.FormFeed
	Set properties("Name") = pObj.Name
	Set properties("RightMargin") = pObj.RightMargin
	Set properties("ScreenLength") = pObj.ScreenLength
	Set properties("ZU22Backspace") = pObj.ZU22Backspace
	Set properties("ZU22FormFeed") = pObj.ZU22FormFeed
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"Backspace") properties("Backspace") = model.Backspace
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"CursorControl") properties("CursorControl") = model.CursorControl
	Set:$$$CanSetProperty(model,"EraseEOF") properties("EraseEOF") = model.EraseEOF
	Set:$$$CanSetProperty(model,"EraseEOL") properties("EraseEOL") = model.EraseEOL
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"FormFeed") properties("FormFeed") = model.FormFeed
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"RightMargin") properties("RightMargin") = model.RightMargin
	Set:$$$CanSetProperty(model,"ScreenLength") properties("ScreenLength") = model.ScreenLength
	Set:$$$CanSetProperty(model,"ZU22Backspace") properties("ZU22Backspace") = model.ZU22Backspace
	Set:$$$CanSetProperty(model,"ZU22FormFeed") properties("ZU22FormFeed") = model.ZU22FormFeed
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("Backspace")) model.%Set("Backspace", properties("Backspace"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("CursorControl")) model.%Set("CursorControl", properties("CursorControl"), "string")
	Do:$Data(properties("EraseEOF")) model.%Set("EraseEOF", properties("EraseEOF"), "string")
	Do:$Data(properties("EraseEOL")) model.%Set("EraseEOL", properties("EraseEOL"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("FormFeed")) model.%Set("FormFeed", properties("FormFeed"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("RightMargin")) model.%Set("RightMargin", properties("RightMargin"), "number")
	Do:$Data(properties("ScreenLength")) model.%Set("ScreenLength", properties("ScreenLength"), "number")
	Do:$Data(properties("ZU22Backspace")) model.%Set("ZU22Backspace", properties("ZU22Backspace"), "string")
	Do:$Data(properties("ZU22FormFeed")) model.%Set("ZU22FormFeed", properties("ZU22FormFeed"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.DeviceSubTypes).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Devices">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.933042</TimeChanged>
<TimeCreated>65834,73166.933042</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.PhysicalDevice="" sc = $$$ADDSC(sc,$$$ERROR(5001, "PhysicalDevice property is mandatory."))
	Set:model.SubType="" sc = $$$ADDSC(sc,$$$ERROR(5001, "SubType property is mandatory."))
	Set:model.Type="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Type property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Devices).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Devices).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Devices).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Devices).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.Devices:List")
		Do rs.Execute(Names, CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("Alias") = pObj.Alias
	Set properties("AlternateDevice") = pObj.AlternateDevice
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Description") = pObj.Description
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("OpenParameters") = pObj.OpenParameters
	Set properties("PhysicalDevice") = pObj.PhysicalDevice
	Set properties("Prompt") = pObj.Prompt
	Set properties("SubType") = pObj.SubType
	Set properties("Type") = pObj.Type
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"Alias") properties("Alias") = model.Alias
	Set:$$$CanSetProperty(model,"AlternateDevice") properties("AlternateDevice") = model.AlternateDevice
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Description") properties("Description") = model.Description
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"OpenParameters") properties("OpenParameters") = model.OpenParameters
	Set:$$$CanSetProperty(model,"PhysicalDevice") properties("PhysicalDevice") = model.PhysicalDevice
	Set:$$$CanSetProperty(model,"Prompt") properties("Prompt") = model.Prompt
	Set:$$$CanSetProperty(model,"SubType") properties("SubType") = model.SubType
	Set:$$$CanSetProperty(model,"Type") properties("Type") = model.Type
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("Alias")) model.%Set("Alias", properties("Alias"), "number")
	Do:$Data(properties("AlternateDevice")) model.%Set("AlternateDevice", properties("AlternateDevice"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Description")) model.%Set("Description", properties("Description"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("OpenParameters")) model.%Set("OpenParameters", properties("OpenParameters"), "string")
	Do:$Data(properties("PhysicalDevice")) model.%Set("PhysicalDevice", properties("PhysicalDevice"), "string")
	Do:$Data(properties("Prompt")) model.%Set("Prompt", properties("Prompt"), "number")
	Do:$Data(properties("SubType")) model.%Set("SubType", properties("SubType"), "string")
	Do:$Data(properties("Type")) model.%Set("Type", properties("Type"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Devices).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ECP">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.99487</TimeChanged>
<TimeCreated>65834,73166.99487</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.ECP).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("ClientReconnectDuration") = pObj.ClientReconnectDuration
	Set properties("ClientReconnectInterval") = pObj.ClientReconnectInterval
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("ServerTroubleDuration") = pObj.ServerTroubleDuration
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"ClientReconnectDuration") properties("ClientReconnectDuration") = model.ClientReconnectDuration
	Set:$$$CanSetProperty(model,"ClientReconnectInterval") properties("ClientReconnectInterval") = model.ClientReconnectInterval
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"ServerTroubleDuration") properties("ServerTroubleDuration") = model.ServerTroubleDuration
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("ClientReconnectDuration")) model.%Set("ClientReconnectDuration", properties("ClientReconnectDuration"), "number")
	Do:$Data(properties("ClientReconnectInterval")) model.%Set("ClientReconnectInterval", properties("ClientReconnectInterval"), "number")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("ServerTroubleDuration")) model.%Set("ServerTroubleDuration", properties("ServerTroubleDuration"), "number")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.ECP).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.ECPServers">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.983167</TimeChanged>
<TimeCreated>65834,73166.983167</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Address="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Address property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.ECPServers).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.ECPServers).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.ECPServers).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.ECPServers).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.ECPServers:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("Address") = pObj.Address
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("MirrorConnection") = pObj.MirrorConnection
	Set properties("Name") = pObj.Name
	Set properties("Port") = pObj.Port
	Set properties("SSLConfig") = pObj.SSLConfig
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"Address") properties("Address") = model.Address
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"MirrorConnection") properties("MirrorConnection") = model.MirrorConnection
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Port") properties("Port") = model.Port
	Set:$$$CanSetProperty(model,"SSLConfig") properties("SSLConfig") = model.SSLConfig
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("Address")) model.%Set("Address", properties("Address"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("MirrorConnection")) model.%Set("MirrorConnection", properties("MirrorConnection"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Port")) model.%Set("Port", properties("Port"), "number")
	Do:$Data(properties("SSLConfig")) model.%Set("SSLConfig", properties("SSLConfig"), "number")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.ECPServers).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.IO">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.007783</TimeChanged>
<TimeCreated>65834,73167.007783</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.IO).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("File") = pObj.File
	Set properties("Flags") = pObj.Flags
	Set properties("MagTape") = pObj.MagTape
	Set properties("Name") = pObj.Name
	Set properties("Other") = pObj.Other
	Set properties("Terminal") = pObj.Terminal
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"File") properties("File") = model.File
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"MagTape") properties("MagTape") = model.MagTape
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Other") properties("Other") = model.Other
	Set:$$$CanSetProperty(model,"Terminal") properties("Terminal") = model.Terminal
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("File")) model.%Set("File", properties("File"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("MagTape")) model.%Set("MagTape", properties("MagTape"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Other")) model.%Set("Other", properties("Other"), "string")
	Do:$Data(properties("Terminal")) model.%Set("Terminal", properties("Terminal"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.IO).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Journal">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.006931</TimeChanged>
<TimeCreated>65834,73167.006931</TimeCreated>

<Parameter name="ISSINGLE">
<Description>
Description</Description>
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Journal).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AlternateDirectory") = pObj.AlternateDirectory
	Set properties("BackupsBeforePurge") = pObj.BackupsBeforePurge
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("CurrentDirectory") = pObj.CurrentDirectory
	Set properties("DaysBeforePurge") = pObj.DaysBeforePurge
	Set properties("FileSizeLimit") = pObj.FileSizeLimit
	Set properties("Flags") = pObj.Flags
	Set properties("FreezeOnError") = pObj.FreezeOnError
	Set properties("JournalFilePrefix") = pObj.JournalFilePrefix
	Set properties("JournalcspSession") = pObj.JournalcspSession
	Set properties("Name") = pObj.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AlternateDirectory") properties("AlternateDirectory") = model.AlternateDirectory
	Set:$$$CanSetProperty(model,"BackupsBeforePurge") properties("BackupsBeforePurge") = model.BackupsBeforePurge
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"CurrentDirectory") properties("CurrentDirectory") = model.CurrentDirectory
	Set:$$$CanSetProperty(model,"DaysBeforePurge") properties("DaysBeforePurge") = model.DaysBeforePurge
	Set:$$$CanSetProperty(model,"FileSizeLimit") properties("FileSizeLimit") = model.FileSizeLimit
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"FreezeOnError") properties("FreezeOnError") = model.FreezeOnError
	Set:$$$CanSetProperty(model,"JournalFilePrefix") properties("JournalFilePrefix") = model.JournalFilePrefix
	Set:$$$CanSetProperty(model,"JournalcspSession") properties("JournalcspSession") = model.JournalcspSession
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AlternateDirectory")) model.%Set("AlternateDirectory", properties("AlternateDirectory"), "string")
	Do:$Data(properties("BackupsBeforePurge")) model.%Set("BackupsBeforePurge", properties("BackupsBeforePurge"), "number")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("CurrentDirectory")) model.%Set("CurrentDirectory", properties("CurrentDirectory"), "string")
	Do:$Data(properties("DaysBeforePurge")) model.%Set("DaysBeforePurge", properties("DaysBeforePurge"), "number")
	Do:$Data(properties("FileSizeLimit")) model.%Set("FileSizeLimit", properties("FileSizeLimit"), "number")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("FreezeOnError")) model.%Set("FreezeOnError", properties("FreezeOnError"), "boolean")
	Do:$Data(properties("JournalFilePrefix")) model.%Set("JournalFilePrefix", properties("JournalFilePrefix"), "string")
	Do:$Data(properties("JournalcspSession")) model.%Set("JournalcspSession", properties("JournalcspSession"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Journal).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.LicenseServers">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.014011</TimeChanged>
<TimeCreated>65834,73167.014011</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.LicenseServers).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.LicenseServers).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.LicenseServers).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.LicenseServers).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.LicenseServers:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("Address") = pObj.Address
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("KeyDirectory") = pObj.KeyDirectory
	Set properties("Name") = pObj.Name
	Set properties("Port") = pObj.Port
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"Address") properties("Address") = model.Address
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"KeyDirectory") properties("KeyDirectory") = model.KeyDirectory
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Port") properties("Port") = model.Port
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("Address")) model.%Set("Address", properties("Address"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("KeyDirectory")) model.%Set("KeyDirectory", properties("KeyDirectory"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Port")) model.%Set("Port", properties("Port"), "number")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.LicenseServers).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Loader">
<Description>
Description</Description>
<TimeChanged>65834,73167.057377</TimeChanged>
<TimeCreated>65834,73167.057377</TimeCreated>

<Method name="test">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    ;d ##class(Api.Config.Services.Loader).test()
    

    Set cfg2 = {
        "Defaults":{
            "DBDIR" : "${MGRDIR}",
            "WEBAPPDIR" : "${CSPDIR}",
            "DBDATA" : "${DBDIR}myappdata/",
            "DBARCHIVE" : "${DBDIR}myapparchive/",
            "DBCODE" : "${DBDIR}myappcode/",
            "DBLOG" : "${DBDIR}myapplog/"
        },
        "SYS.Databases":{
            "${DBDATA}" : {"ExpansionSize":128},
            "${DBARCHIVE}" : {},
            "${DBCODE}" : {},
            "${DBLOG}" : {}
        },
        "Databases":{
            "MYAPPDATA" : {
                "Directory" : "${DBDATA}"
            },
            "MYAPPCODE" : {
                "Directory" : "${DBCODE}"
            },
            "MYAPPARCHIVE" : {
                "Directory" : "${DBARCHIVE}"
            },
            "MYAPPLOG" : {
                "Directory" : "${DBLOG}"
            }
        },
        "Namespaces":{
            "MYAPP": {
                "Globals":"MYAPPDATA",
                "Routines":"MYAPPCODE"
            }
        },
        "Security.Applications": {
            "/csp/zrestapp": {
                "DispatchClas" : "my.dispatch.class",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zrestapp/"
            },
            "/csp/zwebapp": {
                "Path": "${WEBAPPDIR}",
                "Namespace" : "MYAPP",
                "Enabled" : "1",
                "AuthEnabled": "64",
                "CookiePath" : "/csp/zwebapp/"
            }
        },
        "MapGlobals":{
            "MYAPP": [{
                "Name" : "Archive.Data",
                "Database" : "MYAPPARCHIVE"
            },{
                "Name" : "App.Log",
                "Database" : "MYAPPLOG"
            }]
        },
        "MapPackages": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "PackageName",
                "Database" : "USER"
            }]
        },
        "MapRoutines": {
            "MYAPP": [{
                "Namespace" : "MYAPP",
                "Name" : "RoutineName",
                "Database" : "USER"
            }]
        },
        "Journal": {
            "FreezeOnError":1
        },
        "Security.Services":{   
            "%Service_Mirror": {
                "Enabled" : 0
            }
        },
        "SQL": {
            "LockThreshold" : 2500
        },
        "config": {
            "locksiz" : 33554432
        },
        "Startup":{
            "SystemMode" : "DEVELOPMENT"
        }
    }
    zw ..Load(cfg2)
]]></Implementation>
</Method>

<Method name="Load">
<Description>
Model can be : 
* a %String with the path to the JSON Document.
* a stream contain JSON Document
* a %DynamicObject</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[model:%DynamicObject,&params]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set params=""
    ;Set:'$d(params("IFEXISTS")) params("IFEXISTS")="Update"
    Set sc = ..commonLoad(model, "Create",.params)
    Return sc
]]></Implementation>
</Method>

<Method name="Delete">
<Description>
Delete all namespaces, database, mapping, ... in configuration document.
Be careful...  (return an error on System mode LIVE.)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set startup = ##class(Api.Config.Services.Startup).Get()
    If startup.SystemMode = "LIVE" {
        Quit $$$ERROR(5001, "Not allowed on LIVE system")
    }
    Set params = ""
    Quit ..commonLoad(model, "Delete", .params)
]]></Implementation>
</Method>

<Method name="commonLoad">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[model:%DynamicObject,action:%String,&params:%Binary]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #def1arg    log(%arg)       Do ..log(%arg)
    #define     CFGCLASS(%cls)  "Api.Config.Services."_%cls    
    Set sc = $$$OK, sc2 = $$$OK

    If '$ISOBJECT(model) {  ; filename
        Do ..log("Load from file "_model_" ... ")
        If '##class(%File).Exists(model) {
            Do ..log("file not found.",0)
            Quit $$$ERROR(5001, "File not found.")
        }
        #dim file As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
        Do file.LinkToFile(model)
        Set model = {}.%FromJSON(file)
    } ElseIf model.%IsA("%Stream.Object") {
        Do ..log("Load from stream ... ")
        Set model = {}.%FromJSON(model)
    }

    
    ;If model.%IsA()
    
    $$$log("Start load configuration")
    
    Set processedConfig = ..processConfig(model)
    Set formatter=##class(%JSON.Formatter).%New()
    Set swaggerString = ""
    Do formatter.FormatToString(processedConfig, .swaggerString)
    $$$log(swaggerString)

    Set iter = processedConfig.%GetIterator()

    While iter.%GetNext(.key,.value) {
        $$$log(" * "_key)
        
        Set rAction = action
        Set isSingle = $PARAMETER($$$CFGCLASS(key),"ISSINGLE")=1
        Set isMap = $PARAMETER($$$CFGCLASS(key),"ISMAP")=1

        If isSingle { ; singleton params (only update allowed)
            
            Set:action="Create" rAction = "Update"

            $$$log("   + "_rAction _" "_key_" ... ")

            If action = "Delete" {
                $$$log("Not Allowed (skipping)",0)
                CONTINUE
            }
            
            Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, value)
            Set sc = $$$ADDSC(sc,sc2)
            $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
            CONTINUE
        }

        Set iterLvl2 = value.%GetIterator()
        While iterLvl2.%GetNext(.keyLvl2,.valueLvl2) {
            Set rAction = action

            If $PARAMETER($$$CFGCLASS(key),"UPDATEONLY") {
                Set:rAction="Create" rAction = "Update"
                If rAction="Delete" {
                    $$$log("Not Allowed (skipping)",0)
                     CONTINUE
                }
               
            }
            

            If isMap {  ; identifier with 2 properties
                
                Set pIDS = $PARAMETER($$$CFGCLASS(key),"PIDENTIFIER")
                ;Set id1 = valueLvl2.%Get($PIECE(pIDS,",",1))
                Set id1 = keyLvl2
                
                Set iterLvl3 = valueLvl2.%GetIterator()
                While iterLvl3.%GetNext(.keyLvl3,.valueLvl3) {
                    Do valueLvl3.%Set($PIECE(pIDS,",",1),id1)
                    Set id2 = valueLvl3.%Get($PIECE(pIDS,",",2))

                    $$$log("   + "_rAction _" " _ id1 _ " " _ id2 _ " ... ")
                    Set exists = $CLASSMETHOD($$$CFGCLASS(key),"Exists",id1, id2)

                    If rAction="Delete" && 'exists {
                        $$$log("Does not exists (skipping)",0)
                        CONTINUE
                    }

                    If rAction="Create" && exists {
                        If $Get(params("IFEXISTS"))="Update" {
                            $$$log("Already exists (updating) ",0)
                            Set rAction = "Update"
                        } Else {
                            $$$log("Already exists (skipping)",0)
                            CONTINUE
                        }
                    }

                    If rAction = "Delete" {
                        Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, id1, id2)
                    } Else {
                        Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl3)
                    }
                    $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
                   
                }
                CONTINUE
            }

            Do ..SetName(key,.valueLvl2,keyLvl2)
            $$$log("   + "_rAction _" "_keyLvl2_" ... ")
            
            Set exists = $CLASSMETHOD($$$CFGCLASS(key),"Exists",keyLvl2)

            If rAction="Delete" && 'exists {
                $$$log("Does not exists (skipping)",0)
                CONTINUE
            }

            If rAction="Create" && exists {
                If $Get(params("IFEXISTS"))="Update" {
                    Set rAction = "Update"
                     $$$log("Already exists (updating) ",0)
                } Else {
                    $$$log("Already exists (skipping)",0)
                    CONTINUE
                }
            }
            
            If rAction = "Delete" {
                Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, keyLvl2)
            } Else {
                Set sc2 = $CLASSMETHOD($$$CFGCLASS(key), rAction, valueLvl2)
            }

            $$$log($SYSTEM.Status.GetOneErrorText(sc2),0)
        }
    }

    Return sc
]]></Implementation>
</Method>

<Method name="SetName">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[key:%String,&model:%DynamicObject,keyLvl2:%String]]></FormalSpec>
<Implementation><![CDATA[
    Set nameProperty = $PARAMETER("Api.Config.Services."_key,"PNAME")
    If nameProperty="" {
        Set model.Name = keyLvl2
        Quit
    }
    Do model.%Set(nameProperty, keyLvl2)
    Quit
]]></Implementation>
</Method>

<Method name="log">
<Description>
Description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String,newLine:%Boolean=$$$YES,dtOnNewLine:%Boolean=$$$YES</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Write:newLine !
    Write:newLine&&dtOnNewLine $zdatetime($h,3,1), " "
    Write msg
    Return sc
]]></Implementation>
</Method>

<Method name="export">
<Description>
OnlyNotDefaultValue : properties with the default value won't exported.  
toFile : if you want to export to a file, fill toFile argument with the filepath.  </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filter:%DynamicObject={{}},OnlyNotDefaultValue:%Boolean=1,toFile:%String=""</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    ; Do ##class(Api.Config.Services.Loader).export()
    #define     CFGCLASS(%cls)  "Api.Config.Services."_%cls

    #dim export As %DynamicObject = {}

    #dim processedFilter As %DynamicObject = ..processConfig(filter)
    
    Set iter = processedFilter.%GetIterator()

    While iter.%GetNext(.key,.value) {
        
        Set isSingle = $PARAMETER($$$CFGCLASS(key),"ISSINGLE")=1
        Set isMap = $PARAMETER($$$CFGCLASS(key),"ISMAP")=1

        If isSingle { ; 

            Set params = $CLASSMETHOD($$$CFGCLASS(key),"Get")
            Do:OnlyNotDefaultValue ..removeDefaultValue(key,.params)
            Do ..ApplyFilter(value,.params)
            Do export.%Set(key, params)
            CONTINUE

        }

        Set tmpObj = {}
        Do export.%Set(key,tmpObj)

        If isMap {
            Set lvl2keyProp = $PIECE($PARAMETER($$$CFGCLASS(key),"PIDENTIFIER"),",",1)
            CONTINUE:'$ISOBJECT(value)
            
            Set iterList = value.%GetIterator(), lst = []
            While iterList.%GetNext(.keylist,.vl) {
                Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List",keylist) 
                Do tmpObj.%Set(keylist, lst)
            }

            CONTINUE
        }

        
        Set lst = [], lvl2keyProp = $PARAMETER($$$CFGCLASS(key),"PNAME")
        Set:lvl2keyProp="" lvl2keyProp="Name"
        
        If $ISOBJECT(value) {

            Set iterList = value.%GetIterator()
            While iterList.%GetNext(.keylist,.vl) {
                
                If $CLASSMETHOD($$$CFGCLASS(key),"Exists",keylist) {
                    Do lst.%Push($CLASSMETHOD($$$CFGCLASS(key),"Get",keylist))
                }
                
            }

        } Else {
            Set lst = $CLASSMETHOD($$$CFGCLASS(key),"List")
        }

        Set iterList = lst.%GetIterator()
        While iterList.%GetNext(.keylist,.vl) {
            Do tmpObj.%Set($Property(vl,lvl2keyProp), vl)
            Do:OnlyNotDefaultValue ..removeDefaultValue(key,.vl)
        }
    }

    Set formatter=##class(%JSON.Formatter).%New()
    Set exportStr = ""
    Do formatter.FormatToString(export, .exportStr)
    
    If toFile '= "" {
        Do ..toFile(export, toFile)
    }

    Quit export
]]></Implementation>
</Method>

<Method name="ApplyFilter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filter:%DynamicObject,&model:%DynamicObject]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
    if '$ISOBJECT(filter) {
        Quit $$$OK
    }

    Set iter = model.%GetIterator()

    While iter.%GetNext(.key,.value) {
        Do:'filter.%IsDefined(key) model.%Remove(key)
    }

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeDefaultValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,model:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    If key [ "." {
        Set className = key
    } Else {
        Set className = "Config."_key
    }

    New $NAMESPACE
    Set ns = $NAMESPACE, $NAMESPACE = "%SYS"
    Set obj = $CLASSMETHOD(className,"%New")
    Try {
        Set iter = model.%GetIterator()
        While iter.%GetNext(.property,.value) {
            If ##class(%Dictionary.CompiledProperty).%ExistsId(className_"||"_property) {
                
                If $PROPERTY(obj,property)=$PROPERTY(model,property) {
                    Do model.%Remove(property)
                }
            }
        }
    } Catch(ex) {
        Set sc = ex.AsStatus()
    }
    Set $NAMESPACE = ns

    Quit sc
]]></Implementation>
</Method>

<Method name="processConfig">
<ClassMethod>1</ClassMethod>
<FormalSpec>config:%DynamicObject</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    Set:'$ISOBJECT(config.Defaults) config.Defaults = {}
	
	Set processedConfig = config.%ToJSON()
	
	Set installDir = ##class(%File).GetDirectory($zu(86))
	
	Set replaceString("${MGRDIR}") = $SYSTEM.Util.ManagerDirectory()
	Set replaceString("${CSPDIR}") = ##class(%File).NormalizeDirectory("csp", installDir)
	
	#dim iter As %Iterator.Object = config.Defaults.%GetIterator()
	
	While iter.%GetNext(.property, .value) {
		Set replaceString( "${"_property_"}" ) = value
	}
	
	Do {
		Set i = $Increment(i), var = ""
		
		For  {
			Set var = $Order(replaceString(var), 1, value)
			Quit:var=""
			Set processedConfig = $Replace(processedConfig, var, $zconvert(value,"O","JS"))
		}
		
	} While (i < 3)	
	
    Set model = {}.%FromJSON(processedConfig)
    Do model.%Remove("Defaults")
    Quit model
]]></Implementation>
</Method>

<Method name="toFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%DynamicObject,filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set dir = ##class(%File).GetDirectory(filename)
    
    If '##class(%File).DirectoryExists(dir) {
        Set created = ##class(%File).CreateDirectoryChain(dir)
        Quit:'created $$$ERROR(5001, "Fail to create directory chain")
    }

    Set configString = object.%ToJSON()
    Set formatter=##class(%JSON.Formatter).%New()
    Do formatter.FormatToString(object, .configString)

    #dim file As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
    $$$QuitOnError(file.LinkToFile(filename))
    Do file.Write(configString)
    Quit file.%Save()
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MagTapes">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.030885</TimeChanged>
<TimeCreated>65834,73167.030885</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.SystemDevice="" sc = $$$ADDSC(sc,$$$ERROR(5001, "SystemDevice property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MagTapes).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MagTapes).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MagTapes).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MagTapes).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.MagTapes:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("SystemDevice") = pObj.SystemDevice
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"SystemDevice") properties("SystemDevice") = model.SystemDevice
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("SystemDevice")) model.%Set("SystemDevice", properties("SystemDevice"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MagTapes).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapGlobals">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.062866</TimeChanged>
<TimeCreated>65834,73167.062866</TimeCreated>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapGlobals).Get(Namespace,Name,.properties))
	Set properties("Name") = Name, properties("Namespace") = Namespace
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*",CPFFile:%String="",Flags:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.MapGlobals:List")
		Do rs.Execute(Namespace,Names,CPFFile,Flags)
		While rs.Next() {
			Do list.%Push(..Get(Namespace, rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Collation") = pObj.Collation
	Set properties("Comments") = pObj.Comments
	Set properties("Database") = pObj.Database
	Set properties("Flags") = pObj.Flags
	Set properties("LockDatabase") = pObj.LockDatabase
	Set properties("Name") = pObj.Name
	Set properties("Namespace") = pObj.Namespace
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Collation") properties("Collation") = model.Collation
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Database") properties("Database") = model.Database
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"LockDatabase") properties("LockDatabase") = model.LockDatabase
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Namespace") properties("Namespace") = model.Namespace
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Collation")) model.%Set("Collation", properties("Collation"), "number")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Database")) model.%Set("Database", properties("Database"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("LockDatabase")) model.%Set("LockDatabase", properties("LockDatabase"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Namespace")) model.%Set("Namespace", properties("Namespace"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapGlobals).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapMirrors">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.04327</TimeChanged>
<TimeCreated>65834,73167.04327</TimeCreated>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>ID,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.GUID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "GUID property is mandatory."))
	Set:model.ID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "ID property is mandatory."))
	Set:model.InstanceDirectory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "InstanceDirectory property is mandatory."))
	Set:model.MirrorAddress="" sc = $$$ADDSC(sc,$$$ERROR(5001, "MirrorAddress property is mandatory."))
	Set:model.MirrorSSPort="" sc = $$$ADDSC(sc,$$$ERROR(5001, "MirrorSSPort property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Create(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Delete(ID,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Exists(ID,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(ID,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapMirrors).Get(ID,Name,.properties))
	Set properties("ID") = ID, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.MapMirrors:List")
		Do rs.Execute(ID,Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(ID, rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AgentAddress") = pObj.AgentAddress
	Set properties("AgentPort") = pObj.AgentPort
	Set properties("AsyncMemberType") = pObj.AsyncMemberType
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("ConnectsTo") = pObj.ConnectsTo
	Set properties("DejournalFilter") = pObj.DejournalFilter
	Set properties("ECPAddress") = pObj.ECPAddress
	Set properties("EncryptCommunication") = pObj.EncryptCommunication
	Set properties("Flags") = pObj.Flags
	Set properties("GUID") = pObj.GUID
	Set properties("ID") = pObj.ID
	Set properties("InstanceDirectory") = pObj.InstanceDirectory
	Set properties("MemberType") = pObj.MemberType
	Set properties("MirrorAddress") = pObj.MirrorAddress
	Set properties("MirrorSSPort") = pObj.MirrorSSPort
	Set properties("Name") = pObj.Name
	Set properties("SSLComputerName") = pObj.SSLComputerName
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AgentAddress") properties("AgentAddress") = model.AgentAddress
	Set:$$$CanSetProperty(model,"AgentPort") properties("AgentPort") = model.AgentPort
	Set:$$$CanSetProperty(model,"AsyncMemberType") properties("AsyncMemberType") = model.AsyncMemberType
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"ConnectsTo") properties("ConnectsTo") = model.ConnectsTo
	Set:$$$CanSetProperty(model,"DejournalFilter") properties("DejournalFilter") = model.DejournalFilter
	Set:$$$CanSetProperty(model,"ECPAddress") properties("ECPAddress") = model.ECPAddress
	Set:$$$CanSetProperty(model,"EncryptCommunication") properties("EncryptCommunication") = model.EncryptCommunication
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"GUID") properties("GUID") = model.GUID
	Set:$$$CanSetProperty(model,"ID") properties("ID") = model.ID
	Set:$$$CanSetProperty(model,"InstanceDirectory") properties("InstanceDirectory") = model.InstanceDirectory
	Set:$$$CanSetProperty(model,"MemberType") properties("MemberType") = model.MemberType
	Set:$$$CanSetProperty(model,"MirrorAddress") properties("MirrorAddress") = model.MirrorAddress
	Set:$$$CanSetProperty(model,"MirrorSSPort") properties("MirrorSSPort") = model.MirrorSSPort
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"SSLComputerName") properties("SSLComputerName") = model.SSLComputerName
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AgentAddress")) model.%Set("AgentAddress", properties("AgentAddress"), "string")
	Do:$Data(properties("AgentPort")) model.%Set("AgentPort", properties("AgentPort"), "number")
	Do:$Data(properties("AsyncMemberType")) model.%Set("AsyncMemberType", properties("AsyncMemberType"), "number")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("ConnectsTo")) model.%Set("ConnectsTo", properties("ConnectsTo"), "string")
	Do:$Data(properties("DejournalFilter")) model.%Set("DejournalFilter", properties("DejournalFilter"), "string")
	Do:$Data(properties("ECPAddress")) model.%Set("ECPAddress", properties("ECPAddress"), "string")
	Do:$Data(properties("EncryptCommunication")) model.%Set("EncryptCommunication", properties("EncryptCommunication"), "number")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("GUID")) model.%Set("GUID", properties("GUID"), "string")
	Do:$Data(properties("ID")) model.%Set("ID", properties("ID"), "string")
	Do:$Data(properties("InstanceDirectory")) model.%Set("InstanceDirectory", properties("InstanceDirectory"), "string")
	Do:$Data(properties("MemberType")) model.%Set("MemberType", properties("MemberType"), "number")
	Do:$Data(properties("MirrorAddress")) model.%Set("MirrorAddress", properties("MirrorAddress"), "string")
	Do:$Data(properties("MirrorSSPort")) model.%Set("MirrorSSPort", properties("MirrorSSPort"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("SSLComputerName")) model.%Set("SSLComputerName", properties("SSLComputerName"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapMirrors).Modify(model.ID,model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapPackages">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.055024</TimeChanged>
<TimeCreated>65834,73167.055024</TimeCreated>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapPackages).Get(Namespace,Name,.properties))
	Set properties("Namespace") = Namespace, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*",CPFFile:%String="",Flags:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.MapPackages:List")
		Do rs.Execute(Namespace,Names,CPFFile,Flags)
		While rs.Next() {
			Do list.%Push(..Get(Namespace, rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Database") = pObj.Database
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("Namespace") = pObj.Namespace
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Database") properties("Database") = model.Database
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Namespace") properties("Namespace") = model.Namespace
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Database")) model.%Set("Database", properties("Database"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Namespace")) model.%Set("Namespace", properties("Namespace"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapPackages).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapRoutines">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.091466</TimeChanged>
<TimeCreated>65834,73167.091466</TimeCreated>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>Namespace,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Database="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Database property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Namespace="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Namespace property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Create(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Delete(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Exists(Namespace,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Namespace,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapRoutines).Get(Namespace,Name,.properties))
	Set properties("Namespace") = Namespace, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Names:%String="*",CPFFile:%String="",Flags:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.MapRoutines:List")
		Do rs.Execute(Namespace,Names,CPFFile,Flags)
		While rs.Next() {
			Do list.%Push(..Get(Namespace, rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Database") = pObj.Database
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("Namespace") = pObj.Namespace
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Database") properties("Database") = model.Database
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Namespace") properties("Namespace") = model.Namespace
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Database")) model.%Set("Database", properties("Database"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Namespace")) model.%Set("Namespace", properties("Namespace"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapRoutines).Modify(model.Namespace,model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MapShadows">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.081542</TimeChanged>
<TimeCreated>65834,73167.081542</TimeCreated>

<Parameter name="ISMAP">
<Default>1</Default>
</Parameter>

<Parameter name="PIDENTIFIER">
<Default>ID,Name</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Directory="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Directory property is mandatory."))
	Set:model.ID="" sc = $$$ADDSC(sc,$$$ERROR(5001, "ID property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Create(model.ID,model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Delete(ID,Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Exists(ID,Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(ID,Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MapShadows).Get(ID,Name,.properties))
	Set properties("ID") = ID, properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>ID:%String,Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.MapShadows:List")
		Do rs.Execute(ID,Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(ID, rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Directory") = pObj.Directory
	Set properties("Flags") = pObj.Flags
	Set properties("ID") = pObj.ID
	Set properties("Name") = pObj.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Directory") properties("Directory") = model.Directory
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"ID") properties("ID") = model.ID
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Directory")) model.%Set("Directory", properties("Directory"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("ID")) model.%Set("ID", properties("ID"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MapShadows).Modify(model.ID,model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.MirrorMember">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.107854</TimeChanged>
<TimeCreated>65834,73167.107854</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.MirrorMember).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AgentAddress") = pObj.AgentAddress
	Set properties("AsyncMemberGUID") = pObj.AsyncMemberGUID
	Set properties("AsyncMemberType") = pObj.AsyncMemberType
	Set properties("AsyncUseSystemPurgeInterval") = pObj.AsyncUseSystemPurgeInterval
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("JoinMirror") = pObj.JoinMirror
	Set properties("Name") = pObj.Name
	Set properties("SystemName") = pObj.SystemName
	Set properties("VirtualAddressInterface") = pObj.VirtualAddressInterface
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AgentAddress") properties("AgentAddress") = model.AgentAddress
	Set:$$$CanSetProperty(model,"AsyncMemberGUID") properties("AsyncMemberGUID") = model.AsyncMemberGUID
	Set:$$$CanSetProperty(model,"AsyncMemberType") properties("AsyncMemberType") = model.AsyncMemberType
	Set:$$$CanSetProperty(model,"AsyncUseSystemPurgeInterval") properties("AsyncUseSystemPurgeInterval") = model.AsyncUseSystemPurgeInterval
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"JoinMirror") properties("JoinMirror") = model.JoinMirror
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"SystemName") properties("SystemName") = model.SystemName
	Set:$$$CanSetProperty(model,"VirtualAddressInterface") properties("VirtualAddressInterface") = model.VirtualAddressInterface
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AgentAddress")) model.%Set("AgentAddress", properties("AgentAddress"), "string")
	Do:$Data(properties("AsyncMemberGUID")) model.%Set("AsyncMemberGUID", properties("AsyncMemberGUID"), "string")
	Do:$Data(properties("AsyncMemberType")) model.%Set("AsyncMemberType", properties("AsyncMemberType"), "number")
	Do:$Data(properties("AsyncUseSystemPurgeInterval")) model.%Set("AsyncUseSystemPurgeInterval", properties("AsyncUseSystemPurgeInterval"), "boolean")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("JoinMirror")) model.%Set("JoinMirror", properties("JoinMirror"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("SystemName")) model.%Set("SystemName", properties("SystemName"), "string")
	Do:$Data(properties("VirtualAddressInterface")) model.%Set("VirtualAddressInterface", properties("VirtualAddressInterface"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.MirrorMember).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Mirrors">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.115523</TimeChanged>
<TimeCreated>65834,73167.115523</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Mirrors).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Mirrors).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Mirrors).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Mirrors).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.Mirrors:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AllowParallelDejournaling") = pObj.AllowParallelDejournaling
	Set properties("ArbiterNode") = pObj.ArbiterNode
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("CompressionForAsyncMembers") = pObj.CompressionForAsyncMembers
	Set properties("CompressionForFailoverMembers") = pObj.CompressionForFailoverMembers
	Set properties("CompressionTypeForAsyncMembers") = pObj.CompressionTypeForAsyncMembers
	Set properties("CompressionTypeForFailoverMembers") = pObj.CompressionTypeForFailoverMembers
	Set properties("DefinedPrimary") = pObj.DefinedPrimary
	Set properties("Flags") = pObj.Flags
	Set properties("GUID") = pObj.GUID
	Set properties("Name") = pObj.Name
	Set properties("QOSTimeout") = pObj.QOSTimeout
	Set properties("UseSSL") = pObj.UseSSL
	Set properties("VirtualAddress") = pObj.VirtualAddress
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AllowParallelDejournaling") properties("AllowParallelDejournaling") = model.AllowParallelDejournaling
	Set:$$$CanSetProperty(model,"ArbiterNode") properties("ArbiterNode") = model.ArbiterNode
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"CompressionForAsyncMembers") properties("CompressionForAsyncMembers") = model.CompressionForAsyncMembers
	Set:$$$CanSetProperty(model,"CompressionForFailoverMembers") properties("CompressionForFailoverMembers") = model.CompressionForFailoverMembers
	Set:$$$CanSetProperty(model,"CompressionTypeForAsyncMembers") properties("CompressionTypeForAsyncMembers") = model.CompressionTypeForAsyncMembers
	Set:$$$CanSetProperty(model,"CompressionTypeForFailoverMembers") properties("CompressionTypeForFailoverMembers") = model.CompressionTypeForFailoverMembers
	Set:$$$CanSetProperty(model,"DefinedPrimary") properties("DefinedPrimary") = model.DefinedPrimary
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"GUID") properties("GUID") = model.GUID
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"QOSTimeout") properties("QOSTimeout") = model.QOSTimeout
	Set:$$$CanSetProperty(model,"UseSSL") properties("UseSSL") = model.UseSSL
	Set:$$$CanSetProperty(model,"VirtualAddress") properties("VirtualAddress") = model.VirtualAddress
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AllowParallelDejournaling")) model.%Set("AllowParallelDejournaling", properties("AllowParallelDejournaling"), "number")
	Do:$Data(properties("ArbiterNode")) model.%Set("ArbiterNode", properties("ArbiterNode"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("CompressionForAsyncMembers")) model.%Set("CompressionForAsyncMembers", properties("CompressionForAsyncMembers"), "number")
	Do:$Data(properties("CompressionForFailoverMembers")) model.%Set("CompressionForFailoverMembers", properties("CompressionForFailoverMembers"), "number")
	Do:$Data(properties("CompressionTypeForAsyncMembers")) model.%Set("CompressionTypeForAsyncMembers", properties("CompressionTypeForAsyncMembers"), "number")
	Do:$Data(properties("CompressionTypeForFailoverMembers")) model.%Set("CompressionTypeForFailoverMembers", properties("CompressionTypeForFailoverMembers"), "number")
	Do:$Data(properties("DefinedPrimary")) model.%Set("DefinedPrimary", properties("DefinedPrimary"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("GUID")) model.%Set("GUID", properties("GUID"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("QOSTimeout")) model.%Set("QOSTimeout", properties("QOSTimeout"), "number")
	Do:$Data(properties("UseSSL")) model.%Set("UseSSL", properties("UseSSL"), "boolean")
	Do:$Data(properties("VirtualAddress")) model.%Set("VirtualAddress", properties("VirtualAddress"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Mirrors).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Miscellaneous">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.10914</TimeChanged>
<TimeCreated>65834,73167.10914</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Miscellaneous).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AsyncDisconnectErr") = pObj.AsyncDisconnectErr
	Set properties("AsynchError") = pObj.AsynchError
	Set properties("BreakMode") = pObj.BreakMode
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("CollectResourceStats") = pObj.CollectResourceStats
	Set properties("Comments") = pObj.Comments
	Set properties("DX") = pObj.DX
	Set properties("DisconnectErr") = pObj.DisconnectErr
	Set properties("FileMode") = pObj.FileMode
	Set properties("Flags") = pObj.Flags
	Set properties("GlobalKillEnabled") = pObj.GlobalKillEnabled
	Set properties("IEEEError") = pObj.IEEEError
	Set properties("LineRecall") = pObj.LineRecall
	Set properties("ListFormat") = pObj.ListFormat
	Set properties("LogRollback") = pObj.LogRollback
	Set properties("MVDefined") = pObj.MVDefined
	Set properties("Name") = pObj.Name
	Set properties("NodeNameInPid") = pObj.NodeNameInPid
	Set properties("NullSubscripts") = pObj.NullSubscripts
	Set properties("OldZU5") = pObj.OldZU5
	Set properties("OpenMode") = pObj.OpenMode
	Set properties("PopError") = pObj.PopError
	Set properties("RefInKind") = pObj.RefInKind
	Set properties("ScientificNotation") = pObj.ScientificNotation
	Set properties("SetZEOF") = pObj.SetZEOF
	Set properties("ShutDownLogErrors") = pObj.ShutDownLogErrors
	Set properties("StopID") = pObj.StopID
	Set properties("SwitchOSdir") = pObj.SwitchOSdir
	Set properties("SynchCommit") = pObj.SynchCommit
	Set properties("TelnetNUL") = pObj.TelnetNUL
	Set properties("TruncateOverflow") = pObj.TruncateOverflow
	Set properties("Undefined") = pObj.Undefined
	Set properties("UseNagleAlgorithm") = pObj.UseNagleAlgorithm
	Set properties("ViewPastData") = pObj.ViewPastData
	Set properties("ZDateNull") = pObj.ZDateNull
	Set properties("ZaMode") = pObj.ZaMode
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AsyncDisconnectErr") properties("AsyncDisconnectErr") = model.AsyncDisconnectErr
	Set:$$$CanSetProperty(model,"AsynchError") properties("AsynchError") = model.AsynchError
	Set:$$$CanSetProperty(model,"BreakMode") properties("BreakMode") = model.BreakMode
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"CollectResourceStats") properties("CollectResourceStats") = model.CollectResourceStats
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"DX") properties("DX") = model.DX
	Set:$$$CanSetProperty(model,"DisconnectErr") properties("DisconnectErr") = model.DisconnectErr
	Set:$$$CanSetProperty(model,"FileMode") properties("FileMode") = model.FileMode
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"GlobalKillEnabled") properties("GlobalKillEnabled") = model.GlobalKillEnabled
	Set:$$$CanSetProperty(model,"IEEEError") properties("IEEEError") = model.IEEEError
	Set:$$$CanSetProperty(model,"LineRecall") properties("LineRecall") = model.LineRecall
	Set:$$$CanSetProperty(model,"ListFormat") properties("ListFormat") = model.ListFormat
	Set:$$$CanSetProperty(model,"LogRollback") properties("LogRollback") = model.LogRollback
	Set:$$$CanSetProperty(model,"MVDefined") properties("MVDefined") = model.MVDefined
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"NodeNameInPid") properties("NodeNameInPid") = model.NodeNameInPid
	Set:$$$CanSetProperty(model,"NullSubscripts") properties("NullSubscripts") = model.NullSubscripts
	Set:$$$CanSetProperty(model,"OldZU5") properties("OldZU5") = model.OldZU5
	Set:$$$CanSetProperty(model,"OpenMode") properties("OpenMode") = model.OpenMode
	Set:$$$CanSetProperty(model,"PopError") properties("PopError") = model.PopError
	Set:$$$CanSetProperty(model,"RefInKind") properties("RefInKind") = model.RefInKind
	Set:$$$CanSetProperty(model,"ScientificNotation") properties("ScientificNotation") = model.ScientificNotation
	Set:$$$CanSetProperty(model,"SetZEOF") properties("SetZEOF") = model.SetZEOF
	Set:$$$CanSetProperty(model,"ShutDownLogErrors") properties("ShutDownLogErrors") = model.ShutDownLogErrors
	Set:$$$CanSetProperty(model,"StopID") properties("StopID") = model.StopID
	Set:$$$CanSetProperty(model,"SwitchOSdir") properties("SwitchOSdir") = model.SwitchOSdir
	Set:$$$CanSetProperty(model,"SynchCommit") properties("SynchCommit") = model.SynchCommit
	Set:$$$CanSetProperty(model,"TelnetNUL") properties("TelnetNUL") = model.TelnetNUL
	Set:$$$CanSetProperty(model,"TruncateOverflow") properties("TruncateOverflow") = model.TruncateOverflow
	Set:$$$CanSetProperty(model,"Undefined") properties("Undefined") = model.Undefined
	Set:$$$CanSetProperty(model,"UseNagleAlgorithm") properties("UseNagleAlgorithm") = model.UseNagleAlgorithm
	Set:$$$CanSetProperty(model,"ViewPastData") properties("ViewPastData") = model.ViewPastData
	Set:$$$CanSetProperty(model,"ZDateNull") properties("ZDateNull") = model.ZDateNull
	Set:$$$CanSetProperty(model,"ZaMode") properties("ZaMode") = model.ZaMode
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AsyncDisconnectErr")) model.%Set("AsyncDisconnectErr", properties("AsyncDisconnectErr"), "boolean")
	Do:$Data(properties("AsynchError")) model.%Set("AsynchError", properties("AsynchError"), "boolean")
	Do:$Data(properties("BreakMode")) model.%Set("BreakMode", properties("BreakMode"), "boolean")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("CollectResourceStats")) model.%Set("CollectResourceStats", properties("CollectResourceStats"), "boolean")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("DX")) model.%Set("DX", properties("DX"), "boolean")
	Do:$Data(properties("DisconnectErr")) model.%Set("DisconnectErr", properties("DisconnectErr"), "boolean")
	Do:$Data(properties("FileMode")) model.%Set("FileMode", properties("FileMode"), "boolean")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("GlobalKillEnabled")) model.%Set("GlobalKillEnabled", properties("GlobalKillEnabled"), "boolean")
	Do:$Data(properties("IEEEError")) model.%Set("IEEEError", properties("IEEEError"), "boolean")
	Do:$Data(properties("LineRecall")) model.%Set("LineRecall", properties("LineRecall"), "boolean")
	Do:$Data(properties("ListFormat")) model.%Set("ListFormat", properties("ListFormat"), "number")
	Do:$Data(properties("LogRollback")) model.%Set("LogRollback", properties("LogRollback"), "boolean")
	Do:$Data(properties("MVDefined")) model.%Set("MVDefined", properties("MVDefined"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("NodeNameInPid")) model.%Set("NodeNameInPid", properties("NodeNameInPid"), "boolean")
	Do:$Data(properties("NullSubscripts")) model.%Set("NullSubscripts", properties("NullSubscripts"), "boolean")
	Do:$Data(properties("OldZU5")) model.%Set("OldZU5", properties("OldZU5"), "boolean")
	Do:$Data(properties("OpenMode")) model.%Set("OpenMode", properties("OpenMode"), "number")
	Do:$Data(properties("PopError")) model.%Set("PopError", properties("PopError"), "boolean")
	Do:$Data(properties("RefInKind")) model.%Set("RefInKind", properties("RefInKind"), "boolean")
	Do:$Data(properties("ScientificNotation")) model.%Set("ScientificNotation", properties("ScientificNotation"), "boolean")
	Do:$Data(properties("SetZEOF")) model.%Set("SetZEOF", properties("SetZEOF"), "boolean")
	Do:$Data(properties("ShutDownLogErrors")) model.%Set("ShutDownLogErrors", properties("ShutDownLogErrors"), "boolean")
	Do:$Data(properties("StopID")) model.%Set("StopID", properties("StopID"), "boolean")
	Do:$Data(properties("SwitchOSdir")) model.%Set("SwitchOSdir", properties("SwitchOSdir"), "boolean")
	Do:$Data(properties("SynchCommit")) model.%Set("SynchCommit", properties("SynchCommit"), "boolean")
	Do:$Data(properties("TelnetNUL")) model.%Set("TelnetNUL", properties("TelnetNUL"), "boolean")
	Do:$Data(properties("TruncateOverflow")) model.%Set("TruncateOverflow", properties("TruncateOverflow"), "boolean")
	Do:$Data(properties("Undefined")) model.%Set("Undefined", properties("Undefined"), "number")
	Do:$Data(properties("UseNagleAlgorithm")) model.%Set("UseNagleAlgorithm", properties("UseNagleAlgorithm"), "boolean")
	Do:$Data(properties("ViewPastData")) model.%Set("ViewPastData", properties("ViewPastData"), "boolean")
	Do:$Data(properties("ZDateNull")) model.%Set("ZDateNull", properties("ZDateNull"), "boolean")
	Do:$Data(properties("ZaMode")) model.%Set("ZaMode", properties("ZaMode"), "boolean")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Miscellaneous).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Monitor">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.128262</TimeChanged>
<TimeCreated>65834,73167.128262</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Monitor).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("PatrolCollectionInterval") = pObj.PatrolCollectionInterval
	Set properties("PatrolDisplayMode") = pObj.PatrolDisplayMode
	Set properties("PatrolEnabled") = pObj.PatrolEnabled
	Set properties("PatrolTopProcesses") = pObj.PatrolTopProcesses
	Set properties("SNMPEnabled") = pObj.SNMPEnabled
	Set properties("WMIEnabled") = pObj.WMIEnabled
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"PatrolCollectionInterval") properties("PatrolCollectionInterval") = model.PatrolCollectionInterval
	Set:$$$CanSetProperty(model,"PatrolDisplayMode") properties("PatrolDisplayMode") = model.PatrolDisplayMode
	Set:$$$CanSetProperty(model,"PatrolEnabled") properties("PatrolEnabled") = model.PatrolEnabled
	Set:$$$CanSetProperty(model,"PatrolTopProcesses") properties("PatrolTopProcesses") = model.PatrolTopProcesses
	Set:$$$CanSetProperty(model,"SNMPEnabled") properties("SNMPEnabled") = model.SNMPEnabled
	Set:$$$CanSetProperty(model,"WMIEnabled") properties("WMIEnabled") = model.WMIEnabled
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("PatrolCollectionInterval")) model.%Set("PatrolCollectionInterval", properties("PatrolCollectionInterval"), "number")
	Do:$Data(properties("PatrolDisplayMode")) model.%Set("PatrolDisplayMode", properties("PatrolDisplayMode"), "number")
	Do:$Data(properties("PatrolEnabled")) model.%Set("PatrolEnabled", properties("PatrolEnabled"), "boolean")
	Do:$Data(properties("PatrolTopProcesses")) model.%Set("PatrolTopProcesses", properties("PatrolTopProcesses"), "number")
	Do:$Data(properties("SNMPEnabled")) model.%Set("SNMPEnabled", properties("SNMPEnabled"), "boolean")
	Do:$Data(properties("WMIEnabled")) model.%Set("WMIEnabled", properties("WMIEnabled"), "boolean")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Monitor).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Namespaces">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.152603</TimeChanged>
<TimeCreated>65834,73167.152603</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Globals="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Globals property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Set:model.Routines="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Routines property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Namespaces).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Namespaces).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Namespaces).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Namespaces).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.Namespaces:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Namespace")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Flags") = pObj.Flags
	Set properties("Globals") = pObj.Globals
	Set properties("Name") = pObj.Name
	Set properties("Routines") = pObj.Routines
	Set properties("TempGlobals") = pObj.TempGlobals
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Globals") properties("Globals") = model.Globals
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Routines") properties("Routines") = model.Routines
	Set:$$$CanSetProperty(model,"TempGlobals") properties("TempGlobals") = model.TempGlobals
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Globals")) model.%Set("Globals", properties("Globals"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Routines")) model.%Set("Routines", properties("Routines"), "string")
	Do:$Data(properties("TempGlobals")) model.%Set("TempGlobals", properties("TempGlobals"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Namespaces).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SQL">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.166722</TimeChanged>
<TimeCreated>65834,73167.166722</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.SQL).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("ANSIPrecedence") = pObj.ANSIPrecedence
	Set properties("AllowRowIDUpdate") = pObj.AllowRowIDUpdate
	Set properties("AutoParallel") = pObj.AutoParallel
	Set properties("AutoParallelThreshold") = pObj.AutoParallelThreshold
	Set properties("BiasQueriesAsOutlier") = pObj.BiasQueriesAsOutlier
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comment") = pObj.Comment
	Set properties("Comments") = pObj.Comments
	Set properties("DBMSSecurity") = pObj.DBMSSecurity
	Set properties("DDLDefineBitmapExtent") = pObj.DDLDefineBitmapExtent
	Set properties("DDLFinal") = pObj.DDLFinal
	Set properties("DDLNo201") = pObj.DDLNo201
	Set properties("DDLNo30") = pObj.DDLNo30
	Set properties("DDLNo307") = pObj.DDLNo307
	Set properties("DDLNo311") = pObj.DDLNo311
	Set properties("DDLNo315") = pObj.DDLNo315
	Set properties("DDLNo324") = pObj.DDLNo324
	Set properties("DDLNo333") = pObj.DDLNo333
	Set properties("DDLSQLOnlyCompile") = pObj.DDLSQLOnlyCompile
	Set properties("DDLUseExtentSet") = pObj.DDLUseExtentSet
	Set properties("DDLUseSequence") = pObj.DDLUseSequence
	Set properties("DefaultSchema") = pObj.DefaultSchema
	Set properties("DelimitedIds") = pObj.DelimitedIds
	Set properties("DropDelete") = pObj.DropDelete
	Set properties("ECPSync") = pObj.ECPSync
	Set properties("ExtrinsicFunctions") = pObj.ExtrinsicFunctions
	Set properties("FastDistinct") = pObj.FastDistinct
	Set properties("Flags") = pObj.Flags
	Set properties("IdKey") = pObj.IdKey
	Set properties("IdTrxFrom") = pObj.IdTrxFrom
	Set properties("IdTrxTo") = pObj.IdTrxTo
	Set properties("JDBCGatewayJVMArgs") = pObj.JDBCGatewayJVMArgs
	Set properties("JDBCGatewayLog") = pObj.JDBCGatewayLog
	Set properties("JDBCGatewayPort") = pObj.JDBCGatewayPort
	Set properties("JDBCGatewayUsePassphrase") = pObj.JDBCGatewayUsePassphrase
	Set properties("JavaClassPath") = pObj.JavaClassPath
	Set properties("JavaHome") = pObj.JavaHome
	Set properties("LockThreshold") = pObj.LockThreshold
	Set properties("LockTimeout") = pObj.LockTimeout
	Set properties("Name") = pObj.Name
	Set properties("ODBCVarcharMaxlen") = pObj.ODBCVarcharMaxlen
	Set properties("QueryProcedures") = pObj.QueryProcedures
	Set properties("RTPC") = pObj.RTPC
	Set properties("ReferentialChecks") = pObj.ReferentialChecks
	Set properties("SaveMAC") = pObj.SaveMAC
	Set properties("TCPKeepAlive") = pObj.TCPKeepAlive
	Set properties("TODATEDefaultFormat") = pObj.TODATEDefaultFormat
	Set properties("TimePrecision") = pObj.TimePrecision
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"ANSIPrecedence") properties("ANSIPrecedence") = model.ANSIPrecedence
	Set:$$$CanSetProperty(model,"AllowRowIDUpdate") properties("AllowRowIDUpdate") = model.AllowRowIDUpdate
	Set:$$$CanSetProperty(model,"AutoParallel") properties("AutoParallel") = model.AutoParallel
	Set:$$$CanSetProperty(model,"AutoParallelThreshold") properties("AutoParallelThreshold") = model.AutoParallelThreshold
	Set:$$$CanSetProperty(model,"BiasQueriesAsOutlier") properties("BiasQueriesAsOutlier") = model.BiasQueriesAsOutlier
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comment") properties("Comment") = model.Comment
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"DBMSSecurity") properties("DBMSSecurity") = model.DBMSSecurity
	Set:$$$CanSetProperty(model,"DDLDefineBitmapExtent") properties("DDLDefineBitmapExtent") = model.DDLDefineBitmapExtent
	Set:$$$CanSetProperty(model,"DDLFinal") properties("DDLFinal") = model.DDLFinal
	Set:$$$CanSetProperty(model,"DDLNo201") properties("DDLNo201") = model.DDLNo201
	Set:$$$CanSetProperty(model,"DDLNo30") properties("DDLNo30") = model.DDLNo30
	Set:$$$CanSetProperty(model,"DDLNo307") properties("DDLNo307") = model.DDLNo307
	Set:$$$CanSetProperty(model,"DDLNo311") properties("DDLNo311") = model.DDLNo311
	Set:$$$CanSetProperty(model,"DDLNo315") properties("DDLNo315") = model.DDLNo315
	Set:$$$CanSetProperty(model,"DDLNo324") properties("DDLNo324") = model.DDLNo324
	Set:$$$CanSetProperty(model,"DDLNo333") properties("DDLNo333") = model.DDLNo333
	Set:$$$CanSetProperty(model,"DDLSQLOnlyCompile") properties("DDLSQLOnlyCompile") = model.DDLSQLOnlyCompile
	Set:$$$CanSetProperty(model,"DDLUseExtentSet") properties("DDLUseExtentSet") = model.DDLUseExtentSet
	Set:$$$CanSetProperty(model,"DDLUseSequence") properties("DDLUseSequence") = model.DDLUseSequence
	Set:$$$CanSetProperty(model,"DefaultSchema") properties("DefaultSchema") = model.DefaultSchema
	Set:$$$CanSetProperty(model,"DelimitedIds") properties("DelimitedIds") = model.DelimitedIds
	Set:$$$CanSetProperty(model,"DropDelete") properties("DropDelete") = model.DropDelete
	Set:$$$CanSetProperty(model,"ECPSync") properties("ECPSync") = model.ECPSync
	Set:$$$CanSetProperty(model,"ExtrinsicFunctions") properties("ExtrinsicFunctions") = model.ExtrinsicFunctions
	Set:$$$CanSetProperty(model,"FastDistinct") properties("FastDistinct") = model.FastDistinct
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"IdKey") properties("IdKey") = model.IdKey
	Set:$$$CanSetProperty(model,"IdTrxFrom") properties("IdTrxFrom") = model.IdTrxFrom
	Set:$$$CanSetProperty(model,"IdTrxTo") properties("IdTrxTo") = model.IdTrxTo
	Set:$$$CanSetProperty(model,"JDBCGatewayJVMArgs") properties("JDBCGatewayJVMArgs") = model.JDBCGatewayJVMArgs
	Set:$$$CanSetProperty(model,"JDBCGatewayLog") properties("JDBCGatewayLog") = model.JDBCGatewayLog
	Set:$$$CanSetProperty(model,"JDBCGatewayPort") properties("JDBCGatewayPort") = model.JDBCGatewayPort
	Set:$$$CanSetProperty(model,"JDBCGatewayUsePassphrase") properties("JDBCGatewayUsePassphrase") = model.JDBCGatewayUsePassphrase
	Set:$$$CanSetProperty(model,"JavaClassPath") properties("JavaClassPath") = model.JavaClassPath
	Set:$$$CanSetProperty(model,"JavaHome") properties("JavaHome") = model.JavaHome
	Set:$$$CanSetProperty(model,"LockThreshold") properties("LockThreshold") = model.LockThreshold
	Set:$$$CanSetProperty(model,"LockTimeout") properties("LockTimeout") = model.LockTimeout
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"ODBCVarcharMaxlen") properties("ODBCVarcharMaxlen") = model.ODBCVarcharMaxlen
	Set:$$$CanSetProperty(model,"QueryProcedures") properties("QueryProcedures") = model.QueryProcedures
	Set:$$$CanSetProperty(model,"RTPC") properties("RTPC") = model.RTPC
	Set:$$$CanSetProperty(model,"ReferentialChecks") properties("ReferentialChecks") = model.ReferentialChecks
	Set:$$$CanSetProperty(model,"SaveMAC") properties("SaveMAC") = model.SaveMAC
	Set:$$$CanSetProperty(model,"TCPKeepAlive") properties("TCPKeepAlive") = model.TCPKeepAlive
	Set:$$$CanSetProperty(model,"TODATEDefaultFormat") properties("TODATEDefaultFormat") = model.TODATEDefaultFormat
	Set:$$$CanSetProperty(model,"TimePrecision") properties("TimePrecision") = model.TimePrecision
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("ANSIPrecedence")) model.%Set("ANSIPrecedence", properties("ANSIPrecedence"), "boolean")
	Do:$Data(properties("AllowRowIDUpdate")) model.%Set("AllowRowIDUpdate", properties("AllowRowIDUpdate"), "boolean")
	Do:$Data(properties("AutoParallel")) model.%Set("AutoParallel", properties("AutoParallel"), "boolean")
	Do:$Data(properties("AutoParallelThreshold")) model.%Set("AutoParallelThreshold", properties("AutoParallelThreshold"), "number")
	Do:$Data(properties("BiasQueriesAsOutlier")) model.%Set("BiasQueriesAsOutlier", properties("BiasQueriesAsOutlier"), "boolean")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comment")) model.%Set("Comment", properties("Comment"), "boolean")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("DBMSSecurity")) model.%Set("DBMSSecurity", properties("DBMSSecurity"), "boolean")
	Do:$Data(properties("DDLDefineBitmapExtent")) model.%Set("DDLDefineBitmapExtent", properties("DDLDefineBitmapExtent"), "boolean")
	Do:$Data(properties("DDLFinal")) model.%Set("DDLFinal", properties("DDLFinal"), "boolean")
	Do:$Data(properties("DDLNo201")) model.%Set("DDLNo201", properties("DDLNo201"), "boolean")
	Do:$Data(properties("DDLNo30")) model.%Set("DDLNo30", properties("DDLNo30"), "boolean")
	Do:$Data(properties("DDLNo307")) model.%Set("DDLNo307", properties("DDLNo307"), "boolean")
	Do:$Data(properties("DDLNo311")) model.%Set("DDLNo311", properties("DDLNo311"), "boolean")
	Do:$Data(properties("DDLNo315")) model.%Set("DDLNo315", properties("DDLNo315"), "boolean")
	Do:$Data(properties("DDLNo324")) model.%Set("DDLNo324", properties("DDLNo324"), "boolean")
	Do:$Data(properties("DDLNo333")) model.%Set("DDLNo333", properties("DDLNo333"), "boolean")
	Do:$Data(properties("DDLSQLOnlyCompile")) model.%Set("DDLSQLOnlyCompile", properties("DDLSQLOnlyCompile"), "boolean")
	Do:$Data(properties("DDLUseExtentSet")) model.%Set("DDLUseExtentSet", properties("DDLUseExtentSet"), "boolean")
	Do:$Data(properties("DDLUseSequence")) model.%Set("DDLUseSequence", properties("DDLUseSequence"), "boolean")
	Do:$Data(properties("DefaultSchema")) model.%Set("DefaultSchema", properties("DefaultSchema"), "string")
	Do:$Data(properties("DelimitedIds")) model.%Set("DelimitedIds", properties("DelimitedIds"), "boolean")
	Do:$Data(properties("DropDelete")) model.%Set("DropDelete", properties("DropDelete"), "boolean")
	Do:$Data(properties("ECPSync")) model.%Set("ECPSync", properties("ECPSync"), "boolean")
	Do:$Data(properties("ExtrinsicFunctions")) model.%Set("ExtrinsicFunctions", properties("ExtrinsicFunctions"), "boolean")
	Do:$Data(properties("FastDistinct")) model.%Set("FastDistinct", properties("FastDistinct"), "boolean")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("IdKey")) model.%Set("IdKey", properties("IdKey"), "boolean")
	Do:$Data(properties("IdTrxFrom")) model.%Set("IdTrxFrom", properties("IdTrxFrom"), "string")
	Do:$Data(properties("IdTrxTo")) model.%Set("IdTrxTo", properties("IdTrxTo"), "string")
	Do:$Data(properties("JDBCGatewayJVMArgs")) model.%Set("JDBCGatewayJVMArgs", properties("JDBCGatewayJVMArgs"), "string")
	Do:$Data(properties("JDBCGatewayLog")) model.%Set("JDBCGatewayLog", properties("JDBCGatewayLog"), "string")
	Do:$Data(properties("JDBCGatewayPort")) model.%Set("JDBCGatewayPort", properties("JDBCGatewayPort"), "number")
	Do:$Data(properties("JDBCGatewayUsePassphrase")) model.%Set("JDBCGatewayUsePassphrase", properties("JDBCGatewayUsePassphrase"), "boolean")
	Do:$Data(properties("JavaClassPath")) model.%Set("JavaClassPath", properties("JavaClassPath"), "string")
	Do:$Data(properties("JavaHome")) model.%Set("JavaHome", properties("JavaHome"), "string")
	Do:$Data(properties("LockThreshold")) model.%Set("LockThreshold", properties("LockThreshold"), "number")
	Do:$Data(properties("LockTimeout")) model.%Set("LockTimeout", properties("LockTimeout"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("ODBCVarcharMaxlen")) model.%Set("ODBCVarcharMaxlen", properties("ODBCVarcharMaxlen"), "number")
	Do:$Data(properties("QueryProcedures")) model.%Set("QueryProcedures", properties("QueryProcedures"), "boolean")
	Do:$Data(properties("RTPC")) model.%Set("RTPC", properties("RTPC"), "boolean")
	Do:$Data(properties("ReferentialChecks")) model.%Set("ReferentialChecks", properties("ReferentialChecks"), "boolean")
	Do:$Data(properties("SaveMAC")) model.%Set("SaveMAC", properties("SaveMAC"), "boolean")
	Do:$Data(properties("TCPKeepAlive")) model.%Set("TCPKeepAlive", properties("TCPKeepAlive"), "number")
	Do:$Data(properties("TODATEDefaultFormat")) model.%Set("TODATEDefaultFormat", properties("TODATEDefaultFormat"), "string")
	Do:$Data(properties("TimePrecision")) model.%Set("TimePrecision", properties("TimePrecision"), "number")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.SQL).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SYS.Databases">
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>65834,73167.186713</TimeChanged>
<TimeCreated>65834,73167.186713</TimeCreated>

<Parameter name="PNAME">
<Default>Directory</Default>
</Parameter>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Do:'##class(%File).DirectoryExists(model.Directory) ##class(%File).CreateDirectoryChain(model.Directory)
    Set db=##Class(SYS.Database).%New()
    Set lbProperties = $$$DBSysCreateProperties
    Do ..ToArray(model, .properties)
    Set key = ""
    For  {
        Set key = $Order(properties(key),1,value)
        Quit:key=""
        If ''$LISTFIND(lbProperties,key) {  ; can set this property on create.
            Set $Property(db, key) = value
        }
    }
	Quit db.%Save()
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(SYS.Database).DeleteDatabase(Directory)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Quit ##class(SYS.Database).%ExistsId(Directory)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Directory) ""
	$$$switchNSSys
    Set DBObj = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    Do ..ObjectToArray(DBObj, .properties)
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>mask:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set dbList = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("SYS.Database:CompactLocalList")
		Do rs.Execute(mask)
		While rs.Next() {
			Do dbList.%Push(..Get(rs.Data("Directory")))
		}
		Do rs.Close()
		$$$restoreNS

	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return dbList
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
    Set db=##Class(SYS.Database).%OpenId(model.Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    
    Set lbProperties = $$$DBSysUpdateProperties

    Set key = ""
    For  {
        Set key = $Order(properties(key),1,value)
        Quit:key=""
        If ''$LISTFIND(lbProperties,key) {  ; can set this property on update.
            Set $Property(db, key) = value
        }
    }
	Quit db.%Save()
]]></Implementation>
</Method>

<Method name="Dismount">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    Quit:'db.Mounted $$$OK
    Quit db.Dismount()
]]></Implementation>
</Method>

<Method name="Mount">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String,readOnly:%Boolean=$$$NO</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) $$$ThrowStatus(sc)
    If db.Mounted && (db.ReadOnlyMounted'=readOnly) {
        $$$ThrowOnError(db.Dismount())
    }
    Quit db.Mount(+readOnly)
]]></Implementation>
</Method>

<Method name="GetMountState">
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
    $$$switchNSSys
    Set db = ##class(SYS.Database).%OpenId(Directory,,.sc)
    If $$$ISERR(sc) {
        $$$ThrowStatus(sc)
    }

    #dim mountState As %Library.DynamicObject = {}
    Do mountState.%Set("Directory", db.Directory, "string")
    Do mountState.%Set("Mounted", db.Mounted, "boolean")
    Do mountState.%Set("ReadOnlyMounted", db.ReadOnlyMounted, "boolean")
    
    Quit mountState
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set properties("BlockFormat") = pObj.BlockFormat
	Set properties("BlockSize") = pObj.BlockSize
	Set properties("Blocks") = pObj.Blocks
	Set properties("BlocksPerMap") = pObj.BlocksPerMap
	Set properties("ClusterMountMode") = pObj.ClusterMountMode
	Set properties("ClusterMounted") = pObj.ClusterMounted
	Set properties("CompressionEngine") = pObj.CompressionEngine
	Set properties("CurrentMaps") = pObj.CurrentMaps
	Set properties("Directory") = pObj.Directory
	Set properties("DirectoryBlock") = pObj.DirectoryBlock
	Set properties("EncryptedDB") = pObj.EncryptedDB
	Set properties("EncryptionKeyID") = pObj.EncryptionKeyID
	Set properties("Expanding") = pObj.Expanding
	Set properties("ExpansionSize") = pObj.ExpansionSize
	Set properties("Full") = pObj.Full
	Set properties("GlobalJournalState") = pObj.GlobalJournalState
	Set properties("InActiveMirror") = pObj.InActiveMirror
	Set properties("LastExpansionTime") = pObj.LastExpansionTime
	Set properties("MaxSize") = pObj.MaxSize
	Set properties("MirrorActivationRequired") = pObj.MirrorActivationRequired
	Set properties("MirrorDBCatchup") = pObj.MirrorDBCatchup
	Set properties("MirrorDBCreatedNew") = pObj.MirrorDBCreatedNew
	Set properties("MirrorDBName") = pObj.MirrorDBName
	Set properties("MirrorDBPaused") = pObj.MirrorDBPaused
	Set properties("MirrorFailoverDB") = pObj.MirrorFailoverDB
	Set properties("MirrorNoWrite") = pObj.MirrorNoWrite
	Set properties("MirrorObsolete") = pObj.MirrorObsolete
	Set properties("MirrorSetName") = pObj.MirrorSetName
	Set properties("Mirrored") = pObj.Mirrored
	Set properties("Mounted") = pObj.Mounted
	Set properties("NewGlobalCollation") = pObj.NewGlobalCollation
	Set properties("NewGlobalGrowthBlock") = pObj.NewGlobalGrowthBlock
	Set properties("NewGlobalIsKeep") = pObj.NewGlobalIsKeep
	Set properties("NewGlobalPointerBlock") = pObj.NewGlobalPointerBlock
	Set properties("NumberOfConfigDB") = pObj.NumberOfConfigDB
	Set properties("ROReasonCode") = pObj.ROReasonCode
	Set properties("ROReasonText") = pObj.ROReasonText
	Set properties("ReCreate") = pObj.ReCreate
	Set properties("ReadOnly") = pObj.ReadOnly
	Set properties("ReadOnlyMounted") = pObj.ReadOnlyMounted
	Set properties("Reinitialize") = pObj.Reinitialize
	Set properties("RequestSize") = pObj.RequestSize
	Set properties("ResourceName") = pObj.ResourceName
	Set properties("RunCatchupDBOnCreate") = pObj.RunCatchupDBOnCreate
	Set properties("SFN") = pObj.SFN
	Set properties("Size") = pObj.Size
	Set properties("Skeleton") = pObj.Skeleton
	Set properties("SparseDB") = pObj.SparseDB
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"BlockFormat") properties("BlockFormat") = model.BlockFormat
	Set:$$$CanSetProperty(model,"BlockSize") properties("BlockSize") = model.BlockSize
	Set:$$$CanSetProperty(model,"ClusterMountMode") properties("ClusterMountMode") = model.ClusterMountMode
	Set:$$$CanSetProperty(model,"CompressionEngine") properties("CompressionEngine") = model.CompressionEngine
	Set:$$$CanSetProperty(model,"Directory") properties("Directory") = model.Directory
	Set:$$$CanSetProperty(model,"EncryptedDB") properties("EncryptedDB") = model.EncryptedDB
	Set:$$$CanSetProperty(model,"EncryptionKeyID") properties("EncryptionKeyID") = model.EncryptionKeyID
	Set:$$$CanSetProperty(model,"ExpansionSize") properties("ExpansionSize") = model.ExpansionSize
	Set:$$$CanSetProperty(model,"Full") properties("Full") = model.Full
	Set:$$$CanSetProperty(model,"GlobalJournalState") properties("GlobalJournalState") = model.GlobalJournalState
	Set:$$$CanSetProperty(model,"MaxSize") properties("MaxSize") = model.MaxSize
	Set:$$$CanSetProperty(model,"MirrorDBName") properties("MirrorDBName") = model.MirrorDBName
	Set:$$$CanSetProperty(model,"MirrorSetName") properties("MirrorSetName") = model.MirrorSetName
	Set:$$$CanSetProperty(model,"NewGlobalCollation") properties("NewGlobalCollation") = model.NewGlobalCollation
	Set:$$$CanSetProperty(model,"NewGlobalGrowthBlock") properties("NewGlobalGrowthBlock") = model.NewGlobalGrowthBlock
	Set:$$$CanSetProperty(model,"NewGlobalIsKeep") properties("NewGlobalIsKeep") = model.NewGlobalIsKeep
	Set:$$$CanSetProperty(model,"NewGlobalPointerBlock") properties("NewGlobalPointerBlock") = model.NewGlobalPointerBlock
	Set:$$$CanSetProperty(model,"ReCreate") properties("ReCreate") = model.ReCreate
	Set:$$$CanSetProperty(model,"ReadOnly") properties("ReadOnly") = model.ReadOnly
	Set:$$$CanSetProperty(model,"Reinitialize") properties("Reinitialize") = model.Reinitialize
	Set:$$$CanSetProperty(model,"RequestSize") properties("RequestSize") = model.RequestSize
	Set:$$$CanSetProperty(model,"ResourceName") properties("ResourceName") = model.ResourceName
	Set:$$$CanSetProperty(model,"RunCatchupDBOnCreate") properties("RunCatchupDBOnCreate") = model.RunCatchupDBOnCreate
	Set:$$$CanSetProperty(model,"Size") properties("Size") = model.Size
	Set:$$$CanSetProperty(model,"SparseDB") properties("SparseDB") = model.SparseDB
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("BlockFormat")) model.%Set("BlockFormat", properties("BlockFormat"), "number")
	Do:$Data(properties("BlockSize")) model.%Set("BlockSize", properties("BlockSize"), "number")
	Do:$Data(properties("Blocks")) model.%Set("Blocks", properties("Blocks"), "number")
	Do:$Data(properties("BlocksPerMap")) model.%Set("BlocksPerMap", properties("BlocksPerMap"), "number")
	Do:$Data(properties("ClusterMountMode")) model.%Set("ClusterMountMode", properties("ClusterMountMode"), "boolean")
	Do:$Data(properties("ClusterMounted")) model.%Set("ClusterMounted", properties("ClusterMounted"), "boolean")
	Do:$Data(properties("CompressionEngine")) model.%Set("CompressionEngine", properties("CompressionEngine"), "number")
	Do:$Data(properties("CurrentMaps")) model.%Set("CurrentMaps", properties("CurrentMaps"), "number")
	Do:$Data(properties("Directory")) model.%Set("Directory", properties("Directory"), "string")
	Do:$Data(properties("DirectoryBlock")) model.%Set("DirectoryBlock", properties("DirectoryBlock"), "number")
	Do:$Data(properties("EncryptedDB")) model.%Set("EncryptedDB", properties("EncryptedDB"), "boolean")
	Do:$Data(properties("EncryptionKeyID")) model.%Set("EncryptionKeyID", properties("EncryptionKeyID"), "string")
	Do:$Data(properties("Expanding")) model.%Set("Expanding", properties("Expanding"), "boolean")
	Do:$Data(properties("ExpansionSize")) model.%Set("ExpansionSize", properties("ExpansionSize"), "number")
	Do:$Data(properties("Full")) model.%Set("Full", properties("Full"), "boolean")
	Do:$Data(properties("GlobalJournalState")) model.%Set("GlobalJournalState", properties("GlobalJournalState"), "string")
	Do:$Data(properties("InActiveMirror")) model.%Set("InActiveMirror", properties("InActiveMirror"), "boolean")
	Do:$Data(properties("LastExpansionTime")) model.%Set("LastExpansionTime", properties("LastExpansionTime"), "string")
	Do:$Data(properties("MaxSize")) model.%Set("MaxSize", properties("MaxSize"), "number")
	Do:$Data(properties("MirrorActivationRequired")) model.%Set("MirrorActivationRequired", properties("MirrorActivationRequired"), "boolean")
	Do:$Data(properties("MirrorDBCatchup")) model.%Set("MirrorDBCatchup", properties("MirrorDBCatchup"), "boolean")
	Do:$Data(properties("MirrorDBCreatedNew")) model.%Set("MirrorDBCreatedNew", properties("MirrorDBCreatedNew"), "boolean")
	Do:$Data(properties("MirrorDBName")) model.%Set("MirrorDBName", properties("MirrorDBName"), "string")
	Do:$Data(properties("MirrorDBPaused")) model.%Set("MirrorDBPaused", properties("MirrorDBPaused"), "boolean")
	Do:$Data(properties("MirrorFailoverDB")) model.%Set("MirrorFailoverDB", properties("MirrorFailoverDB"), "boolean")
	Do:$Data(properties("MirrorNoWrite")) model.%Set("MirrorNoWrite", properties("MirrorNoWrite"), "boolean")
	Do:$Data(properties("MirrorObsolete")) model.%Set("MirrorObsolete", properties("MirrorObsolete"), "boolean")
	Do:$Data(properties("MirrorSetName")) model.%Set("MirrorSetName", properties("MirrorSetName"), "string")
	Do:$Data(properties("Mirrored")) model.%Set("Mirrored", properties("Mirrored"), "boolean")
	Do:$Data(properties("Mounted")) model.%Set("Mounted", properties("Mounted"), "boolean")
	Do:$Data(properties("NewGlobalCollation")) model.%Set("NewGlobalCollation", properties("NewGlobalCollation"), "string")
	Do:$Data(properties("NewGlobalGrowthBlock")) model.%Set("NewGlobalGrowthBlock", properties("NewGlobalGrowthBlock"), "number")
	Do:$Data(properties("NewGlobalIsKeep")) model.%Set("NewGlobalIsKeep", properties("NewGlobalIsKeep"), "boolean")
	Do:$Data(properties("NewGlobalPointerBlock")) model.%Set("NewGlobalPointerBlock", properties("NewGlobalPointerBlock"), "number")
	Do:$Data(properties("NumberOfConfigDB")) model.%Set("NumberOfConfigDB", properties("NumberOfConfigDB"), "number")
	Do:$Data(properties("ROReasonCode")) model.%Set("ROReasonCode", properties("ROReasonCode"), "number")
	Do:$Data(properties("ROReasonText")) model.%Set("ROReasonText", properties("ROReasonText"), "string")
	Do:$Data(properties("ReCreate")) model.%Set("ReCreate", properties("ReCreate"), "boolean")
	Do:$Data(properties("ReadOnly")) model.%Set("ReadOnly", properties("ReadOnly"), "boolean")
	Do:$Data(properties("ReadOnlyMounted")) model.%Set("ReadOnlyMounted", properties("ReadOnlyMounted"), "boolean")
	Do:$Data(properties("Reinitialize")) model.%Set("Reinitialize", properties("Reinitialize"), "boolean")
	Do:$Data(properties("RequestSize")) model.%Set("RequestSize", properties("RequestSize"), "number")
	Do:$Data(properties("ResourceName")) model.%Set("ResourceName", properties("ResourceName"), "string")
	Do:$Data(properties("RunCatchupDBOnCreate")) model.%Set("RunCatchupDBOnCreate", properties("RunCatchupDBOnCreate"), "boolean")
	Do:$Data(properties("SFN")) model.%Set("SFN", properties("SFN"), "number")
	Do:$Data(properties("Size")) model.%Set("Size", properties("Size"), "number")
	Do:$Data(properties("Skeleton")) model.%Set("Skeleton", properties("Skeleton"), "boolean")
	Do:$Data(properties("SparseDB")) model.%Set("SparseDB", properties("SparseDB"), "boolean")
	Quit model
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Applications">
<Description>
Description</Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>65834,73167.193565</TimeChanged>
<TimeCreated>65834,73167.193565</TimeCreated>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Security.Applications).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Security.Applications).Modify(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.Applications).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.Applications).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Security.Applications).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Security.Applications:List")
		Do rs.Execute(Names)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AutheEnabled") = pObj.AutheEnabled
	Set properties("AutoCompile") = pObj.AutoCompile
	Set properties("CSPZENEnabled") = pObj.CSPZENEnabled
	Set properties("CSRFToken") = pObj.CSRFToken
	Set properties("ChangePasswordPage") = pObj.ChangePasswordPage
	Set properties("ClientApplications") = pObj.ClientApplications
	Set properties("CookiePath") = pObj.CookiePath
	Set properties("DeepSeeEnabled") = pObj.DeepSeeEnabled
	Set properties("Description") = pObj.Description
	Set properties("DispatchClass") = pObj.DispatchClass
	Set properties("Enabled") = pObj.Enabled
	Set properties("ErrorPage") = pObj.ErrorPage
	Set properties("EventClass") = pObj.EventClass
	Set properties("GroupById") = pObj.GroupById
	Set properties("InbndWebServicesEnabled") = pObj.InbndWebServicesEnabled
	Set properties("IsNameSpaceDefault") = pObj.IsNameSpaceDefault
	Set properties("LockCSPName") = pObj.LockCSPName
	Set properties("LoginPage") = pObj.LoginPage
	Set properties("MatchRoles") = pObj.MatchRoles
	Set properties("Name") = pObj.Name
	Set properties("NameSpace") = pObj.NameSpace
	Set properties("Package") = pObj.Package
	Set properties("Path") = pObj.Path
	Set properties("PermittedClasses") = pObj.PermittedClasses
	Set properties("Recurse") = pObj.Recurse
	Set properties("Resource") = pObj.Resource
	Set properties("Routines") = pObj.Routines
	Set properties("ServeFiles") = pObj.ServeFiles
	Set properties("ServeFilesTimeout") = pObj.ServeFilesTimeout
	Set properties("SessionScope") = pObj.SessionScope
	Set properties("SuperClass") = pObj.SuperClass
	Set properties("Timeout") = pObj.Timeout
	Set properties("Type") = pObj.Type
	Set properties("UseCookies") = pObj.UseCookies
	Set properties("UserCookieScope") = pObj.UserCookieScope
	Set properties("iKnowEnabled") = pObj.iKnowEnabled
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AutheEnabled") properties("AutheEnabled") = model.AutheEnabled
	Set:$$$CanSetProperty(model,"AutoCompile") properties("AutoCompile") = model.AutoCompile
	Set:$$$CanSetProperty(model,"CSPZENEnabled") properties("CSPZENEnabled") = model.CSPZENEnabled
	Set:$$$CanSetProperty(model,"CSRFToken") properties("CSRFToken") = model.CSRFToken
	Set:$$$CanSetProperty(model,"ChangePasswordPage") properties("ChangePasswordPage") = model.ChangePasswordPage
	Set:$$$CanSetProperty(model,"ClientApplications") properties("ClientApplications") = model.ClientApplications
	Set:$$$CanSetProperty(model,"CookiePath") properties("CookiePath") = model.CookiePath
	Set:$$$CanSetProperty(model,"DeepSeeEnabled") properties("DeepSeeEnabled") = model.DeepSeeEnabled
	Set:$$$CanSetProperty(model,"Description") properties("Description") = model.Description
	Set:$$$CanSetProperty(model,"DispatchClass") properties("DispatchClass") = model.DispatchClass
	Set:$$$CanSetProperty(model,"Enabled") properties("Enabled") = model.Enabled
	Set:$$$CanSetProperty(model,"ErrorPage") properties("ErrorPage") = model.ErrorPage
	Set:$$$CanSetProperty(model,"EventClass") properties("EventClass") = model.EventClass
	Set:$$$CanSetProperty(model,"GroupById") properties("GroupById") = model.GroupById
	Set:$$$CanSetProperty(model,"InbndWebServicesEnabled") properties("InbndWebServicesEnabled") = model.InbndWebServicesEnabled
	Set:$$$CanSetProperty(model,"IsNameSpaceDefault") properties("IsNameSpaceDefault") = model.IsNameSpaceDefault
	Set:$$$CanSetProperty(model,"LockCSPName") properties("LockCSPName") = model.LockCSPName
	Set:$$$CanSetProperty(model,"LoginPage") properties("LoginPage") = model.LoginPage
	Set:$$$CanSetProperty(model,"MatchRoles") properties("MatchRoles") = model.MatchRoles
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"NameSpace") properties("NameSpace") = model.NameSpace
	Set:$$$CanSetProperty(model,"Package") properties("Package") = model.Package
	Set:$$$CanSetProperty(model,"Path") properties("Path") = model.Path
	Set:$$$CanSetProperty(model,"PermittedClasses") properties("PermittedClasses") = model.PermittedClasses
	Set:$$$CanSetProperty(model,"Recurse") properties("Recurse") = model.Recurse
	Set:$$$CanSetProperty(model,"Resource") properties("Resource") = model.Resource
	Set:$$$CanSetProperty(model,"Routines") properties("Routines") = model.Routines
	Set:$$$CanSetProperty(model,"ServeFiles") properties("ServeFiles") = model.ServeFiles
	Set:$$$CanSetProperty(model,"ServeFilesTimeout") properties("ServeFilesTimeout") = model.ServeFilesTimeout
	Set:$$$CanSetProperty(model,"SessionScope") properties("SessionScope") = model.SessionScope
	Set:$$$CanSetProperty(model,"SuperClass") properties("SuperClass") = model.SuperClass
	Set:$$$CanSetProperty(model,"Timeout") properties("Timeout") = model.Timeout
	Set:$$$CanSetProperty(model,"Type") properties("Type") = model.Type
	Set:$$$CanSetProperty(model,"UseCookies") properties("UseCookies") = model.UseCookies
	Set:$$$CanSetProperty(model,"UserCookieScope") properties("UserCookieScope") = model.UserCookieScope
	Set:$$$CanSetProperty(model,"iKnowEnabled") properties("iKnowEnabled") = model.iKnowEnabled
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AutheEnabled")) model.%Set("AutheEnabled", properties("AutheEnabled"), "string")
	Do:$Data(properties("AutoCompile")) model.%Set("AutoCompile", properties("AutoCompile"), "boolean")
	Do:$Data(properties("CSPZENEnabled")) model.%Set("CSPZENEnabled", properties("CSPZENEnabled"), "boolean")
	Do:$Data(properties("CSRFToken")) model.%Set("CSRFToken", properties("CSRFToken"), "boolean")
	Do:$Data(properties("ChangePasswordPage")) model.%Set("ChangePasswordPage", properties("ChangePasswordPage"), "string")
	Do:$Data(properties("ClientApplications")) model.%Set("ClientApplications", properties("ClientApplications"), "string")
	Do:$Data(properties("CookiePath")) model.%Set("CookiePath", properties("CookiePath"), "string")
	Do:$Data(properties("DeepSeeEnabled")) model.%Set("DeepSeeEnabled", properties("DeepSeeEnabled"), "boolean")
	Do:$Data(properties("Description")) model.%Set("Description", properties("Description"), "string")
	Do:$Data(properties("DispatchClass")) model.%Set("DispatchClass", properties("DispatchClass"), "string")
	Do:$Data(properties("Enabled")) model.%Set("Enabled", properties("Enabled"), "boolean")
	Do:$Data(properties("ErrorPage")) model.%Set("ErrorPage", properties("ErrorPage"), "string")
	Do:$Data(properties("EventClass")) model.%Set("EventClass", properties("EventClass"), "string")
	Do:$Data(properties("GroupById")) model.%Set("GroupById", properties("GroupById"), "string")
	Do:$Data(properties("InbndWebServicesEnabled")) model.%Set("InbndWebServicesEnabled", properties("InbndWebServicesEnabled"), "boolean")
	Do:$Data(properties("IsNameSpaceDefault")) model.%Set("IsNameSpaceDefault", properties("IsNameSpaceDefault"), "boolean")
	Do:$Data(properties("LockCSPName")) model.%Set("LockCSPName", properties("LockCSPName"), "boolean")
	Do:$Data(properties("LoginPage")) model.%Set("LoginPage", properties("LoginPage"), "string")
	Do:$Data(properties("MatchRoles")) model.%Set("MatchRoles", properties("MatchRoles"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("NameSpace")) model.%Set("NameSpace", properties("NameSpace"), "string")
	Do:$Data(properties("Package")) model.%Set("Package", properties("Package"), "string")
	Do:$Data(properties("Path")) model.%Set("Path", properties("Path"), "string")
	Do:$Data(properties("PermittedClasses")) model.%Set("PermittedClasses", properties("PermittedClasses"), "string")
	Do:$Data(properties("Recurse")) model.%Set("Recurse", properties("Recurse"), "boolean")
	Do:$Data(properties("Resource")) model.%Set("Resource", properties("Resource"), "string")
	Do:$Data(properties("Routines")) model.%Set("Routines", properties("Routines"), "string")
	Do:$Data(properties("ServeFiles")) model.%Set("ServeFiles", properties("ServeFiles"), "number")
	Do:$Data(properties("ServeFilesTimeout")) model.%Set("ServeFilesTimeout", properties("ServeFilesTimeout"), "number")
	Do:$Data(properties("SessionScope")) model.%Set("SessionScope", properties("SessionScope"), "number")
	Do:$Data(properties("SuperClass")) model.%Set("SuperClass", properties("SuperClass"), "string")
	Do:$Data(properties("Timeout")) model.%Set("Timeout", properties("Timeout"), "number")
	Do:$Data(properties("Type")) model.%Set("Type", properties("Type"), "string")
	Do:$Data(properties("UseCookies")) model.%Set("UseCookies", properties("UseCookies"), "number")
	Do:$Data(properties("UserCookieScope")) model.%Set("UserCookieScope", properties("UserCookieScope"), "number")
	Do:$Data(properties("iKnowEnabled")) model.%Set("iKnowEnabled", properties("iKnowEnabled"), "boolean")
	Quit model
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Security.Services">
<Description>
Description</Description>
<IncludeCode>Api.Config.inc</IncludeCode>
<TimeChanged>65834,73167.211601</TimeChanged>
<TimeCreated>65834,73167.211601</TimeCreated>

<Parameter name="UPDATEONLY">
<Default>1</Default>
</Parameter>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Security.Services).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Security.Services).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Security.Services).Modify(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*"</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Security.Services:List")
		Do rs.Execute(Names)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("AutheEnabled") = pObj.AutheEnabled
	Set properties("ClientSystems") = pObj.ClientSystems
	Set properties("Description") = pObj.Description
	Set properties("Enabled") = pObj.Enabled
	Set properties("Name") = pObj.Name
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"AutheEnabled") properties("AutheEnabled") = model.AutheEnabled
	Set:$$$CanSetProperty(model,"ClientSystems") properties("ClientSystems") = model.ClientSystems
	Set:$$$CanSetProperty(model,"Description") properties("Description") = model.Description
	Set:$$$CanSetProperty(model,"Enabled") properties("Enabled") = model.Enabled
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("AutheEnabled")) model.%Set("AutheEnabled", properties("AutheEnabled"), "string")
	Do:$Data(properties("ClientSystems")) model.%Set("ClientSystems", properties("ClientSystems"), "string")
	Do:$Data(properties("Description")) model.%Set("Description", properties("Description"), "string")
	Do:$Data(properties("Enabled")) model.%Set("Enabled", properties("Enabled"), "boolean")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Shadows">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.134696</TimeChanged>
<TimeCreated>65834,73167.134696</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Address="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Address property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Shadows).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Shadows).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.Shadows).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Shadows).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.Shadows:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("Address") = pObj.Address
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("DaysBeforePurge") = pObj.DaysBeforePurge
	Set properties("DisableJournalUpdates") = pObj.DisableJournalUpdates
	Set properties("Enabled") = pObj.Enabled
	Set properties("FilterRoutine") = pObj.FilterRoutine
	Set properties("Flags") = pObj.Flags
	Set properties("JournalDirectory") = pObj.JournalDirectory
	Set properties("MaxErrors") = pObj.MaxErrors
	Set properties("Name") = pObj.Name
	Set properties("SSLConfig") = pObj.SSLConfig
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"Address") properties("Address") = model.Address
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"DaysBeforePurge") properties("DaysBeforePurge") = model.DaysBeforePurge
	Set:$$$CanSetProperty(model,"DisableJournalUpdates") properties("DisableJournalUpdates") = model.DisableJournalUpdates
	Set:$$$CanSetProperty(model,"Enabled") properties("Enabled") = model.Enabled
	Set:$$$CanSetProperty(model,"FilterRoutine") properties("FilterRoutine") = model.FilterRoutine
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"JournalDirectory") properties("JournalDirectory") = model.JournalDirectory
	Set:$$$CanSetProperty(model,"MaxErrors") properties("MaxErrors") = model.MaxErrors
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"SSLConfig") properties("SSLConfig") = model.SSLConfig
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("Address")) model.%Set("Address", properties("Address"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("DaysBeforePurge")) model.%Set("DaysBeforePurge", properties("DaysBeforePurge"), "number")
	Do:$Data(properties("DisableJournalUpdates")) model.%Set("DisableJournalUpdates", properties("DisableJournalUpdates"), "boolean")
	Do:$Data(properties("Enabled")) model.%Set("Enabled", properties("Enabled"), "boolean")
	Do:$Data(properties("FilterRoutine")) model.%Set("FilterRoutine", properties("FilterRoutine"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("JournalDirectory")) model.%Set("JournalDirectory", properties("JournalDirectory"), "string")
	Do:$Data(properties("MaxErrors")) model.%Set("MaxErrors", properties("MaxErrors"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("SSLConfig")) model.%Set("SSLConfig", properties("SSLConfig"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Shadows).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SqlSysDatatypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.156617</TimeChanged>
<TimeCreated>65834,73167.156617</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Datatype="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Datatype property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.SqlSysDatatypes).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.SqlSysDatatypes).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.SqlSysDatatypes).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.SqlSysDatatypes).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.SqlSysDatatypes:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Datatype") = pObj.Datatype
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Datatype") properties("Datatype") = model.Datatype
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Datatype")) model.%Set("Datatype", properties("Datatype"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.SqlSysDatatypes).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.SqlUserDatatypes">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.157794</TimeChanged>
<TimeCreated>65834,73167.157794</TimeCreated>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set sc = $$$OK
	Set:model.Datatype="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Datatype property is mandatory."))
	Set:model.Name="" sc = $$$ADDSC(sc,$$$ERROR(5001, "Name property is mandatory."))
	Quit sc
]]></Implementation>
</Method>

<Method name="Create">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.SqlUserDatatypes).Create(model.Name,.properties)
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.SqlUserDatatypes).Delete(Name)
]]></Implementation>
</Method>

<Method name="Exists">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Quit ##class(Config.SqlUserDatatypes).Exists(Name)
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Quit:'..Exists(Name) ""
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.SqlUserDatatypes).Get(Name,.properties))
	Set properties("Name") = Name
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="List">
<ClassMethod>1</ClassMethod>
<FormalSpec>Names:%String="*",CPFFile:%String="",Flags:%Integer=0,Format:%Integer=0</FormalSpec>
<ReturnType>%DynamicArray</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	Set list = []
	Try{
		Set rs=##class(%Library.ResultSet).%New("Config.SqlUserDatatypes:List")
		Do rs.Execute(Names,CPFFile,Flags,Format)
		While rs.Next() {
			Do list.%Push(..Get(rs.Data("Name")))
		}
		Do rs.Close()
		$$$restoreNS
	}Catch(ex) {
		$$$restoreNS
		Throw ex
	}
	Return list
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("Datatype") = pObj.Datatype
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"Datatype") properties("Datatype") = model.Datatype
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("Datatype")) model.%Set("Datatype", properties("Datatype"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.SqlUserDatatypes).Modify(model.Name,.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Startup">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.198528</TimeChanged>
<TimeCreated>65834,73167.198528</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Startup).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("ArbiterURL") = pObj.ArbiterURL
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("CallinHalt") = pObj.CallinHalt
	Set properties("CallinStart") = pObj.CallinStart
	Set properties("CliSysName") = pObj.CliSysName
	Set properties("Comments") = pObj.Comments
	Set properties("DBSizesAllowed") = pObj.DBSizesAllowed
	Set properties("DefaultPort") = pObj.DefaultPort
	Set properties("DefaultPortBindAddress") = pObj.DefaultPortBindAddress
	Set properties("EnableVSSBackup") = pObj.EnableVSSBackup
	Set properties("EnsembleAutoStart") = pObj.EnsembleAutoStart
	Set properties("ErrorPurge") = pObj.ErrorPurge
	Set properties("FIPSMode") = pObj.FIPSMode
	Set properties("Flags") = pObj.Flags
	Set properties("IPv6") = pObj.IPv6
	Set properties("JobHalt") = pObj.JobHalt
	Set properties("JobServers") = pObj.JobServers
	Set properties("JobStart") = pObj.JobStart
	Set properties("LicenseID") = pObj.LicenseID
	Set properties("MaxConsoleLogSize") = pObj.MaxConsoleLogSize
	Set properties("MaxIRISTempSizeAtStart") = pObj.MaxIRISTempSizeAtStart
	Set properties("MirrorMember") = pObj.MirrorMember
	Set properties("MirrorPrimary") = pObj.MirrorPrimary
	Set properties("MirrorSetName") = pObj.MirrorSetName
	Set properties("Name") = pObj.Name
	Set properties("PasswordHash") = pObj.PasswordHash
	Set properties("ProcessHalt") = pObj.ProcessHalt
	Set properties("ProcessStart") = pObj.ProcessStart
	Set properties("ShardClusterURL") = pObj.ShardClusterURL
	Set properties("ShardMasterRegexp") = pObj.ShardMasterRegexp
	Set properties("ShardMirrorMember") = pObj.ShardMirrorMember
	Set properties("ShardRegexp") = pObj.ShardRegexp
	Set properties("ShardRole") = pObj.ShardRole
	Set properties("ShutdownTimeout") = pObj.ShutdownTimeout
	Set properties("SystemHalt") = pObj.SystemHalt
	Set properties("SystemMode") = pObj.SystemMode
	Set properties("SystemStart") = pObj.SystemStart
	Set properties("TempDirectory") = pObj.TempDirectory
	Set properties("TerminalPrompt") = pObj.TerminalPrompt
	Set properties("WebServer") = pObj.WebServer
	Set properties("WebServerName") = pObj.WebServerName
	Set properties("WebServerPort") = pObj.WebServerPort
	Set properties("WebServerURLPrefix") = pObj.WebServerURLPrefix
	Set properties("ZSTU") = pObj.ZSTU
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"ArbiterURL") properties("ArbiterURL") = model.ArbiterURL
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"CallinHalt") properties("CallinHalt") = model.CallinHalt
	Set:$$$CanSetProperty(model,"CallinStart") properties("CallinStart") = model.CallinStart
	Set:$$$CanSetProperty(model,"CliSysName") properties("CliSysName") = model.CliSysName
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"DBSizesAllowed") properties("DBSizesAllowed") = model.DBSizesAllowed
	Set:$$$CanSetProperty(model,"DefaultPort") properties("DefaultPort") = model.DefaultPort
	Set:$$$CanSetProperty(model,"DefaultPortBindAddress") properties("DefaultPortBindAddress") = model.DefaultPortBindAddress
	Set:$$$CanSetProperty(model,"EnableVSSBackup") properties("EnableVSSBackup") = model.EnableVSSBackup
	Set:$$$CanSetProperty(model,"EnsembleAutoStart") properties("EnsembleAutoStart") = model.EnsembleAutoStart
	Set:$$$CanSetProperty(model,"ErrorPurge") properties("ErrorPurge") = model.ErrorPurge
	Set:$$$CanSetProperty(model,"FIPSMode") properties("FIPSMode") = model.FIPSMode
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"IPv6") properties("IPv6") = model.IPv6
	Set:$$$CanSetProperty(model,"JobHalt") properties("JobHalt") = model.JobHalt
	Set:$$$CanSetProperty(model,"JobServers") properties("JobServers") = model.JobServers
	Set:$$$CanSetProperty(model,"JobStart") properties("JobStart") = model.JobStart
	Set:$$$CanSetProperty(model,"LicenseID") properties("LicenseID") = model.LicenseID
	Set:$$$CanSetProperty(model,"MaxConsoleLogSize") properties("MaxConsoleLogSize") = model.MaxConsoleLogSize
	Set:$$$CanSetProperty(model,"MaxIRISTempSizeAtStart") properties("MaxIRISTempSizeAtStart") = model.MaxIRISTempSizeAtStart
	Set:$$$CanSetProperty(model,"MirrorMember") properties("MirrorMember") = model.MirrorMember
	Set:$$$CanSetProperty(model,"MirrorPrimary") properties("MirrorPrimary") = model.MirrorPrimary
	Set:$$$CanSetProperty(model,"MirrorSetName") properties("MirrorSetName") = model.MirrorSetName
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"PasswordHash") properties("PasswordHash") = model.PasswordHash
	Set:$$$CanSetProperty(model,"ProcessHalt") properties("ProcessHalt") = model.ProcessHalt
	Set:$$$CanSetProperty(model,"ProcessStart") properties("ProcessStart") = model.ProcessStart
	Set:$$$CanSetProperty(model,"ShardClusterURL") properties("ShardClusterURL") = model.ShardClusterURL
	Set:$$$CanSetProperty(model,"ShardMasterRegexp") properties("ShardMasterRegexp") = model.ShardMasterRegexp
	Set:$$$CanSetProperty(model,"ShardMirrorMember") properties("ShardMirrorMember") = model.ShardMirrorMember
	Set:$$$CanSetProperty(model,"ShardRegexp") properties("ShardRegexp") = model.ShardRegexp
	Set:$$$CanSetProperty(model,"ShardRole") properties("ShardRole") = model.ShardRole
	Set:$$$CanSetProperty(model,"ShutdownTimeout") properties("ShutdownTimeout") = model.ShutdownTimeout
	Set:$$$CanSetProperty(model,"SystemHalt") properties("SystemHalt") = model.SystemHalt
	Set:$$$CanSetProperty(model,"SystemMode") properties("SystemMode") = model.SystemMode
	Set:$$$CanSetProperty(model,"SystemStart") properties("SystemStart") = model.SystemStart
	Set:$$$CanSetProperty(model,"TempDirectory") properties("TempDirectory") = model.TempDirectory
	Set:$$$CanSetProperty(model,"TerminalPrompt") properties("TerminalPrompt") = model.TerminalPrompt
	Set:$$$CanSetProperty(model,"WebServer") properties("WebServer") = model.WebServer
	Set:$$$CanSetProperty(model,"WebServerName") properties("WebServerName") = model.WebServerName
	Set:$$$CanSetProperty(model,"WebServerPort") properties("WebServerPort") = model.WebServerPort
	Set:$$$CanSetProperty(model,"WebServerURLPrefix") properties("WebServerURLPrefix") = model.WebServerURLPrefix
	Set:$$$CanSetProperty(model,"ZSTU") properties("ZSTU") = model.ZSTU
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("ArbiterURL")) model.%Set("ArbiterURL", properties("ArbiterURL"), "string")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("CallinHalt")) model.%Set("CallinHalt", properties("CallinHalt"), "boolean")
	Do:$Data(properties("CallinStart")) model.%Set("CallinStart", properties("CallinStart"), "boolean")
	Do:$Data(properties("CliSysName")) model.%Set("CliSysName", properties("CliSysName"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("DBSizesAllowed")) model.%Set("DBSizesAllowed", properties("DBSizesAllowed"), "string")
	Do:$Data(properties("DefaultPort")) model.%Set("DefaultPort", properties("DefaultPort"), "number")
	Do:$Data(properties("DefaultPortBindAddress")) model.%Set("DefaultPortBindAddress", properties("DefaultPortBindAddress"), "string")
	Do:$Data(properties("EnableVSSBackup")) model.%Set("EnableVSSBackup", properties("EnableVSSBackup"), "boolean")
	Do:$Data(properties("EnsembleAutoStart")) model.%Set("EnsembleAutoStart", properties("EnsembleAutoStart"), "boolean")
	Do:$Data(properties("ErrorPurge")) model.%Set("ErrorPurge", properties("ErrorPurge"), "number")
	Do:$Data(properties("FIPSMode")) model.%Set("FIPSMode", properties("FIPSMode"), "boolean")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("IPv6")) model.%Set("IPv6", properties("IPv6"), "boolean")
	Do:$Data(properties("JobHalt")) model.%Set("JobHalt", properties("JobHalt"), "boolean")
	Do:$Data(properties("JobServers")) model.%Set("JobServers", properties("JobServers"), "number")
	Do:$Data(properties("JobStart")) model.%Set("JobStart", properties("JobStart"), "boolean")
	Do:$Data(properties("LicenseID")) model.%Set("LicenseID", properties("LicenseID"), "string")
	Do:$Data(properties("MaxConsoleLogSize")) model.%Set("MaxConsoleLogSize", properties("MaxConsoleLogSize"), "number")
	Do:$Data(properties("MaxIRISTempSizeAtStart")) model.%Set("MaxIRISTempSizeAtStart", properties("MaxIRISTempSizeAtStart"), "number")
	Do:$Data(properties("MirrorMember")) model.%Set("MirrorMember", properties("MirrorMember"), "string")
	Do:$Data(properties("MirrorPrimary")) model.%Set("MirrorPrimary", properties("MirrorPrimary"), "string")
	Do:$Data(properties("MirrorSetName")) model.%Set("MirrorSetName", properties("MirrorSetName"), "string")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("PasswordHash")) model.%Set("PasswordHash", properties("PasswordHash"), "string")
	Do:$Data(properties("ProcessHalt")) model.%Set("ProcessHalt", properties("ProcessHalt"), "boolean")
	Do:$Data(properties("ProcessStart")) model.%Set("ProcessStart", properties("ProcessStart"), "boolean")
	Do:$Data(properties("ShardClusterURL")) model.%Set("ShardClusterURL", properties("ShardClusterURL"), "string")
	Do:$Data(properties("ShardMasterRegexp")) model.%Set("ShardMasterRegexp", properties("ShardMasterRegexp"), "string")
	Do:$Data(properties("ShardMirrorMember")) model.%Set("ShardMirrorMember", properties("ShardMirrorMember"), "string")
	Do:$Data(properties("ShardRegexp")) model.%Set("ShardRegexp", properties("ShardRegexp"), "string")
	Do:$Data(properties("ShardRole")) model.%Set("ShardRole", properties("ShardRole"), "string")
	Do:$Data(properties("ShutdownTimeout")) model.%Set("ShutdownTimeout", properties("ShutdownTimeout"), "number")
	Do:$Data(properties("SystemHalt")) model.%Set("SystemHalt", properties("SystemHalt"), "boolean")
	Do:$Data(properties("SystemMode")) model.%Set("SystemMode", properties("SystemMode"), "string")
	Do:$Data(properties("SystemStart")) model.%Set("SystemStart", properties("SystemStart"), "boolean")
	Do:$Data(properties("TempDirectory")) model.%Set("TempDirectory", properties("TempDirectory"), "string")
	Do:$Data(properties("TerminalPrompt")) model.%Set("TerminalPrompt", properties("TerminalPrompt"), "string")
	Do:$Data(properties("WebServer")) model.%Set("WebServer", properties("WebServer"), "boolean")
	Do:$Data(properties("WebServerName")) model.%Set("WebServerName", properties("WebServerName"), "string")
	Do:$Data(properties("WebServerPort")) model.%Set("WebServerPort", properties("WebServerPort"), "number")
	Do:$Data(properties("WebServerURLPrefix")) model.%Set("WebServerURLPrefix", properties("WebServerURLPrefix"), "string")
	Do:$Data(properties("ZSTU")) model.%Set("ZSTU", properties("ZSTU"), "boolean")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Startup).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.Telnet">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73167.204894</TimeChanged>
<TimeCreated>65834,73167.204894</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.Telnet).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("DNSLookup") = pObj.DNSLookup
	Set properties("Flags") = pObj.Flags
	Set properties("Name") = pObj.Name
	Set properties("Port") = pObj.Port
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"DNSLookup") properties("DNSLookup") = model.DNSLookup
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"Port") properties("Port") = model.Port
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("DNSLookup")) model.%Set("DNSLookup", properties("DNSLookup"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("Port")) model.%Set("Port", properties("Port"), "number")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.Telnet).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.Services.config">
<IncludeCode>Api.Config.inc</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<TimeChanged>65834,73166.887066</TimeChanged>
<TimeCreated>65834,73166.887066</TimeCreated>

<Parameter name="ISSINGLE">
<Default>1</Default>
</Parameter>

<Method name="CheckModel">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	$$$switchNSSys
	$$$ThrowOnError(##class(Config.config).Get(.properties))
	Quit ..ToDynamic(.properties)
]]></Implementation>
</Method>

<Method name="ObjectToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pObj,*properties:%Binary]]></FormalSpec>
<Implementation><![CDATA[
	Set properties("BackoffDisabled") = pObj.BackoffDisabled
	Set properties("CPFFile") = pObj.CPFFile
	Set properties("Comments") = pObj.Comments
	Set properties("ConsoleFile") = pObj.ConsoleFile
	Set properties("Flags") = pObj.Flags
	Set properties("LargePagesDisabled") = pObj.LargePagesDisabled
	Set properties("LargePagesRequired") = pObj.LargePagesRequired
	Set properties("LibPath") = pObj.LibPath
	Set properties("LineRecallBuffer") = pObj.LineRecallBuffer
	Set properties("LineRecallEntries") = pObj.LineRecallEntries
	Set properties("LockSharedMemory") = pObj.LockSharedMemory
	Set properties("LockTextSegment") = pObj.LockTextSegment
	Set properties("MaxServerConn") = pObj.MaxServerConn
	Set properties("MaxServers") = pObj.MaxServers
	Set properties("Name") = pObj.Name
	Set properties("VMSConsoleTerminal") = pObj.VMSConsoleTerminal
	Set properties("ZFSize") = pObj.ZFSize
	Set properties("ZFString") = pObj.ZFString
	Set properties("bbsiz") = pObj.bbsiz
	Set properties("console") = pObj.console
	Set properties("errlog") = pObj.errlog
	Set properties("globals") = pObj.globals
	Set properties("globals16kb") = pObj.globals16kb
	Set properties("globals32kb") = pObj.globals32kb
	Set properties("globals4kb") = pObj.globals4kb
	Set properties("globals64kb") = pObj.globals64kb
	Set properties("globals8kb") = pObj.globals8kb
	Set properties("gmheap") = pObj.gmheap
	Set properties("history") = pObj.history
	Set properties("ijcbuff") = pObj.ijcbuff
	Set properties("ijcnum") = pObj.ijcnum
	Set properties("jrnbufs") = pObj.jrnbufs
	Set properties("locksiz") = pObj.locksiz
	Set properties("memlock") = pObj.memlock
	Set properties("netjob") = pObj.netjob
	Set properties("nlstab") = pObj.nlstab
	Set properties("overview") = pObj.overview
	Set properties("pijdir") = pObj.pijdir
	Set properties("routines") = pObj.routines
	Set properties("targwijsz") = pObj.targwijsz
	Set properties("udevtabsiz") = pObj.udevtabsiz
	Set properties("useresidentmem") = pObj.useresidentmem
	Set properties("wijdir") = pObj.wijdir
	Quit
]]></Implementation>
</Method>

<Method name="ToArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject,*properties:%Binary</FormalSpec>
<Implementation><![CDATA[
	Set:$$$CanSetProperty(model,"BackoffDisabled") properties("BackoffDisabled") = model.BackoffDisabled
	Set:$$$CanSetProperty(model,"CPFFile") properties("CPFFile") = model.CPFFile
	Set:$$$CanSetProperty(model,"Comments") properties("Comments") = model.Comments
	Set:$$$CanSetProperty(model,"ConsoleFile") properties("ConsoleFile") = model.ConsoleFile
	Set:$$$CanSetProperty(model,"Flags") properties("Flags") = model.Flags
	Set:$$$CanSetProperty(model,"LargePagesDisabled") properties("LargePagesDisabled") = model.LargePagesDisabled
	Set:$$$CanSetProperty(model,"LargePagesRequired") properties("LargePagesRequired") = model.LargePagesRequired
	Set:$$$CanSetProperty(model,"LibPath") properties("LibPath") = model.LibPath
	Set:$$$CanSetProperty(model,"LineRecallBuffer") properties("LineRecallBuffer") = model.LineRecallBuffer
	Set:$$$CanSetProperty(model,"LineRecallEntries") properties("LineRecallEntries") = model.LineRecallEntries
	Set:$$$CanSetProperty(model,"LockSharedMemory") properties("LockSharedMemory") = model.LockSharedMemory
	Set:$$$CanSetProperty(model,"LockTextSegment") properties("LockTextSegment") = model.LockTextSegment
	Set:$$$CanSetProperty(model,"MaxServerConn") properties("MaxServerConn") = model.MaxServerConn
	Set:$$$CanSetProperty(model,"MaxServers") properties("MaxServers") = model.MaxServers
	Set:$$$CanSetProperty(model,"Name") properties("Name") = model.Name
	Set:$$$CanSetProperty(model,"VMSConsoleTerminal") properties("VMSConsoleTerminal") = model.VMSConsoleTerminal
	Set:$$$CanSetProperty(model,"ZFSize") properties("ZFSize") = model.ZFSize
	Set:$$$CanSetProperty(model,"ZFString") properties("ZFString") = model.ZFString
	Set:$$$CanSetProperty(model,"bbsiz") properties("bbsiz") = model.bbsiz
	Set:$$$CanSetProperty(model,"errlog") properties("errlog") = model.errlog
	Set:$$$CanSetProperty(model,"globals16kb") properties("globals16kb") = model.globals16kb
	Set:$$$CanSetProperty(model,"globals32kb") properties("globals32kb") = model.globals32kb
	Set:$$$CanSetProperty(model,"globals4kb") properties("globals4kb") = model.globals4kb
	Set:$$$CanSetProperty(model,"globals64kb") properties("globals64kb") = model.globals64kb
	Set:$$$CanSetProperty(model,"globals8kb") properties("globals8kb") = model.globals8kb
	Set:$$$CanSetProperty(model,"gmheap") properties("gmheap") = model.gmheap
	Set:$$$CanSetProperty(model,"ijcbuff") properties("ijcbuff") = model.ijcbuff
	Set:$$$CanSetProperty(model,"ijcnum") properties("ijcnum") = model.ijcnum
	Set:$$$CanSetProperty(model,"jrnbufs") properties("jrnbufs") = model.jrnbufs
	Set:$$$CanSetProperty(model,"locksiz") properties("locksiz") = model.locksiz
	Set:$$$CanSetProperty(model,"netjob") properties("netjob") = model.netjob
	Set:$$$CanSetProperty(model,"nlstab") properties("nlstab") = model.nlstab
	Set:$$$CanSetProperty(model,"pijdir") properties("pijdir") = model.pijdir
	Set:$$$CanSetProperty(model,"routines") properties("routines") = model.routines
	Set:$$$CanSetProperty(model,"targwijsz") properties("targwijsz") = model.targwijsz
	Set:$$$CanSetProperty(model,"udevtabsiz") properties("udevtabsiz") = model.udevtabsiz
	Set:$$$CanSetProperty(model,"useresidentmem") properties("useresidentmem") = model.useresidentmem
	Set:$$$CanSetProperty(model,"wijdir") properties("wijdir") = model.wijdir
	Quit
]]></Implementation>
</Method>

<Method name="ToDynamic">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&properties:%Binary]]></FormalSpec>
<ReturnType>%Library.DynamicObject</ReturnType>
<Implementation><![CDATA[
	Set model = {}
	Do:$Data(properties("BackoffDisabled")) model.%Set("BackoffDisabled", properties("BackoffDisabled"), "boolean")
	Do:$Data(properties("CPFFile")) model.%Set("CPFFile", properties("CPFFile"), "string")
	Do:$Data(properties("Comments")) model.%Set("Comments", properties("Comments"), "string")
	Do:$Data(properties("ConsoleFile")) model.%Set("ConsoleFile", properties("ConsoleFile"), "string")
	Do:$Data(properties("Flags")) model.%Set("Flags", properties("Flags"), "number")
	Do:$Data(properties("LargePagesDisabled")) model.%Set("LargePagesDisabled", properties("LargePagesDisabled"), "boolean")
	Do:$Data(properties("LargePagesRequired")) model.%Set("LargePagesRequired", properties("LargePagesRequired"), "boolean")
	Do:$Data(properties("LibPath")) model.%Set("LibPath", properties("LibPath"), "string")
	Do:$Data(properties("LineRecallBuffer")) model.%Set("LineRecallBuffer", properties("LineRecallBuffer"), "number")
	Do:$Data(properties("LineRecallEntries")) model.%Set("LineRecallEntries", properties("LineRecallEntries"), "number")
	Do:$Data(properties("LockSharedMemory")) model.%Set("LockSharedMemory", properties("LockSharedMemory"), "boolean")
	Do:$Data(properties("LockTextSegment")) model.%Set("LockTextSegment", properties("LockTextSegment"), "boolean")
	Do:$Data(properties("MaxServerConn")) model.%Set("MaxServerConn", properties("MaxServerConn"), "number")
	Do:$Data(properties("MaxServers")) model.%Set("MaxServers", properties("MaxServers"), "number")
	Do:$Data(properties("Name")) model.%Set("Name", properties("Name"), "string")
	Do:$Data(properties("VMSConsoleTerminal")) model.%Set("VMSConsoleTerminal", properties("VMSConsoleTerminal"), "string")
	Do:$Data(properties("ZFSize")) model.%Set("ZFSize", properties("ZFSize"), "number")
	Do:$Data(properties("ZFString")) model.%Set("ZFString", properties("ZFString"), "number")
	Do:$Data(properties("bbsiz")) model.%Set("bbsiz", properties("bbsiz"), "number")
	Do:$Data(properties("console")) model.%Set("console", properties("console"), "string")
	Do:$Data(properties("errlog")) model.%Set("errlog", properties("errlog"), "number")
	Do:$Data(properties("globals")) model.%Set("globals", properties("globals"), "string")
	Do:$Data(properties("globals16kb")) model.%Set("globals16kb", properties("globals16kb"), "number")
	Do:$Data(properties("globals32kb")) model.%Set("globals32kb", properties("globals32kb"), "number")
	Do:$Data(properties("globals4kb")) model.%Set("globals4kb", properties("globals4kb"), "number")
	Do:$Data(properties("globals64kb")) model.%Set("globals64kb", properties("globals64kb"), "number")
	Do:$Data(properties("globals8kb")) model.%Set("globals8kb", properties("globals8kb"), "number")
	Do:$Data(properties("gmheap")) model.%Set("gmheap", properties("gmheap"), "number")
	Do:$Data(properties("history")) model.%Set("history", properties("history"), "string")
	Do:$Data(properties("ijcbuff")) model.%Set("ijcbuff", properties("ijcbuff"), "number")
	Do:$Data(properties("ijcnum")) model.%Set("ijcnum", properties("ijcnum"), "number")
	Do:$Data(properties("jrnbufs")) model.%Set("jrnbufs", properties("jrnbufs"), "number")
	Do:$Data(properties("locksiz")) model.%Set("locksiz", properties("locksiz"), "number")
	Do:$Data(properties("memlock")) model.%Set("memlock", properties("memlock"), "number")
	Do:$Data(properties("netjob")) model.%Set("netjob", properties("netjob"), "boolean")
	Do:$Data(properties("nlstab")) model.%Set("nlstab", properties("nlstab"), "number")
	Do:$Data(properties("overview")) model.%Set("overview", properties("overview"), "string")
	Do:$Data(properties("pijdir")) model.%Set("pijdir", properties("pijdir"), "string")
	Do:$Data(properties("routines")) model.%Set("routines", properties("routines"), "string")
	Do:$Data(properties("targwijsz")) model.%Set("targwijsz", properties("targwijsz"), "number")
	Do:$Data(properties("udevtabsiz")) model.%Set("udevtabsiz", properties("udevtabsiz"), "number")
	Do:$Data(properties("useresidentmem")) model.%Set("useresidentmem", properties("useresidentmem"), "string")
	Do:$Data(properties("wijdir")) model.%Set("wijdir", properties("wijdir"), "string")
	Quit model
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>model:%Library.DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..ToArray(model,.properties)
	$$$switchNSSys
	Quit ##class(Config.config).Modify(.properties)
]]></Implementation>
</Method>
</Class>


<Class name="Api.Config.TempStream">
<Description>
Description</Description>
<Super>%Persistent</Super>
<TimeChanged>65834,73166.761186</TimeChanged>
<TimeCreated>65834,73166.761186</TimeCreated>

<Property name="created">
<Type>%TimeStamp</Type>
<InitialExpression>$zdatetime($HOROLOG,3,1)</InitialExpression>
</Property>

<Property name="name">
<Type>%String</Type>
</Property>

<Property name="charStream">
<Type>%Stream.GlobalCharacter</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Api.Config.TempStreamD</DataLocation>
<DefaultData>TempStreamDefaultData</DefaultData>
<IdLocation>^Api.Config.TempStreamD</IdLocation>
<IndexLocation>^Api.Config.TempStreamI</IndexLocation>
<StreamLocation>^Api.Config.TempStreamS</StreamLocation>
<Data name="TempStreamDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>created</Value>
</Value>
<Value name="3">
<Value>name</Value>
</Value>
<Value name="4">
<Value>charStream</Value>
</Value>
</Data>
</Storage>
</Class>
<Class name="IORedirect.InputHandler">
<Abstract>1</Abstract>
<IncludeCode>IORedirect</IncludeCode>
<TimeChanged>65834,73166.149478</TimeChanged>
<TimeCreated>65834,73166.149478</TimeCreated>

<Parameter name="USETIMEOUT">
<Default>0</Default>
</Parameter>

<Method name="InChar">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="InString">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.InputStream">
<IncludeCode>IORedirect</IncludeCode>
<Super>InputHandler</Super>
<TimeChanged>65834,73166.170415</TimeChanged>
<TimeCreated>65834,73166.170415</TimeCreated>

<Method name="InChar">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Quit:'$ISOBJECT($Get($$$RedirectInputStream)) -1
    Quit $ASCII($$$RedirectInputStream.Read(1))
]]></Implementation>
</Method>

<Method name="InString">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Quit:'$ISOBJECT($Get($$$RedirectInputStream)) ""
    Quit:size="" $$$RedirectInputStream.ReadLine()
    Quit $$$RedirectInputStream.Read(size)
]]></Implementation>
</Method>

<Method name="SetStream">
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(stream)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputStream = stream
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.InputString">
<IncludeCode>IORedirect</IncludeCode>
<Super>InputHandler</Super>
<TimeChanged>65834,73166.148957</TimeChanged>
<TimeCreated>65834,73166.148957</TimeCreated>

<Method name="InChar">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    Set char = $ASCII($Extract(..Get()))
    Do ..Set($Extract(..Get(), 2, *))
    Quit char
]]></Implementation>
</Method>

<Method name="InString">
<Description>
Timeout parameter won't used in this subclass.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>size:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If size '= "" {
        Set buffer = $Extract(..Get(), 1, size)
        Do ..Set($Extract(..Get(), size+1, *))
        Quit buffer
    }

    Set buffer = $Piece(..Get(), $$$NL, 1)
    Do ..Set($Piece(..Get(), $$$NL, 2, *))
    Quit buffer
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Get($$$RedirectInputString)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputString = string
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputGlobal">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>65834,73166.150707</TimeChanged>
<TimeCreated>65834,73166.150707</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Kill @$$$RedirectGblName
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetRedirectLocation">
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(globalName)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>globalName:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectGbl = globalName
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectGblName
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[    Do ..OutString($Char(char))
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Set gbl = $$$RedirectGblName
    Set:'$Data(@gbl) @gbl = 1
    Set @gbl@(@gbl) =  $Get(@gbl@(@gbl)) _ string
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<Implementation><![CDATA[$Increment(@$$$RedirectGblName)
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputHandler">
<Description>
Description</Description>
<Abstract>1</Abstract>
<TimeChanged>65834,73166.180121</TimeChanged>
<TimeCreated>65834,73166.180121</TimeCreated>

<Method name="OutChar">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutString">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutNewLine">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OutTab">
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    $$$ThrowStatus($$$ERROR($$$NotImplemented))
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputStream">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>65834,73166.17993</TimeChanged>
<TimeCreated>65834,73166.17993</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set stream = $$$RedirectStream
    Do:$Isobject(stream) stream.Clear()
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetStream">
<Description>
Description</Description>
<Deprecated>1</Deprecated>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set(stream)
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectStream = stream
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
    Quit:$ISOBJECT($Get($$$RedirectStream)) $$$RedirectStream
    Do ..SetStream()
    Quit $$$RedirectStream
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[
    Do ..OutString($Char(char))
    Quit
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Do ..Get().Write(string)
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString(..Get().LineTerminator)
    Quit
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim sc As %Status = $$$OK
    #dim stream As %Stream.Object = ..Get()
    If stream.%IsA("%Stream.FileBinary") { 
        Set sc = stream.%Save()
    }
    Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.OutputString">
<IncludeCode>IORedirect</IncludeCode>
<Super>IORedirect.OutputHandler</Super>
<TimeChanged>65834,73166.171347</TimeChanged>
<TimeCreated>65834,73166.171347</TimeCreated>

<Method name="Clear">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..Set("")
]]></Implementation>
</Method>

<Method name="Set">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectString = string
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<ClassMethod>1</ClassMethod>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[    Quit $Get($$$RedirectString)
]]></Implementation>
</Method>

<Method name="OutChar">
<ClassMethod>1</ClassMethod>
<FormalSpec>char:%Integer</FormalSpec>
<Implementation><![CDATA[
    Do ..OutString($Char(char))
    Quit
]]></Implementation>
</Method>

<Method name="OutString">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Implementation><![CDATA[
    Set $$$RedirectString = $$$RedirectString _ string
    Quit
]]></Implementation>
</Method>

<Method name="OutFormFeed">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(12))
    Quit
]]></Implementation>
</Method>

<Method name="OutNewLine">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($$$NL)
    Quit
]]></Implementation>
</Method>

<Method name="OutTab">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..OutString($Char(9))
    Quit
]]></Implementation>
</Method>

<Method name="OnStopRedirect">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="IORedirect.Redirect">
<IncludeCode>IORedirect</IncludeCode>
<TimeChanged>65834,73166.200785</TimeChanged>
<TimeCreated>65834,73166.200785</TimeCreated>

<Parameter name="OUTPUTSTREAM">
<Default>IORedirect.OutputStream</Default>
</Parameter>

<Parameter name="OUTPUTGLOBAL">
<Default>IORedirect.OutputGlobal</Default>
</Parameter>

<Parameter name="OUTPUTSTRING">
<Default>IORedirect.OutputString</Default>
</Parameter>

<Parameter name="INPUTSTREAM">
<Default>IORedirect.InputStream</Default>
</Parameter>

<Parameter name="INPUTSTRING">
<Default>IORedirect.InputString</Default>
</Parameter>

<Method name="RedirectIO">
<Description><![CDATA[
Class this method to Enable the redirect<br/>
OutputHandler must be a subclass name of IORedirect.OutputHandler<br/>
If you want to handle Input, you can fill InputHandler with a subclass name of IORedirect.InputHandler<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String,InputHandler:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$OldIO = $IO
    Set $$$OldMnemonic = ##class(%Library.Device).GetMnemonicRoutine()
    Set $$$OldState = ##class(%Library.Device).ReDirectIO()

    Do ..SetInputHandler(InputHandler), ..SetOuputHandler(OutputHandler)

    Use $IO::("^"_$ZNAME)

    Do ##class(%Library.Device).ReDirectIO(1)

    Quit $$$OK
]]></Implementation>
</Method>

<Method name="RestoreIO">
<Description><![CDATA[
Stop the redirect and restore original IO Setting.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Quit:'$Data($$$OldState) $$$OK
    
    If $Get($$$OldMnemonic) '= "" {
        Use $$$OldIO::("^"_$$$OldMnemonic)
    } Else {
        Use $$$OldIO
    }

    Do ##class(%Library.Device).ReDirectIO($$$OldState)
    $$$KillOldStateData

    Do $CLASSMETHOD($$$RedirectOutputHandler, "OnStopRedirect")
    
    Do ..SetInputHandler(""), ..SetOuputHandler("")
    
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<Description>
Return the output value depending the last used output hander:
OutputGlobal : String with the global name.
OutputString : String with the output value.
OutputStream : Stream with the output value.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit $CLASSMETHOD($$$LastOutputHandler, "Get")
]]></Implementation>
</Method>

<Method name="ToStream">
<Description>
Enable Output Redirection to a Stream object.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTREAM))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTSTREAM, "Set", stream))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToString">
<Description>
Enable output redirect to a string.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTRING))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTSTRING, "Set", ""))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToFileCharacter">
<Description>
Enable output redirect to a file.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>fileName:%String</FormalSpec>
<Implementation><![CDATA[
    #dim fcs As %Stream.FileCharacter = ##class(%Stream.FileCharacter).%New()
    Set dir = ##class(%File).GetDirectory(fileName)
    Do:'##class(%File).DirectoryExists(dir) ##class(%File).CreateDirectoryChain(dir)
    Do fcs.LinkToFile(fileName)
    $$$QuitOnError(..RedirectIO(..#OUTPUTSTREAM))

    Quit $CLASSMETHOD(..#OUTPUTSTREAM, "SetStream", fcs)
]]></Implementation>
</Method>

<Method name="ToGlobal">
<Description>
Enable Output redirection to a global.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>global:%String=$Name(^||IORedirect)</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$QuitOnError(..RedirectIO(..#OUTPUTGLOBAL))
    $$$QuitOnError($CLASSMETHOD(..#OUTPUTGLOBAL, "Set", global))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InputStream">
<Description>
Enable Read from a stream.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream.Object=##class(%Stream.GlobalCharacter).%New()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetInputHandler(..#INPUTSTREAM), $CLASSMETHOD(..#INPUTSTREAM, "Set", stream)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="InputString">
<Description>
Enable Read from a string.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>inputString:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Do ..SetInputHandler(..#INPUTSTRING), $CLASSMETHOD(..#INPUTSTRING, "Set", inputString)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetOuputHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set:OutputHandler'="" $$$LastOutputHandler = OutputHandler
    Set $$$RedirectOutputHandler = OutputHandler
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetOuputHandler">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectOutputHandler
]]></Implementation>
</Method>

<Method name="SetInputHandler">
<ClassMethod>1</ClassMethod>
<FormalSpec>OutputHandler:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $$$RedirectInputHandler = OutputHandler
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInputHandler">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RedirectInputHandler
]]></Implementation>
</Method>

<Method name="ClearConfig">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$ClearConfig
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="labels">
<ClassMethod>1</ClassMethod>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
    Quit
rchr(c)      Quit:$Get($$$RedirectInputHandler)=""  Quit $$$CallReadChar($Get(c))
rstr(sz,to)  Quit:$Get($$$RedirectInputHandler)=""  Quit $$$CallReadString($g(sz),$g(to))
wchr(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutChar",s)  Quit
wstr(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutString",s)  Quit
wff()        Do $CLASSMETHOD($$$RedirectOutputHandler,"OutFormFeed")  Quit
wnl()        Do $CLASSMETHOD($$$RedirectOutputHandler,"OutNewLine")  Quit
wtab(s)      Do $CLASSMETHOD($$$RedirectOutputHandler,"OutTab")  Quit
]]></Implementation>
</Method>
</Class>
</Export>
